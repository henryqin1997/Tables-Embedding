{"relation": [["", "", "", "", "", "", "", ""], ["t", "new_position", "mirror", "only_portals", "crossed_portals", "portal_meshes", "firstIndex", "lastIndex"], ["The transform to the start of the segment", "The end of the segment, in world coordinates", "Unused parameter...", "Whether the collision has to be checked only with the portals, or also with all meshes", "The list where will be stored all portals that are crossed during the following of this segment", "The list where will be stored the portal container of all the portals that are crossed during the following of this segment", "The starting index where the portals will be stored in the crossed_portals and portal_meshes lists.", "The place where will be stored the index of the last portal crossed"]], "pageTitle": "Crystal Space 2.0: iSector Struct Reference (Crystal Space 2.0 Public API Reference)", "title": "", "url": "http://www.crystalspace3d.org/docs/online/api-2.0/structiSector.html", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 12, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042987174.71/warc/CC-MAIN-20150728002307-00310-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 382898071, "recordOffset": 382883344, "tableOrientation": "HORIZONTAL", "lastModified": "Sun, 22 Jul 2012 20:19:31 GMT", "textBeforeTable": "Parameters: If only_portals is true then only portals will be checked. This means that intersection with normal polygons is not checked. This is a lot faster but it does mean that you need to use another collision detection system to test with walls. This function returns the resulting sector, and new_position will be set to the last position that you can go to before hitting a wall. This routine will modify all the given parameters to reflect space warping. These should be used as the new camera transformation when you decide to really go to the new position. If the segment intersects with a polygon it will stop there unless the polygon is a portal in which case it will recursively go to that sector (possibly applying warping transformations) and continue there. Follow a segment starting at this sector. [pure virtual] ) \u00a0 lastIndex = 0 int *\u00a0 firstIndex = 0, int\u00a0 portal_meshes = 0, iMeshWrapper **\u00a0 crossed_portals = 0, iPortal **\u00a0 only_portals = false, bool\u00a0 mirror, bool &\u00a0 new_position,", "textAfterTable": "Warning: The crossed_portals and portal_meshes arrays must be allocated to a sufficient size The crossed_portals and portal_meshes arrays won't be filled with crossed portals if lastIndex is not provided virtual csColor iSector::GetDynamicAmbientLight ( \u00a0)\u00a0 const [pure virtual] Get the last set dynamic ambient light for this sector. virtual uint iSector::GetDynamicAmbientVersion ( \u00a0)\u00a0 const [pure virtual] Get the version number of the dynamic ambient color. This number is increased whenever dynamic ambient changes. virtual const csFog& iSector::GetFog ( \u00a0)\u00a0 const [pure virtual] Return the fog structure (even if fog is disabled). virtual iLightList* iSector::GetLights ( \u00a0)\u00a0 [pure virtual] Get the list", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}