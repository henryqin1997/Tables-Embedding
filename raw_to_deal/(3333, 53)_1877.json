{"relation": [["Guest Name", "fivetime", "fourtime", "threetime", "twotime", "onetime"], ["cpu.share given", "512", "1024", "1024", "1536", "1024"], ["percentage of cpu", "10%", "20%", "20%", "30%", "20%"]], "pageTitle": "util-vserver:Cgroups - Linux-VServer", "title": "", "url": "http://linux-vserver.org/index.php?title=util-vserver:Cgroups&oldid=4383", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 1, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988065.26/warc/CC-MAIN-20150728002308-00318-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 145657715, "recordOffset": 145643454, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{8243=This feature is currently available in patch-2.6.32.20-vs2.3.0.36.29.6.diff and is in testing phase as of this patch set so report any bugs to the mailing list., 19785=Squeeze is due to ship with the 2.6.32 kernel. Currently the package linux-image-2.6.32-5-vserver-amd64 works well for cgroup scheduling. The following steps are simplest way to set it up:, 12583=I used the kernels from [2], described at [3]. I've done this on a few versions, works for 2.6.31.7 with patch vs2.3.0.36.27 on amd64, also 2.6.31.11 with patch vs2.3.0.36.28. I used the stock Lenny util-vserver, patched as described below. The kernel config is critically important, with specific cgroup options necessary in order to get cgroups working in this way. Check the configs for the [4] kernels to see which ones I used., 8427=To get the hard limit setup on every vServer start you need a recent utils package. It worked for me with: 0.30.216-pre2864. (Download from util-vserver prereleases), 10249=in linux-vserver patch version vs2.3.0.36.29 memory limiting by cgroup is introduced. to use it you need to have the following config lines in your kernel build (aditionally to the others mentioned for cgroup cpu limits):}", "textBeforeTable": "Then started the guests. When the system was loaded (I used one instance of cpuburn on each server - not advised but a useful test) they each should have got the following percentage of CPU. echo \"1024\" > /etc/vservers/onetime/cgroup/cpu.shares echo \"1536\" > /etc/vservers/twotime/cgroup/cpu.shares echo \"1024\" > /etc/vservers/threetime/cgroup/cpu.shares echo \"1024\" > /etc/vservers/fourtime/cgroup/cpu.shares echo \"512\" > /etc/vservers/fivetime/cgroup/cpu.shares mkdir /etc/vservers/fivetime/cgroup/ /etc/vservers/fourtime/cgroup/ /etc/vservers/threetime/cgroup/ /etc/vservers/twotime/cgroup/ /etc/vservers/twotime/cgroup/ I have a few test guests hanging around that I play with, call onetime, twotime, threetime, fourtime and fivetime. I order to set the shares for each guest I did this:   Sharing out the CPU between guest servers  $ mkdir /etc/vservers/.defaults/cgroup For the util-vserver to do the right thing, this directory needed adding too:  $ mount -t cgroup vserver /dev/cgroup $ mkdir /dev/cgroup Next I added a correctly mounted cgroup file system on /dev/cgroup/.  shift user=$1 +attachToCgroup \"$VSERVER_DIR\" +addtoCPUSET \"$VSERVER_DIR\" -addtoCPUSET \"$VSERVER_DIR\" generateOptions \"$VSERVER_DIR\" } exit 1 @@ -22,7 +22,8 @@ test -z \"$is_stopped\" -o \"$OPTION_INSECU +++ /usr/lib/util-vserver/vserver.suexec 2009-08-20 02:11:42.000000000 -0500 --- /usr/lib/util-vserver/vserver.suexec.orig\t2008-12-12 22:56:25.000000000 -0600 There's a very old version of util-vserver on Lenny, it needs this patch applying before it will set the cgroups properly, it basically only adds one line:   Getting Lenny Ready  I used the kernels from [2], described at [3]. I've done this on a few versions, works for 2.6.31.7 with patch vs2.3.0.36.27 on amd64, also 2.6.31.11 with patch", "textAfterTable": "This didn't quite happen, as each process could migrate to other CPUs. When I fixed every guest to use only one of the available CPUs (see below how I did this) the percentage of processing time alloted to each guest were then pretty much exact! Each process was given exactly it's designated percentage of time according to vtop. Dishing out different processors sets to different guest servers The \"cpuset\" for each guest is the subset of CPUs which it is permitted to use. I found out the number of CPUs available on my system by doing this: $ cat /dev/cgroup/cpuset.cpus This gave me the result 0-1, meaning that the overall set for my cgroups consists of CPUs 0 and 1 (for a quad core system one would expect the result 0-3, or for quad core with HT, 0-7). I stopped my guests, then for each guest specified a cpuset containing only CPU 0 for each of them: $ echo \"0\" > /etc/vservers/onetime/cgroup/cpuset.cpus $ echo \"0\" > /etc/vservers/twotime/cgroup/cpuset.cpus $ echo \"0\" > /etc/vservers/threetime/cgroup/cpuset.cpus $ echo \"0\" > /etc/vservers/fourtime/cgroup/cpuset.cpus $ echo \"0\" > /etc/vservers/fivetime/cgroup/cpuset.cpus On restarting the guest, I could see (using vtop) that these guest were only using the CPU 0 (the column \"Last used cpu (SMP)\" needs to be on in vtop in order to see this). This set up isn't particularly useful, but did allow me to check that the cpu.shares I specified for my guest were working", "hasKeyColumn": true, "keyColumnIndex": 0, "headerRowIndex": 0}