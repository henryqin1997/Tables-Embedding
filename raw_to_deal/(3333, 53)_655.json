{"relation": [["Data Attributes", "ALIGNED", "AREA[( area-size)]", "BINARY [(precision)] or BIN...", "BIT [(maximum-length)]", "CHARACTER[(maximum-length)] or CHAR...", "COMPLEX [(precision)] or CPLX...", "DECIMAL [(precision)] or DEC...", "(dimension-attribute)", "ENTRY[(parameter descriptor list]", "FILE", "FIXED [(precision)]", "FLOAT [(number of digits)]", "FORMAT", "LABEL", "MEMBER", "NONVARYING or NONVAR", "OFFSET[(reference)]", "PICTURE picture-specification or PIC...", "POINTER or PTR", "STRUCTURE", "UNALIGNED or UNAL", "VARYING or VAR"], ["Input/Output Attributes", "DIRECT", "ENVIRONMENT(options) or ENV...", "INPUT", "KEYED", "OUTPUT", "PRINT", "SEQUENTIAL or SEQL", "STREAM", "UPDATE", "RECORD", "", "", "", "", "", "", "", "", "", "", "", ""], ["Other Attributes", "AUTOMATIC or AUTO", "BASED[(reference)", "BUILTIN", "CONDITION or COND", "CONSTANT", "CONTROLLED or CTL", "DEFINED[( reference)] or DEF...", "EXTERNAL or EXT", "GENERIC(criteria list)", "INITIAL(value-list) or INIT...", "INTERNAL or INT", "LIKE unsubscripted reference", "LOCAL", "OPTIONS(options)", "PARAMETER or PARM", "POSITION [(expression)] or POS...", "STATIC", "VARIABLE", "", "", "", ""]], "pageTitle": "PL/I - Wikipedia, the free encyclopedia", "title": "", "url": "https://en.wikipedia.org/wiki/PL/I_programming_language", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 6, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042981753.21/warc/CC-MAIN-20150728002301-00010-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 838703223, "recordOffset": 838654916, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{48663=Compilers were implemented by several groups in the early 1960s. The Multics project at MIT, one of the first to develop an operating system in a high level language, used Early PL/I (EPL), a subset dialect of PL/I, as their implementation language in 1964. EPL was developed at Bell Labs and MIT by Douglas McIlroy, Robert Morris, and others. The influential Multics PL/I compiler, described on the \"Multicians\" website,[22] was the source of compiler technology used by a number of manufacturers and software groups., 51261=The PL/I optimizing compiler took over from the PL/I F compiler and was IBM\u2019s workhorse compiler from the 1970s to the 1990s. Like PL/I F, it was a multiple pass compiler with a 44 kilobyte design point, but it was an entirely new design. Unlike the F compiler, it had to perform compile time evaluation of constant expressions using the run-time library, reducing the maximum memory for a compiler phase to 28 kilobytes. A second-time around design, it succeeded in eliminating the annoyances of PL/I F such as cascading diagnostics. It was written in S/360 Macro Assembler by a team, led by Tony Burbridge, most of whom had worked on PL/I F. Macros were defined to automate common compiler services and to shield the compiler writers from the task of managing real-mode storage, allowing the compiler to be moved easily to other memory models. The gamut of program optimization techniques developed for the contemporary IBM Fortran H compiler were deployed: the Optimizer equaled Fortran execution speeds in the hands of good programmers. Announced with the IBM S/370 in 1970, it shipped first for the DOS/360 operating system in August 1971, and shortly afterward for OS/360, and the first virtual memory IBM operating systems OS/VS1, MVS, and VM/CMS. (The developers were unaware that while they were shoehorning the code into 28 kb sections, IBM Poughkeepsie was finally ready to ship virtual memory support in OS/360). It supported the batch programming environments and, under TSO and CMS, it could be run interactively. This compiler went through many versions covering all mainframe operating systems including the operating systems of the Japanese PCMs., 54783=Perhaps the most commercially successful implementation aside from IBM's was Digital Equipment's 1988 release of the ANSI PL/I 1987 subset. The implementation is \"a strict superset of the ANSI X3.4-1981 PL/I General Purpose Subset and provides most of the features of the new ANSI X3.74-1987 PL/I General Purpose Subset\".[28] The front end was designed by Robert Freiburghouse, and the code generator was implemented by Dave Cutler, who managed the design and implementation of VAX/VMS. It runs on VMS on VAX and ALPHA and on Tru64. UniPrise Systems, Inc., was responsible for the compiler;[29] it is currently supported by Kednos Corporation.[30], 15954=In the 1950s and early 1960s business and scientific users programmed for different computer hardware using different programming languages. Business users were moving from Autocoders via COMTRAN to COBOL, while scientific users programmed in General Interpretive Programme (GIP), Fortran, ALGOL, GEORGE, and others. The IBM System/360[3] (announced in 1964 but not delivered until 1966) was designed as a common machine architecture for both groups of users, superseding all existing IBM architectures. Similarly, IBM wanted a single programming language for all users. It hoped that Fortran could be extended to include the features needed by commercial programmers. In October 1963 a committee was formed[4] composed originally of 3 IBMers from New York and 3 members of SHARE, the IBM scientific users group, to propose these extensions to Fortran. Given the constraints of Fortran, they were unable to do this and embarked on the design of a \u201cnew programming language\u201d based loosely on Algol labeled \u201cNPL\". This acronym conflicted with that of the UK\u2019s National Physical Laboratory and was replaced briefly by MPPL (MultiPurpose Programming Language) and, in 1965, with PL/I (with a Roman numeral \u201cI\u201d ). The first definition appeared in April 1964.[5][6], 39852=Language standardization began in April 1966 in Europe with ECMA TC10. In 1969 ANSI established a \"Composite Language Development Committee\", nicknamed \"Kludge\", which fortunately was renamed X3J1 PL/I.[14] Standardization became a joint effort of ECMA TC/10 and ANSI X3J1. A subset of the GY33-6003[15] document was offered to the joint effort by IBM and became the base document for standardization. The major features omitted from the base document were multitasking and the attributes for program optimization (e.g. NORMAL and ABNORMAL)., 53244=The PL/I checkout compiler,[26][27] (colloquially \"The Checker\") announced in August 1970 was designed to speed and improve the debugging of PL/I programs. The team was led by Brian Marks. The three-pass design cut the time to compile a program to 25% of that taken by the F Compiler. It was run from an interactive terminal, converting PL/I programs into an internal format, \u201cH-text\u201d. This format was interpreted by the Checkout compiler at run-time, detecting virtually all types of errors. Pointers were represented in 16 bytes, containing the target address and a description of the referenced item, thus permitting \"bad\" pointer use to be diagnosed. In a conversational environment when an error was detected, control was passed to the user who could inspect any variables, introduce debugging statements and edit the source program. Over time the debugging capability of mainframe programming environments developed most of the functions offered by this compiler and it was withdrawn (in the 1990s?), 18185=IBM took NPL as a starting point and completed the design to a level that the first compiler could be written: the NPL definition was incomplete in scope and in detail.[7] Control of the PL/I language[8] was vested initially in the New York Programming Center and later at the IBM UK Laboratory at Hursley. The SHARE and GUIDE user groups were involved in extending the language and had a role in IBM\u2019s process for controlling the language through their PL/I Projects. The experience of defining such a large language showed the need for a formal definition of PL/I. A project was set up in 1967 in IBM Vienna to make an unambiguous and complete specification.[9] This led in turn to one of the first large scale Formal Methods for development, VDM., 106721=Passing a variable as an argument to a parameter by reference allows the argument's allocated storage to be referenced using the parameter. The DEFINED attribute (e.g. DCL A(10,10), B(2:9,2:9) DEFINED A) allows part or all of a variable's storage to be used with a different, but consistent, declaration. These two usages are safe and machine independent., 43921=A \"PL/I General-Purpose Subset\" (\"Subset-G\") standard was issued by ANSI in 1981[13] and a revision published in 1987.[17] The General Purpose subset was widely adopted as the kernel for PL/I implementations., 45055=PL/I was first implemented by IBM, at its Hursley Laboratories in the United Kingdom, as part of the development of System/360. The first production PL/I compiler was the PL/I F compiler for the OS/360 Operating System, built by John Nash's team at Hursley in the UK: the runtime library team was managed by I.M. (Nobby) Clarke. The PL/I F compiler was written entirely in System/360 assembly language.[18] Release 1 shipped in 1966. OS/360 was a real-memory environment and the compiler was designed for systems with as little as 64 kilobytes of real storage \u2013 F being 64 kB in S/360 parlance. To fit a large compiler into the 44 kilobytes of memory available on a 64-kilobyte machine, the compiler consisted of a control phase and a large number of compiler phases (approaching 100). The phases were brought into memory from disk, and released, one at a time to handle particular language features and aspects of compilation., 19900=The first compiler was delivered in 1966. The Standard for PL/I was approved in 1976., 59395=In a major revamp of PL/I, IBM Santa Teresa in California launched an entirely new compiler in 1992. The initial shipment was for OS/2 and included most ANSI-G features and many new PL/I features.[36] Subsequent releases covered additional platforms (MVS, VM, OS/390, AIX and Windows)[37] and continued to add functions to make PL/I fully competitive with other languages offered on the PC (particularly C and C++) in areas where it had been overtaken. The corresponding \u201cIBM Language Environment\" supports inter-operation of PL/I programs with Database and Transaction systems, and with programs written in C, C++, and COBOL, the compiler supports all the data types needed for intercommunication with these languages., 19441=The language was first specified in detail in the manual \u201cPL/I Language Specifications. C28-6571\u201d written in New York from 1965 and superseded by \u201cPL/I Language Specifications. GY33-6003\u201d written in Hursley from 1967. IBM continued to develop PL/I in the late sixties and early seventies, publishing it in the GY33-6003 manual. These manuals were used by the Multics group and other early implementers.}", "lastModified": "Mon, 27 Jul 2015 22:06:24 GMT", "textBeforeTable": "A declaration of an identifier may contain one or more of the following attributes (but they need to be mutually consistent): AREA, CONDITION(identifier), ERROR, FINISH or one of the conditions: UNDEFINEDFILE(file) (UNDF) TRANSMIT(file) RECORD(file) NAME(file) KEY(file) ENDPAGE(file) ENDFILE(file) or an Input/Output condition, ZERODIVIDE (ZDIV) UNDERFLOW (UFL) SUBSCRIPTRANGE (SUBRG) STRINGSIZE (STRZ) STRINGRANGE (STRG) SIZE OVERFLOW (OFL) FIXEDOVERFLOW (FOFL) CONVERSION (CONV) a computational condition, An on-unit is a single statement or block of statements written to be executed when one or more of these conditions occur: A sequence of statements becomes a group when preceded by a DO statement and followed by an END statement. Groups may include nested groups and begin blocks. The IF statement specifies a group or a single statement as the THEN part and the ELSE part (see the sample program). The group is the unit of iteration. The begin block (BEGIN; stmt-list END;) may contain declarations for names and internal procedures local to the block. A procedure starts with a PROCEDURE statement and is terminated syntactically by an END statement. The body of a procedure is a sequence of blocks, groups, and statements and contains declarations for names and procedures local to the procedure or EXTERNAL to the procedure. There are no reserved words in PL/I. A statement is terminated by a semi-colon.", "textAfterTable": "Current compilers from Kednos, Micro Focus, and particularly that from IBM implement many extensions over the standardized version of the language. The IBM extensions are summarised in the Implementation sub-section for the compiler later. Although there are some extensions common to these compilers the lack of a current standard means that compatibility is not guaranteed. Standardization[edit] Language standardization began in April 1966 in Europe with ECMA TC10. In 1969 ANSI established a \"Composite Language Development Committee\", nicknamed \"Kludge\", which fortunately was renamed X3J1 PL/I.[14] Standardization became a joint effort of ECMA TC/10 and ANSI X3J1. A subset of the GY33-6003[15] document was offered to the joint effort by IBM and became the base document for standardization. The major features omitted from the base document were multitasking and the attributes for program optimization (e.g. NORMAL and ABNORMAL). Proposals to change the base document were voted upon by both committees. In the event that the committees disagreed, the chairs, initially Michael Marcotty of General Motors and C.A.R. Hoare representing ICL had to resolve the disagreement. In addition to IBM, Honeywell, CDC, Data General, Digital Equipment, Prime Computer,", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}