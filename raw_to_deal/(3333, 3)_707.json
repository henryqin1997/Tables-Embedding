{"relation": [["Original Target", "GL_TEXTURE_1D", "GL_TEXTURE_2D", "GL_TEXTURE_3D", "GL_TEXTURE_CUBE_MAP", "GL_TEXTURE_RECTANGLE", "GL_TEXTURE_BUFFER", "GL_TEXTURE_1D_ARRAY", "GL_TEXTURE_2D_ARRAY", "GL_TEXTURE_CUBE_MAP_ARRAY", "GL_TEXTURE_2D_MULTISAMPLE", "GL_TEXTURE_2D_MULTISAMPLE_ARRAY"], ["Compatible New Targets", "GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY", "GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY", "GL_TEXTURE_3D", "GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTUER_CUBE_MAP_ARRAY", "GL_TEXTURE_RECTANGLE", "none. Cannot be used with this function.", "GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY", "GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_ARRAY, GL_TEXTUER_CUBE_MAP_ARRAY", "GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTUER_CUBE_MAP_ARRAY", "GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY", "GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY"]], "pageTitle": "Difference between revisions of \"Texture Storage\" - OpenGL.org", "title": "", "url": "https://www.opengl.org/wiki_132/index.php?title=Texture_Storage&diff=8043&oldid=8042", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 4, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988051.33/warc/CC-MAIN-20150728002308-00021-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 930640415, "recordOffset": 930622805, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{45304=Note that what immutable storage refers to is the allocation of the memory, not the contents of that memory. You can upload different pixel data to immutable storage all you want. You simply can't change a 256x256 texture into a 1024x1024 texture the way you can with mutable storage., 43316=Note that what immutable storage refers to is the allocation of the memory, not the contents of that memory. You can upload different pixel data to immutable storage all you want. With mutable storage, you can re-vamp the storage of a texture object entirely, changing a 256x256 texture into a 1024x1024 texture.}", "textBeforeTable": "Here is a table describing which texture types may have which values (mipmaps, array layers, and faces): Therefore, a texture can be thought of as a three-dimensional array of images. The first index is the mipmap level, the second is the array layer, and the third is the cube map face. Another way to think of it is that a texture has a number of mipmap levels. Each mipmap can have a number of array layers. And each array has a number of faces. Face, layer, and level yields a single image. For Cubemap Textures, the face within that array layer and mipmap level. Note that for cubemap array textures, the layer and face are combined into layer-faces. For Array Textures, the array layer\u200b that contains the image. For textures that can have mipmaps, the mipmap level\u200b that contains the image. Since a texture stores multiple images, it is important to be able to identify a specific image in a texture. Each image in a texture can be uniquely identified by the following numbers, depending on the texture type: A texture contains one or more images of a certain dimensionality. Each kind of texture has a specific arrangement of images in its storage. Textures can have mipmaps, which are smaller versions of the same image used to aid in texture sampling and filtering. Each mipmap level has a separate set of images.", "textAfterTable": "GL_TEXTURE_CUBE_MAP_ARRAY Yes Yes Yes 2D GL_TEXTURE_RECTANGLE 2D GL_TEXTURE_BUFFER 1D GL_TEXTURE_2D_MULTISAMPLE 2D GL_TEXTURE_2D_MULTISAMPLE_ARRAY Yes 2D Note that virtually every function in OpenGL that deals with a texture's storage assumes that the texture may have mipmaps. So almost all of them take a level\u200b parameter. When using such functions for textures that cannot be mipmapped, the value for level\u200b must always be 0. Similarly, when dealing with functions that ask for a number of mipmap levels (such as the function to create storage for a texture), you must use 1 for non-mipmapped texture types. Image sizes Each texture type represents images of a certain dimensionality. As such, it is important to know the size of the individual images within a texture. This is easy enough. All images that have the same mipmap level (ie: all array layers and/or cube map faces in a mipmap) in a texture will have the same size (note that there are ways to try to break this rule; they will only lead to a non-functional texture). That size depends on the size of the", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}