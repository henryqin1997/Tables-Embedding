{"relation": [["Numeric Value", "0", "1", "2", "7", "8", "9", "10"], ["Constant Value", "%Attachment_Success", "%Attachment_Failed", "%Attachment_Cancelled", "%Attachment_DestSystNotFound", "%Attachment_DestSystFailedLogin", "%Attachment_FileNotFound", "%Attachment_DeleteFailed"], ["Description", "File was attached successfully.", "File was not successfully attached.", "File attachment didn't complete because the operation was canceled by the user.", "Cannot locate destination system for ftp.", "Unable to login to destination system for ftp.", "Cannot locate file.", "Cannot delete file."]], "pageTitle": "PeopleCode Built-in Functions", "title": "", "url": "http://docs.oracle.com/cd/E13292_01/pt849pbr0/eng/psbooks/tpcl/htm/tpcl02.htm", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 123, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042981969.11/warc/CC-MAIN-20150728002301-00011-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 68347227, "recordOffset": 68177297, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{906299=1997-09-01, 735311=&FIELD_CNT = ActiveRowCount(DBFIELD_VW.FIELDNAME);\nFor &I = 1 to &FIELD_CNT;\n   WinMessage(MsgGetText(21000, 1, \"Present Row Number is: %1\", &I));\nEnd-for;, 906538=1997-10-01, 487816=0:00 PM, 906777=1997-11-01, 904865=1997-03-01, 643607=When tasks have the same priority, the system orders the tasks according to the time they were created. For example, suppose the following tasks exist: Priority 2 created at 11:15 AM and Priority 2 created at 11:16 AM. In this case, the system assigns the task created at 11:15 AM before the task created at 11:16 AM., 907016=1997-12-01, 832400=http://bsto091200/psp/ps_newwin/EMPLOYEE/RMTNODE/q/?ICAction=ICQryNameURL=PUBLIC.QUERYNAME, 907374=Find the begin date of the pay period containing the date 1997-05-11 (the value of &COMPAREDate). The result date returned would be 1997-05-01., 905343=1997-05-01, 497729=If the user's Date Format personalization setting is set to DDMMYY (or it is defaulted to this from their browser locale or the system-wide personalization defaults) then the following code returns a Datetime value equal to September 10, 1997., 905582=1997-06-01, 167153=Assume that a time, &BREAKTime, is 0:15:00. The following moves the time &BREAKTime back by one hour, resulting in 23:15:00:, 905821=1997-07-01, 487693=12 o'clock PM, 906060=1997-08-01, 498948=Though TEST_DATE has a century setting, it isn\u2019t used because the PeopleCode fired in TEST_FIELD. Instead, DateValue uses the 50/50 rule and calculates the year to be 2011 (instead of 1911)., 1091676=If &TIMEOUT contains a Time value equal to 04:59:59 PM, the following example sets &TIMEOUT_HOUR to 16:, 904579=1997-02-28, 552213=The following code deletes the ABCD_XY SQL Definition for the current DBType and November 3, 1998:, 942983=/* ===> \n   This is a dynamically generated PeopleCode template to be used only as a helper to the application developer.  You need\nto replace all references to '<*>' OR default values with  references to PeopleCode variables and/or a Rec.Fields.*/ \n \n/* ===> Declare and instantiate: */ \nLocal Interlink &LDAP_SEARCHBI_1; \nLocal BIDocs &inDoc; \nLocal BIDocs &outDoc; \nLocal Boolean &RSLT; \nLocal number  &EXECRSLT; \n&LDAP_SEARCHBI_1 =  GetInterlink(INTERLINK.LDAP_SEARCHBIND); \n \n/* ===> You can use the following assignments to set the configuration parameters. \n*/ \n \n&LDAP_SEARCHBI_1.Server = \"jtsay111198.peoplesoft.com\"; \n&LDAP_SEARCHBI_1.Port = 389; \n&LDAP_SEARCHBI_1.User_DN = \"cn=Admin,o=PeopleSoft\"; \n&LDAP_SEARCHBI_1.Password = &password; \n&LDAP_SEARCHBI_1.UserID_Attribute_Name = \"uid\"; \n&LDAP_SEARCHBI_1.URL = \"///file:C:/User/Documentum/XML%20Applications/proddoc/peoplebook_upc/peoplebook_upc.dtd\"; \n&LDAP_SEARCHBI_1.BIDocValidating = \"Off\"; \n \n \n/* ===> You might want to call the following statement in a loop if there is more than one row of data to be added.  */ \n \n/* ===> Add inputs: */ \n&inDoc = &LDAP_SEARCHBI_1.GetInputDocs(\"\"); \n&ret = &inDoc.AddValue(\"User_ID\", <*>); \n&ret = &inDoc.AddValue(\"User_Password\", <*>); \n&ret = &inDoc.AddValue(\"Connect_DN\", <*>); \n&ret = &inDoc.AddValue(\"Connect_Password\", <*>); \n&Directory_Search_ParmsDoc = &inDoc.AddDoc(\"Directory_Search_Parms\"); \n&ret = &Directory_Search_ParmsDoc.AddValue(\"Host\", <*>); \n&ret = &Directory_Search_ParmsDoc.AddValue(\"Port\", <*>); \n&ret = &Directory_Search_ParmsDoc.AddValue(\"Base\", <*>); \n&ret = &Directory_Search_ParmsDoc.AddValue(\"Scope\", <*>); \n&ret = &Directory_Search_ParmsDoc.AddValue(\"Filter\", <*>); \n \n \n/* ===> The following statement executes this instance: */ \n&EXECRSLT = &LDAP_SEARCHBI_1.Execute(); \nIf ( &EXECRSLT <> 1 ) Then \n   /* The instance failed to execute */ \nElse \n&outDoc = &LDAP_SEARCHBI_1.GetOutputDocs(\"\"); \n&ret = &outDoc.GetValue(\"Distinguished_Name\", <*>); \n&ret = &outDoc.GetValue(\"return_status\", <*>); \n&ret = &outDoc.GetValue(\"return_status_msg\", <*>); \nEnd-If; /* If NOT &RSLT ...  */, 664393=&PRIOR_STATUS = PriorEffdt(EMPL_STATUS);\nEvaluate ACTION\nWhen  \"HIR\" \n   If %Mode = \"A\" Then\n      Warning MsgGet(1000, 13, \"You are hiring an employee and Action is not set to Hire.\");\n   End-if;\n   Break;\nWhen = \"REH\" \n   If All(&PRIOR_STATUS) and\n         not (&PRIOR_STATUS = \"T\"  or\n            &PRIOR_STATUS = \"R\" ) Then\n      Error MsgGet(1000, 14, \"Hire or Rehire action is valid\n        only if employee status is Terminated or Retired.\");\n   End-if;\n   Break;\nWhen-Other\n/* default code */\nEnd-evaluate;, 904340=1997-01-31, 487566=12:08 PM, 1018581=/* Use a related display of a required non-default field to verify \n * that the new Employee Id is not already in use */\nIf GetRelField(EMPLID, PERSONAL_DATA.NAME) <> \"\" Then\n   Error MsgGet(1000, 65, \"New Employee ID is already in use.  Please reenter.\");\nEnd-If;, 339266=&DATETIMEVAL= ConvertDateTimeToBase(\"01/01/1999 10:00:00AM\", \"EST\");, 487439=Wed, July 10, '96, 117994=30N/360: all months but February are 30 days long according to SIA rules, 826759=http://bsto091200/psc/ps_newwin/EMPLOYEE/RMTNODE/q/?ICAction=ICQryNameURL=PUBLIC.QUERYNAME, 495857=&Date_TIME = DateTimeValue(\"10/13/97 10:34:25 PM\");\n&Date_TIME = DateTimeValue(\"10/13/97 22:34:25\");, 904626=1997-02-01, 905296=1997-05-31, 487294=1996.07.10 AD at 15:08:56, 487955=1996.July.10 AD 12:08 PM, 826347=http://bsto091200/psc/ps/EMPLOYEE/RMTNODE/q/?ICAction=ICQryNameURL=PUBLIC.QUERYNAME, 905104=1997-04-01, 901721=A date field set by the caller as the date of interest, for example, \"1997-02-17.\", 159418=For example, in the following, &NewDate is 29/03/2004., 495419=Though TEST_DATE has a century setting, it isn\u2019t used because the PeopleCode fired in TEST_FIELD. Instead, DateTimeValue uses the 50/50 rule and calculates the year to be 2011 (instead of 1911)., 474831=The following example sets &DT to a DateTime value equal to 10:09:20 on March 15, 1997:, 495734=Both of the following examples set &Date_TIME to a Datetime value equal to October 13, 1997 10:34:25 PM., 562631=For example, 1302 is returned when an invalid task type or no value is provided., 347554=In the following example, &TIMEVAL would have a time value of \"07:00:00.000000\", assuming the Base time (as defined in PSOPTIONS) was PST., 477505=is a 3-character month name, one of Jan, Feb, Mar, and so on., 993854=Dec, 906252=1997-09-30, 170637=If All(RETURN_DT, BEGIN_DT) and\n    8 * (RETURN_DT - BEGIN_DT) (DURATION_DAYS * 8 + DURATION_HOURS) \nThen \n    Warning MsgGet(1000, 1, \"Duration of absence exceeds standard hours for number of days absent.\");\nEnd-if;, 906107=1997-08-30, 700552=The following code gets the text associated with the ABCD_XY SQL Definition for the current DBType and November 3, 1998:, 474936=&DT = DateTime6(1997, 3, 15, 10, 9, 20);, 472210=&D1 = DateTimeValue(\"11/12/1997 10:23:15 AM\");\n&D2 = DatePart(&D1);, 904387=1997-01-01, 906969=1997-12-31, 907208=1997-01-15, 906491=1997-10-31, 339080=In the following example, &DATETIMEVAL would have a datetime value of \"01-01-1999-07:00:00.000000\", assuming the Base time (as defined in PSOPTIONS) was PST., 906730=1997-11-30, 467666=Set the temporary variable &HIREDate to a date field containing the date July 1, 1997:, 831989=http://bsto091200/psp/ps/EMPLOYEE/RMTNODE/q/?ICAction=ICQryNameURL=PUBLIC.QUERYNAME, 906824=1997-11-27, 589178=DoModal(PAGE.EDUCATION_DTL, MsgGetText(1000, 167, \"Education Details - %1\", EDUCATN.DEGREE), - 1, - 1, 1, RECORD.EDUCATN,\nCurrentRowNumber());, 501046=If HIRE_DATE is November, 1, 1997, the following Day function returns the integer 1:, 651237=If PAGES2_INV_WRK.PHYS_CYC_INV_FLG = \"Y\" Then\n      SetCursorPos(%Page, PHYSICAL_INV.INV_LOT_ID, CurrentRowNumber(1), QTY_ADJUSTED, CurrentRowNumber());\n      Error MsgGet(11100, 180, \"Message not found.\");\n   End-If;, 899666=Use the GetCalendarDate function to return the value of a Date field from the PS_PAY_CALENDAR table. If a table entry is not found, GetCalendarDate returns 1899-01-01., 982028=1-192    10.39.54    0.320 Cur#2.1980.DB844901 RC=0 Dur=0.320 Connect=Secondry/DB844901/testdb2/\n1-193    10.39.54    0.000 GNNWGC ---- Successful obtain Second DB connection \n1-194    10.39.54    0.010 Cur#2.1980.DB844901 RC=0 Dur=0.010 COM Stmt=UPDATE PS_MCF_INSTALL SET MCF_EMAIL_ID = MCF_EMAIL_ID\n+ 1 \n1-195    10.39.54    0.000 Cur#2.1980.DB844901 RC=0 Dur=0.000 COM Stmt=SELECT MCF_EMAIL_ID FROM PS_MCF_INSTALL \n1-196    10.39.54    0.000 Cur#2.1980.DB844901 RC=0 Dur=0.000 Commit\n1-197    10.39.54    0.000 Cur#2.1980.DB844901 RC=0 Dur=0.000 Disconnect, 482634=1996, 194532=If CURRENCY_CD = PriorEffdt(CURRENCY_CD) Then\n      Evaluate ACTION\n      When = \"PAY\" \n         If ANNUAL_RT = PriorEffdt(ANNUAL_RT) Then\n            Warning MsgGet(1000, 27, \"Pay Rate Change action is chosen and Pay Rate has not been changed.\");\n         End-if;\n         Break;\n      When = \"DEM\" \n         If ANNUAL_RT >= PriorEffdt(ANNUAL_RT) Then\n            Warning MsgGet(1000, 29, \"Demotion Action is chosen and Pay Rate has not been decreased.\");\n         End-if;\n        Break;\n      When-other\n      End-evaluate;\n      WinMessage(\"This message appears after executing either of the BREAK statements or after all WHEN statements are false\");\nEnd-if;, 904818=1997-03-31, 905057=1997-04-30, 906013=1997-08-31, 492652=&NEWDATETIME will have the value 01/01/99 13:00:00 because EST is three hours ahead of PST on 01/01/99, so three hours are added to the datetime value., 498059=If the user's Date Format personalization setting is set to MMDDYY (or it is defaulted to this from their browser locale or the system-wide personalization defaults) then the same function call returns a value equal to October 9, 1997., 905535=1997-06-30, 338155=Specify a datetime value represented as text (for example, \"01/01/1999 3:00 PM\"), 345932=This function is useful for users to convert constant times in specific time zones into database time. For example, there is a deadline for completing Federal Funds transfers by 3:00 PM Eastern Time. ConvertTimeToBase does this conversion, taking into account daylight savings time. The date used to calculate whether daylight savings time is in effect is the current date., 180970=This example sets &RESULT equal to \"Int=114 Prin=176 Bal=11223.72\"., 492346=The following example. TESTDTTM, is a datetime field with a value 01/01/99 10:00:00. This example converts TESTDTTM from Pacific standard time (PST) to eastern standard time (EST)., 904912=1997-03-29, 905629=1997-06-28, 905774=1997-07-31, 996994=Function Update(&1 As string) Returns number NoExport\n   Doc \"this is some attached annotation\"\n   Return 1.23;\nEnd-Function;\n\nFunction Updateagain(&1 As string) Returns number\n   Doc \"this is some more attached annotation\"\n   Return 1.23;\nEnd-Function;\n\nLocal File &log;\n\nFunction LogText(&msg As string)\n   If &log = Null Then\n      Return\n   End-If;\n   &log.WriteLine(&msg);\nEnd-Function;\n\n\nFunction CreateCI(&Name As string) Returns ApiObject\n   Local ApiObject &CI;\n   /** Get Component Interface **/\n   &CI = %Session.GetCompIntfc(@(\"CompIntfc.\" | &Name));\n   /* instantiate */\n   &CI.PROCESSNAME = \"AEMINITEST\";\n   &CI.PROCESSTYPE = \"Application Engine\";\n   &CI.RUNCONTROLID = 99;\n   &CI.Create();\n   Return &CI;\nEnd-Function;\n\nFunction DisplayProgramFuncInfo(&r As array of array of any)\n   \n   Local integer &i;\n   \n   For &i = 1 To &r.Len\n      Local string &o;\n      &o = &r [&i][1] | \"(\" | &r [&i][2] | \";\" | &r [&i][3] | \") doc '\" | &r [&i][4] | \"'\";\n      If &r [&i][5] = 0 Then\n         &o = &o | \" noexport \";\n      Else\n         &o = &o | \" export \";\n      End-If;\n      If &r [&i][6] = 0 Then\n         &o = &o | \" no permission \";\n      Else\n         &o = &o | \" permitted \";\n      End-If;\n      LogText(&o);\n   End-For;\nEnd-Function;\n\nFunction SetupParameters(&Names As array of string, &Sigs As array of string) Returns array of any\n   Local array of any &p = CreateArrayAny();\n   Local integer &i;\n   \n   /* could use the parameter name to get values out of a dom?? */\n   /* Base types we could handle\n//  D = Dec\n//  S = String\n//  d = Date\n//  A = Any\n//  B = Boolean\n//  V = None\n//  t = Time\n//  T = DateTime\n//  I = Image\n//  O = Object\n//  i = Integer\n//  f = Float\n//  9 = Number\n//  x = Unknown\n*/\n   For &i = 1 To &Sigs.Len\n      Local string &parName = RTrim(LTrim(&Names [&i + 1])); /* first name is create/get/?? */\n      /* Here is where you'd get the value for this particular parameter \n and then push it properly onto the parameter array */\n      Evaluate Substring(&Sigs [&i], 1, 1)\n      When = \"D\"\n         &p.Push(1);\n         Break;\n      When = \"S\"\n         &p.Push(\"String for \" | &parName);\n         Break;\n      When = \"9\"\n      When = \"i\"\n         &p.Push(&i);\n         Break;\n      When-Other\n         &p.Push(\"Unimplemented . . .\");\n      End-Evaluate\n   End-For;\n   \n   Return &p;\nEnd-Function;\n\nFunction CallUDMMethod(&ci As ApiObject, &funcInfo As array of array of any, &methodName As string) Returns any\n   \n   /* an example of calling a user defined method on a ci */\n   \n   /* 1. find it in the funcinfo */\n   Local integer &i = 1;\n   Local integer &nFuncs = &funcInfo.Len;\n   \n   While &i <= &nFuncs\n      /* name should match and it should be exportable (the default) \n\t\t and the doc tag should have something in it \n\t\t and it should be permitted */\n      If &funcInfo [&i][1] = &methodName And\n            &funcInfo [&i][5] <> 0 And\n            Len(&funcInfo [&i][4]) > 0 And\n            &funcInfo [&i][6] <> 0 Then\n         Break;\n      End-If;\n      &i = &i + 1;\n   End-While;\n   \n   If &i > &nFuncs Then\n      LogText(\"not found\");\n      Return False;\n   End-If;\n   \n   /* 2. Next get the info necessary to call the function based on the signature info */\n   Local string &parSignatures = &funcInfo [&i][2];\n   Local boolean &bPars = False;\n   Local array of any &Pars;\n   If Len(&parSignatures) > 0 Then\n      &bPars = True;\n      Local array of string &parSignature = Split(&parSignatures, \",\");\n      Local array of string &parNames = Split(&funcInfo [&i][4], \",\"); /* first one should be Create/get/? */\n      /* number of parameters should match number of parameter names  */\n      If &parSignature.Len <> &parNames.Len - 1 Then\n         LogText(\"length mismatch\");\n         Return False;\n      End-If;\n      &Pars = SetupParameters(&parNames, &parSignature);\n   Else\n      &Pars = CreateArrayAny();\n   End-If;\n\n   /* 3. Call the udm method with our parameters */\n   Return &ci.InvokeMethodUDF(&methodName, &Pars);\n   \nEnd-Function;\n\nQE_ABSENCE_HIST.QE_REASON.Value = \"\"; /* clean it up */\nLocal string &ciName = \"PROCESSREQUEST\";\n\nLocal ApiObject &CI = CreateCI(&ciName);\n\nLocal array of any &pars = CreateArrayAny(\"First parameter\", 2);\n/* check with variable for method name */\nLocal string &methodname = \"FoxTest\";\n/* add in a bogus parameter  - tested - works - fails with false return :-( as per usual in api objects*/\nLocal string &bogus = \"bogus par\";\n\n&log = GetFile(\"C:\\temp\\junk\\udflog.txt\", \"a\", %FilePath_Absolute);\nLogText(\"=====================================\");\nLogText(\"Result of direct call: \" | &CI.InvokeMethodUDF(&methodname, &pars /* , &bogus */));\nrem LogText(\"&ci: \" | &CI);\n\n/* do this the new way - at least model how a webservices Peoplecode implementation could do it */\nLocal string &ciObjid = \"COMPONENTINTERFACE.\" | &ciName | \".METHOD.Methods\";\n/* get the program information */\nLocal array of array of any &progInfo;\n&progInfo = GetProgramFunctionInfo(&ciObjid);\n/* returns a an array of arrays: an array for each function defined in the program.\n\nEach row has the following ([i] = position i):\n[1] = program name (string)\n[2] = comma separated list of parameter signatures (string)\n[3] = result signature (string)\n[4] = text that was with the doc tag. Convention here is a comma separated list of values:\n    first item is one of either Create or Get, specifying what method has to be called first\n    second and subsequent items are the names of the parameters (this information is not obtainable from the\n    program information. These are the names to be exposed as the web service parameter names\n\n    e.g. the above function would have a doc like \"Create, StringParameter, NumericParameter\"\n[5] = an integer setting: 0=no export and 1=export (the default)\n[6] = an integer setting indicating the permission for user to call this (only applies to CI programs)\n\t\t0=no permission and 1=permitted (the default)\n\n*/\nDisplayProgramFuncInfo(&progInfo);\nIf &CI = Null Then\n   &CI = CreateCI(&ciName);\nEnd-If;\nLogText(\"Result of indirect call: \" | CallUDMMethod(&CI, &progInfo, &methodname));, 346655=Specify a time value represented as text (e.g., \"3:00 PM\"), 488132=REM**************************************************************; \nFunction ConvertDateToDTTM(&Date As date) Returns datetime ; \nREM ***********************************************************; \n   &String = DateTimeToLocalizedString(&Date, \"M/d/y\"); \n   &String = &String | \" 00:00:00.000000\"; \n   &DateTime = DateTimeValue(&String); \n   Return &DateTime; \nEnd-Function;}", "lastModified": "Tue, 16 Sep 2008 05:57:54 GMT", "textBeforeTable": "\u00a0 The accrual convention. This parameter takes either a number or a constant value. Values for this parameter are: Accrual_Conv The end of the time period for determining the accrual. This parameter takes a date value. EndDate The beginning of the time period for determining the accrual. This parameter takes a date value. StartDate Parameters Use the AccruableDays function to return the number of days during which interest can accrue in a given range of time according to the Accrual_Conv parameter. Description AccruableDays(StartDate, EndDate, Accrual_Conv)  Syntax AccruableDays    Sign, %Abs.  See Also  &RESULT = Abs(&NUM_1 - &NUM_2); The example returns the absolute value of the difference between &NUM_1 and &NUM_2: Example Specify the number you want the decimal value for. x Parameters Use the Abs function to", "textAfterTable": "AccrualFactor Syntax  AccrualFactor(StartDate, EndDate, Accrual_Conv) Description Use the AccrualFactor function to compute a factor that's equal to the number of years of interest accrued during a date range, according to Accrual_Conv parameter. Parameters StartDate The beginning of the time period for determining the accrual. This parameter takes a date value. EndDate The end of the time period for determining the accrual. This parameter takes a date value. Accrual_Conv The accrual convention. This parameter takes either a number or constant value. Values for this parameter are: \u00a0 Numeric Value Constant Value Description 0 %Accrual_30DPM 30/360: all months 30 days long according to NASD rules for date truncation 1", "hasKeyColumn": true, "keyColumnIndex": 1, "headerRowIndex": 0}