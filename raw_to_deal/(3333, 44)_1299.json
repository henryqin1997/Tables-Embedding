{"relation": [["Operator", "ltree @> ltree", "ltree <@ ltree", "ltree ~ lquery", "lquery ~ ltree", "ltree ? lquery[]", "lquery[] ? ltree", "ltree @ ltxtquery", "ltxtquery @ ltree", "ltree || ltree", "ltree || text", "text || ltree", "ltree[] @> ltree", "ltree <@ ltree[]", "ltree[] <@ ltree", "ltree @> ltree[]", "ltree[] ~ lquery", "lquery ~ ltree[]", "ltree[] ? lquery[]", "lquery[] ? ltree[]", "ltree[] @ ltxtquery", "ltxtquery @ ltree[]", "ltree[] ?@> ltree", "ltree[] ?<@ ltree", "ltree[] ?~ lquery", "ltree[] ?@ ltxtquery"], ["Returns", "boolean", "boolean", "boolean", "boolean", "boolean", "boolean", "boolean", "boolean", "ltree", "ltree", "ltree", "boolean", "boolean", "boolean", "boolean", "boolean", "boolean", "boolean", "boolean", "boolean", "boolean", "ltree", "ltree", "ltree", "ltree"], ["Description", "is left argument an ancestor of right (or equal)?", "is left argument a descendant of right (or equal)?", "does ltree match lquery?", "does ltree match lquery?", "does ltree match any lquery in array?", "does ltree match any lquery in array?", "does ltree match ltxtquery?", "does ltree match ltxtquery?", "concatenate ltree paths", "convert text to ltree and concatenate", "convert text to ltree and concatenate", "does array contain an ancestor of ltree?", "does array contain an ancestor of ltree?", "does array contain a descendant of ltree?", "does array contain a descendant of ltree?", "does array contain any path matching lquery?", "does array contain any path matching lquery?", "does ltree array contain any path matching any lquery?", "does ltree array contain any path matching any lquery?", "does array contain any path matching ltxtquery?", "does array contain any path matching ltxtquery?", "first array entry that is an ancestor of ltree; NULL if none", "first array entry that is a descendant of ltree; NULL if none", "first array entry that matches lquery; NULL if none", "first array entry that matches ltxtquery; NULL if none"]], "pageTitle": "PostgreSQL: Documentation: 9.3: ltree", "title": "", "url": "http://www.postgresql.org/docs/9.3/static/ltree.html", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 1, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990900.28/warc/CC-MAIN-20150728002310-00192-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 667046269, "recordOffset": 667038067, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{18593=All work was done by Teodor Sigaev (<teodor@stack.net>) and Oleg Bartunov (<oleg@sai.msu.su>). See http://www.sai.msu.su/~megera/postgres/gist/ for additional information. Authors would like to thank Eugeny Rodichev for helpful discussions. Comments and bug reports are welcome.}", "textBeforeTable": "Table F-12. ltree Operators Type ltree has the usual comparison operators =, <>, <, >, <=, >=. Comparison sorts in the order of a tree traversal, with the children of a node sorted by label text. In addition, the specialized operators shown in Table F-12 are available. F.21.2. Operators and Functions Note: ltxtquery allows whitespace between symbols, but ltree and lquery do not. This will match paths that contain the label Europe and any label beginning with Russia (case-insensitive), but not paths containing the label Transportation. The location of these words within the path is not important. Also, when % is used, the word can be matched to any underscore-separated word within a label, regardless of position. Europe & Russia*@ & !Transportation ltxtquery represents a full-text-search-like pattern for matching ltree values. An ltxtquery value contains words, possibly with the modifiers @, *, % at the end; the modifiers have the same meanings as in lquery. Words can be combined with & (AND), | (OR), ! (NOT), and parentheses. The key difference from lquery is that ltxtquery matches words without regard to their position in the label path. Here's an example ltxtquery:   and then ends with a label beginning with", "textAfterTable": "The operators <@, @>, @ and ~ have analogues ^<@, ^@>, ^@, ^~, which are the same except they do not use indexes. These are useful only for testing purposes. The available functions are shown in Table F-13. Table F-13. ltree Functions Function Return Type Description Example Result subltree(ltree, int start, int end) ltree subpath of ltree from position start to position end-1 (counting from 0) subltree('Top.Child1.Child2',1,2) Child1 subpath(ltree, int offset, int len) ltree subpath of ltree starting at position offset, length len. If offset is negative, subpath starts that far from the end of the path. If len is negative, leaves that many labels off the end of the path. subpath('Top.Child1.Child2',0,2) Top.Child1 subpath(ltree, int offset) ltree subpath of ltree starting at position offset, extending to end of path. If offset is negative, subpath starts that far from the end of the path. subpath('Top.Child1.Child2',1) Child1.Child2 nlevel(ltree) integer number of labels in path nlevel('Top.Child1.Child2') 3 index(ltree a, ltree b) integer position of first occurrence of b in a; -1 if not found", "hasKeyColumn": true, "keyColumnIndex": 2, "headerRowIndex": 0}