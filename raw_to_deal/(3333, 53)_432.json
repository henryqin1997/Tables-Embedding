{"relation": [["", "M1", "", "", "M2", "M3"], ["Preconditions", "pre(x,_),pre(y,_)", "pre(p(d),_)", "", "pre(y,M1), pre(p(w),M1)", "pre(z,M1), pre(m,M2)"], ["Postconditions", "r post(x,_), post(y,M2),", "post(z,M3)", "Effects: w=f(d)", "post(m,M3)", "post(n,_)"]], "pageTitle": "Automatic Learning in Proof Planning", "title": "", "url": "http://www.cs.bham.ac.uk/~mmk/papers/00-calculemus-learning.html", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 2, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438043062723.96/warc/CC-MAIN-20150728002422-00174-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 392845599, "recordOffset": 392826086, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{55453=We would like to thank Alan Bundy for his continuing interest in and advice on our work, and in particular for pointing us to the work of Silver and Desimone. Furthermore we would like to thank Andreas Meier and Volker Sorge for their invaluable help in getting started to realise our ideas in Omega . Finally we would like to thank our referees for many useful comments. This work was supported by EPSRC grants GR/M22031 and GR/M99644.}", "lastModified": "Mon, 06 Jun 2005 08:07:16 GMT", "textBeforeTable": "Let there be a proof of a theorem T which consists of three steps, M1, M2 and M3. These methods consist of preconditions, postconditions, effects and tactics as demonstrated in the table below: The idea of precondition analysis is to examine the reasons for applying each inference at each step of the proof. This is achieved by providing explanations for each step in the proof which are usually extracted from the information of preconditions and postconditions of a step. The preconditions of each rule used in a method are paired with additional information, namely the methods that generated these preconditions. Similarly, the postconditions of each rule used in a method are paired with the methods that use these postconditions. We extend Desimone's method schema representation with the effects that an inference rule has in the proof. Effects are used to express a change in the proof planning state which is not explicitly planned for, because, for instance, the underlying language may not be rich enough to express these changes. We demonstrate a representation of a method schema with an example. 5.1.\u00a0\u00a0Precondition Analysis Methods expressed using the language introduced in Section 3 do not specify what their preconditions and postconditions are. They also do not specify how the number of loop applications of inference rules is instantiated when used to prove a theorem. Hence, the method representation needs to be enriched to account for these factors. We propose to", "textAfterTable": "M3 \u00a0 \u00a0\u00a0\u00a0\u00a0 z \u00a0&\u00a0 m \u00a0 \u00a0n \u00a0 \u00a0 \u00a0 \u00a0 t3 Notice that p(d) denotes some property p of d, where this property is a precondition of M 1. f denotes a function which under the application of M 1 changes a term d occurring in a precondition p(d) to a term w. The initial state of the proof of the theorem can be described in terms of x \u00a0&\u00a0 y\u00a0&\u00a0 p(d) which holds for theorem T. The preconditions of each method M i used in a proof of an example are analysed to determine the explanations for using these particular steps in the proof. The explanations are generated in a bottom-up fashion starting with the application of the final method. M 3 was obviously applied in order to reach a solution denoted by n and is not an interesting case. Now consider reasons for applying method M 2. This is done by the analysis of the preconditions of M 3 which may be provided as the postconditions of M 2. The preconditions for method M 3 are z\u00a0&\u00a0 m. The precondition z was already satisfied before the application of M 2, Note that all changes to the state of the proof caused by the application of a method have to be explicitly stated in the specification", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}