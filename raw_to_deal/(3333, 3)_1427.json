{"relation": [["jcr:path", "/folder1", "/folder1/document1", "/folder1/folder2", "/folder1/folder2/document2", "/folder1/folder2/document3", "..."], ["jcr:score", "1000", "1000", "1000", "1000", "1000", "..."]], "pageTitle": "eXo JCR Developer Guide", "title": "", "url": "http://docs.jboss.org/exojcr/1.12.13-GA/developer/en-US/html_single/", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 11, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042981576.7/warc/CC-MAIN-20150728002301-00203-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 75094431, "recordOffset": 74897488, "tableOrientation": "HORIZONTAL", "TableContextTimeStampBeforeTable": "{320612=Copyright \u00a9 2009, 2010 eXoPlatform, 72044=JCR MySQL-backend requires special dialect MySQL-UTF8 to be used for internationalization support. But the database default charset should be latin1 to use limited index space effectively (1000 bytes for MyISAM engine, 767 for InnoDB). If database default charset is multibyte, a JCR database initialization error is thrown concerning index creation failure. In other words, JCR can work on any singlebyte default charset of database, with UTF8 supported by MySQL server. But we have tested it only on latin1 database default charset., 24357=MS SQL Server 2005 SP3 JDBC Driver 2.0, 174221=Roy T. Fielding, JSR 170 Overview: Standardizing the Content Repository Interface (March 13, 2005), 173971=Benjamin Mestrallet, Tuan Nguyen, Gennady Azarenkov, Francois Moron and Brice Revenant eXo Platform v2, Portal, JCR, ECM, Groupware and Business Intelligence. (January 2006)}", "TableContextTimeStampAfterTable": "{296856=If you have Microsoft Office 2010 applications or Microsoft Office 2007 applications installed on a client computer. From that client computer, you try to access an Office file that is stored on a web server that is configured for Basic authentication. The connection between your computer and the web server does not use Secure Sockets Layer (SSL). When you try to open or to download the file, you experience the following symptoms:, 512266=* Benjamin Mestrallet, Tuan Nguyen, Gennady Azarenkov, Francois Moron and Brice Revenant eXo Platform v2, Portal, JCR, ECM, Groupware and Business Intelligence (January 2006), 152654=jcr:content (nt:resource) jcr:lastModified=\"2007-01-19T15:34:15.917+02:00\", 152128=jcr:content (nt:resource) jcr:lastModified=\"2006-01-19T15:34:15.917+02:00\", 134054=document1 (mix:title) jcr:title=\"War and peace\" jcr:description=\"novel\" prop_pagecount=1000, 512081=* David Nuescheler and Janus Boye, JSR-170 What's in it for me? (April 20, 2005), 151389=Find all nodes of primary type \"nt:resource\" whose jcr:lastModified property value is greater than 2006-06-04 and less than 2008-06-04., 511841=* Roy T. Fielding, JSR 170 Overview: Standardizing the Content Repository Interface (March 13, 2005), 152391=jcr:content (nt:resource) jcr:lastModified=\"2005-01-19T15:34:15.917+02:00\", 290229=At present, eXo JCR WebDav server is tested by using MS Internet Explorer, Dav Explorer, Xythos Drive, Microsoft Office 2003 (as client), and Ubuntu Linux., 301600=When you have already some FTP server installed in your system , this parameter needs to be changed (2121 for example) to avoid conflicts or if the port is protected., 116570=document1 (mix:title) jcr:title=\"War and peace\" prop_pagecount=1000, 549833=Beware of setting maxThreads too big, this can cause OutOfMemoryError. We've got it with maxThreads=1250 on such machine:}", "lastModified": "Mon, 11 Jun 2012 12:24:37 GMT", "textBeforeTable": "Table\u00a027.1.\u00a0Table content Table content is } Value[] values = row.getValues(); // get values of the row Row row = rit.nextRow(); { while (rit.hasNext()) RowIterator rit = result.getRows(); String[] columnNames = result.getColumnNames(); We can also get a table: NodeIterator will return \"folder1\", \"folder2\",\"document1\",\"document2\",\"document3\", and each other nodes in workspace if they are here. } Node findedNode = it.nextNode(); { if(it.hasNext()) NodeIterator it = result.getNodes(); Let's get nodes: 27.10.2.3.\u00a0Fetching result QueryResult result = query.execute(); // execute query and fetch result Query query = queryManager.createQuery(xpathStatement, Query.XPATH); String xpathStatement = \"//element(*,nt:base)\"; // create query QueryManager queryManager = workspace.getQueryManager(); // make XPath query XPath QueryResult result = query.execute(); // execute query and fetch result Query query = queryManager.createQuery(sqlStatement, Query.SQL); String sqlStatement = \"SELECT * FROM nt:base\"; // create query QueryManager queryManager = workspace.getQueryManager(); // make SQL query SQL 27.10.2.2.\u00a0Query execution document3 (nt:folder) document2 (nt:unstructured) folder2 (nt:folder) document1 (nt:file) folder1 (nt:folder) root Repository contains many different nodes. 27.10.2.1.\u00a0Repository structure: Find all nodes in the repository. Only those nodes are found to which the session has READ permission. See also Access Control.", "textAfterTable": "27.10.3.\u00a0Finding Nodes by Primary Type Find all nodes whose primary type is \"nt:file\". 27.10.3.1.\u00a0Repository structure: The repository contains nodes with different primary types and mixin types. root document1 primarytype = \"nt:unstructured\" mixintype = \"mix:title\" document2 primarytype = \"nt:file\" mixintype = \"mix:lockable\" document3 primarytype = \"nt:file\" mixintype = \"mix:title\" 27.10.3.2.\u00a0Query execution SQL // make SQL query QueryManager queryManager = workspace.getQueryManager(); // create query String sqlStatement = \"SELECT * FROM nt:file\"; Query query = queryManager.createQuery(sqlStatement, Query.SQL); // execute query and fetch result QueryResult result = query.execute(); XPath // make XPath query QueryManager queryManager = workspace.getQueryManager(); // create query String xpathStatement = \"//element(*,nt:file)\"; Query query = queryManager.createQuery(xpathStatement, Query.XPATH); // execute query and fetch result QueryResult result = query.execute(); 27.10.3.3.\u00a0Fetching result Let's get nodes: NodeIterator it = result.getNodes(); if(it.hasNext()) { Node findedNode = it.nextNode(); } NodeIterator will return \"document2\" and \"document3\". We can also get a table: String[] columnNames = result.getColumnNames(); RowIterator rit = result.getRows(); while (rit.hasNext()) { Row row = rit.nextRow(); // get values of the row Value[] values = row.getValues(); } The table content is", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}