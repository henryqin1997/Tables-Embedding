{"relation": [["Source of CultureInfo and DateTimeFormatInfo object", "CultureInfo.CurrentCulture.DateTimeFormat property", "DateTimeFormatInfo.CurrentInfo property", "CultureInfo.CreateSpecificCulture method", "CultureInfo.GetCultureInfo method", "CultureInfo.CultureInfo(String) constructor", "CultureInfo.CultureInfo(String, Boolean) constructor"], ["Reflects user overrides", "Yes", "Yes", "Yes", "No", "Yes", "Depends on value of useUserOverride parameter"]], "pageTitle": "DateTimeFormatInfo Class (System.Globalization)", "title": "", "url": "https://msdn.microsoft.com/en-us/library/System.Globalization.DateTimeFormatInfo(v=vs.110).aspx", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 4, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990611.52/warc/CC-MAIN-20150728002310-00130-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 880538791, "recordOffset": 880500632, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{119923=RFC1123Pattern, to define a result string that conforms to the RFC 1123 standard. The property is read-only., 165371=The following example illustrates the culture-sensitive nature of parsing date and time strings. It tries to parse two date strings by using the conventions of the en-US, en-GB, fr-FR, and fi-FI cultures. The date that is interpreted as 8/18/2014 in the en-US culture throws a FormatException exception in the other three cultures because 18 is interpreted as the month number. 1/2/2015 is parsed as the second day of the first month in the en-US culture, but as the first day of the second month in the remaining cultures.}", "textBeforeTable": "// fr-FR from GetInstance: False // fr from GetCultureInfo: True\u00a0 // fr-FR from CreateSpecificCulture: False\u00a0 // fr from CultureInfo constructor: False\u00a0 // fr from Parent property: False\u00a0 // fr from Parent property: False\u00a0 // The example displays the following output:\u00a0 Console.WriteLine(\"{0} from GetInstance: {1}\", neutral.Name, dtfi.IsReadOnly); dtfi = System.Globalization.DateTimeFormatInfo.GetInstance(neutral); neutral = System.Globalization.CultureInfo.CreateSpecificCulture(\"fr\"); // Instantiate a DateTimeFormatInfo object by calling GetInstance. Console.WriteLine(\"{0} from GetCultureInfo: {1}\", neutral.Name, dtfi.IsReadOnly); dtfi = neutral.DateTimeFormat; neutral = System.Globalization.CultureInfo.GetCultureInfo(\"fr\"); // Retrieve a culture by calling the GetCultureInfo method. Console.WriteLine(\"{0} from CreateSpecificCulture: {1}\", neutral.Name, dtfi.IsReadOnly); dtfi = neutral.DateTimeFormat; neutral = System.Globalization.CultureInfo.CreateSpecificCulture(\"fr\"); // Instantiate a culture using CreateSpecificCulture. Console.WriteLine(\"{0} from CultureInfo constructor: {1}\", neutral.Name, dtfi.IsReadOnly); dtfi = neutral.DateTimeFormat; neutral = new System.Globalization.CultureInfo(\"fr\"); // Instantiate a neutral culture using the CultureInfo constructor. Console.WriteLine(\"{0} from Parent property: {1}\", neutral.Name, dtfi.IsReadOnly); dtfi = System.Globalization.CultureInfo.GetCultureInfo(\"fr-FR\").Parent.DateTimeFormat; Console.WriteLine(\"{0} from Parent property: {1}\", neutral.Name, dtfi.IsReadOnly); dtfi = neutral.DateTimeFormat; neutral = specific.Parent; specific = System.Globalization.CultureInfo.GetCultureInfo(\"fr-FR\"); // Instantiate a culture by creating a specific culture and using its Parent property. System.Globalization.DateTimeFormatInfo dtfi; System.Globalization.CultureInfo specific, neutral;     Copy   VB  C# A neutral culture represents", "textAfterTable": "using System; using System.Collections; using System.Collections.Generic; using System.Globalization; using System.Reflection; public\u00a0class Example { public\u00a0static\u00a0void Main() { // Get all the neutral cultures List<String> names = new List<String>(); Array.ForEach(CultureInfo.GetCultures(CultureTypes.NeutralCultures), culture => names.Add(culture.Name)); names.Sort(); foreach (var name in names) { // Ignore the invariant culture.\u00a0 if (name == \"\") continue; ListSimilarChildCultures(name); } } private\u00a0static\u00a0void ListSimilarChildCultures(String name) { // Create the neutral DateTimeFormatInfo object. DateTimeFormatInfo dtfi = CultureInfo.GetCultureInfo(name).DateTimeFormat; // Retrieve all specific cultures of the neutral culture. CultureInfo[] cultures = Array.FindAll(CultureInfo.GetCultures(CultureTypes.SpecificCultures), culture => culture.Name.StartsWith(name + \"-\", StringComparison.OrdinalIgnoreCase)); // Create an array of DateTimeFormatInfo properties PropertyInfo[] properties = typeof(DateTimeFormatInfo).GetProperties(BindingFlags.Instance | BindingFlags.Public); bool hasOneMatch = false; foreach (var ci in cultures) { bool match = true; // Get the DateTimeFormatInfo for a specific culture. DateTimeFormatInfo specificDtfi = ci.DateTimeFormat; // Compare the property values of the two.\u00a0 foreach (var prop in properties) { // We're not interested in the value of IsReadOnly. \u00a0 if (prop.Name == \"IsReadOnly\") continue; // For arrays, iterate the individual elements to see if they are the same.\u00a0 if (prop.PropertyType.IsArray) { IList nList = (IList) prop.GetValue(dtfi, null); IList sList = (IList) prop.GetValue(specificDtfi, null); if (nList.Count != sList.Count) { match = false; Console.WriteLine(\" Different n in {2} array for {0} and {1}\",", "hasKeyColumn": true, "keyColumnIndex": 0, "headerRowIndex": 0}