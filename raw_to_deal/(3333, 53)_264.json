{"relation": [["syntax", "$\\a", "$\\b", "$\\t", "$\\n", "$\\v", "$\\f", "$\\r", "$\\e", "$\\\\"], ["asciiValue", "7", "8", "9", "10", "11", "12", "13", "27", "92"], ["ASCII designation", "bel (alert)", "bs (backspace)", "ht (horizontal tab)", "nl (newline)", "vt (vertical tab)", "np (new page, or form feed)", "cr (carriage return)", "esc (escape)", "\\ (a single backslash character)"]], "pageTitle": "Pepsi -- not quite The Real Thing", "title": "", "url": "http://piumarta.com/pepsi/pepsi.html", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 1, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988310.3/warc/CC-MAIN-20150728002308-00162-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 188611015, "recordOffset": 188590863, "tableOrientation": "HORIZONTAL", "lastModified": "Fri, 27 Apr 2007 20:48:35 GMT", "textBeforeTable": "compiles bar.st into the object file bar.so that can be loaded into a running program with the import: directive. (The directory examples/dynamic contains an example of importing shared libraries into a running program.) 2.2\u00a0\u00a0\u00a0Compiling the compiler The compiler source directory contains several directories, as follows: idc -s bar.st    compiles foo.st into the executable foo combining it with previously compiled object files bar.o and baz.o. (The examples/static directory contains an example of linking multiple object files into a monolithic program.)  The -s option tells the compiler to generate a shared library from the source file. (The resulting library can be loaded into an already-running program.) The command  idc foo.st bar.o baz.o    compiles bar.st into the object file bar.o. Any number of .o files can be linked when compiling an executable program. The command idc -c bar.st    builds the program bar from the source foo.st, searching ../st80 and .../MyClassLibrary for included files. 2.1\u00a0\u00a0\u00a0Object files and shared libraries The default behaviour is to compile a single source file into an object file and then link it into an executable program. The -c option tells the compiler not to link the executable program. The command idc -I../st80 -I.../MyClassLibrary -o bar foo.st    compiles the file foo.st to create an executable file called foo. The -o option overrides the default name of the output file, if required.  The search path for imported and included files", "textAfterTable": "{ directive optionalArguments... } to direct the compiler to perform some unusual action. The most commonly used directive is import:. The imperative { import: name } asks the compiler to search for a file called 'name.st' and make the global declarations within it available to the importing program. The complete list of supported directives is given in the appendix Compiler directives. 3.2\u00a0\u00a0\u00a0Prototype definitions Two top-level forms provide for the creation of new prototypes: name ( listOfSlots ) creates a new 'root' prototype (it has no parent, or 'delegate') and binds it to name. The prototype contains zero or more named slots, similar to instance variables. The definition could be read as: \" name is listOfSlots\". Such a prototype has no useful behaviour (it can't even clone itself to create useful application objects). Adding a minimum of primitive behaviour (e.g., cloning) is the first thing you'll want to do to such an object. The second form: name : parent ( listOfSlots ) is similar, except the new prototype delegates to the named parent object and inherits the parent object's slots before adding its own. Such definitions could be read as: \" name extends parent with listOfSlots\". (This is every bit as bogus as a single inheritance mechanism being used to share state and behaviour, but I'm still trying to figure out how to separate delegation from the sharing of state without sacrificing performance. Only allowing slots", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}