{"relation": [["Python", "+", "-", "*", "/", "**", "or", "and", "<", "<=", "==", "!="], ["R", "+", "-", "*", "/", "** or ^", "|", "&", "<", "<=", "==", "!="]], "pageTitle": "Vectors and arrays \u2014 rpy2 2.3.9 documentation", "title": "", "url": "http://rpy.sourceforge.net/rpy2/doc-2.3/html/vector.html", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 3, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988305.14/warc/CC-MAIN-20150728002308-00302-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 201519975, "recordOffset": 201500526, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{76320=path : string with a path quote : quote character sep : separator character eol : end-of-line character(s) na : string for missing values dec : string for decimal separator row_names : boolean (save row names, or not) col_names : boolean (save column names, or not) comment_char : method to \u2018escape\u2019 special characters append : boolean (append if the file in the path is already existing, or not), 72575=path : string with a path header : boolean (heading line with column names or not) sep : separator character quote : quote character row_names : column name, or column index for column names (warning: indexing starts at one in R) fill : boolean (fill the lines when less entries than columns) comment_char : comment character as_is : boolean (keep the columns of strings as such, or turn them into factors)}", "lastModified": "Sun, 26 Jan 2014 21:22:40 GMT", "textBeforeTable": "For example, the following vector of labels R\u2019s factors are somewhat peculiar: they aim at representing a memory-efficient vector of labels, and in order to achieve it are implemented as vectors of integers to which are associated a (presumably shorter) vector of labels. Each integer represents the position of the label in the associated vector of labels. FactorVector\u00b6 New in version 2.2.0: Vectors for date or time points return a POSIXct vector from a sequence of datetime.datetime elements. \u00b6 ) seq ( sexp_from_datetime static The constructor accepts either an R vector floats or a sequence (an object with the Python sequence interface) of time.struct_time objects. POSIXlt(seq) -> POSIXlt. Representation of dates as seconds since Epoch. This form is preferred to POSIXlt for inclusion in a DataFrame. Bases: rpy2.robjects.vectors.POSIXt, rpy2.robjects.vectors.FloatVector \u00b6 ) obj ( POSIXct rpy2.robjects.vectors. class The constructor accepts either an R vector or a sequence (an object with the Python sequence interface) of time.struct_time objects. POSIXlt(seq) -> POSIXlt. Representation of dates with a 9-component structure (similar to Python\u2019s time.struct_time). Bases: rpy2.robjects.vectors.POSIXt, rpy2.robjects.vectors.Vector", "textAfterTable": ">>> sv = ro.StrVector('ababbc') >>> fac = ro.FactorVector(sv) >>> print(fac) [1] a b a b b c Levels: a b c >>> tuple(fac) (1, 2, 1, 2, 2, 3) >>> tuple(fac.levels) ('a', 'b', 'c') Since a FactorVector is an IntVector with attached metadata (the levels), getting items Python-style was not changed from what happens when gettings items from a IntVector. A consequence to that is that information about the levels is then lost. >>> item_i = 0 >>> fac[item_i] 1 Getting the level corresponding to an item requires using the levels,: >>> fac.levels[fac[item_i] - 1] 'a' Warning Do not forget to subtract one to the value in the FactorVector. Indexing in Python starts at zero while indexing R starts at one, and recovering the level for an item requires an adjustment between the", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}