{"relation": [["rcd1ab55", "7", "8", "9", "", "", "", "", "", "10", "11", "12", "13", "14", "", "", "", "", "", "15", "16", "17", "18", "19", "20", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "21", "22", "23", "24", "25", "", "26", "27", "", "28", "29", "", "30", "31", "\u2026", "34", "35", "", "", "", "", "", "36", "37", "\u2026", "39", "40", "41", "42", "43", "44", "45", "", "", "", "46", "47", "48", "", "49", "50", "\u2026", "56", "57", "", "58", "59", "60", "61", "", "62", "63", "\u2026", "65", "66", "", "", "67", "", "68", "69", "70", "", "", "", "", "", "", "71", "72", "\u2026", "75", "76", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "77", "78", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "79", "80", "", "", "", "", "", "", "", "", "", "", "", "", "", "81", "82", "", "", "", "", "", "", "", "", "", "", "", "", "", "83", "84", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "85", "86"], ["rb62cf2b", "7", "8", "", "9", "10", "11", "12", "13", "14", "15", "", "", "", "16", "17", "18", "19", "20", "21", "22", "23", "", "", "", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "", "55", "56", "57", "58", "59", "60", "61", "62", "63", "\u2026", "66", "67", "68", "69", "70", "71", "72", "73", "74", "\u2026", "76", "77", "", "78", "79", "", "80", "81", "82", "83", "84", "", "", "85", "86", "87", "\u2026", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "\u2026", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", "120", "\u2026", "123", "124", "125", "126", "127", "128", "129", "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", "190", "191", "192", "193", "194", "195", "196", "197", "198", "199", "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", "210", "211", "212", "213", "214", "215", "216", "217", "218", "219", "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", "230", "231", "232", "233", "234", "235", "236", "237", "238", "239", "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", "250", "251", "252", "253", "254", "255", "256", "257", "258", "259", "260", "261", "262", "263", "264", "265", "266", "267", "268", "269", "270", "271", "272", "273", "274", "275", "276", "277", "278", "279", "280", "281", "282", "283", "284", "285", "286", "287", "288", "289", "290", "291", "292", "293", "294", "295", "296", "297", "298", "299", "300", "301", "302", "303", "304", "305", "306", "307", "308", "309", "310", "311", "312", "313", "314", "315", "316", "317", "318", "319", "320", "321", "322", "323", "324", "325", "326", "327", "328", "329", "330", "331", "332", "333", "334"], ["", "#include \"eventer/eventer.h\"", "#include \"utils/noit_atomic.h\"", "", "#include \"utils/noit_skiplist.h\"", "", "#include", "#include", "#include", "#include", "#include", "", "int maxfds;", "struct {", "#include", "", "static struct timeval __max_sleeptime = { 0, 200000 }; /* 200ms */", "static int maxfds;", "static struct {", "eventer_t e;", "pthread_t executor;", "noit_spinlock_t lock;", "} **master_fds;", "", "int kqueue_fd;", "} *master_fds = NULL;", "", "typedef enum { EV_OWNED, EV_ALREADY_OWNED } ev_lock_state_t;", "", "static ev_lock_state_t", "acquire_master_fd(int fd) {", "if(noit_spinlock_trylock(&master_fds[fd].lock)) {", "master_fds[fd].executor = pthread_self();", "return EV_OWNED;", "}", "if(pthread_equal(master_fds[fd].executor, pthread_self())) {", "return EV_ALREADY_OWNED;", "}", "noit_spinlock_lock(&master_fds[fd].lock);", "master_fds[fd].executor = pthread_self();", "return EV_OWNED;", "}", "static void", "release_master_fd(int fd, ev_lock_state_t as) {", "if(as == EV_OWNED) {", "memset(&master_fds[fd].executor, 0, sizeof(master_fds[fd].executor));", "noit_spinlock_unlock(&master_fds[fd].lock);", "}", "}", "", "static pthread_t master_thread;", "static int kqueue_fd = -1;", "typedef struct kqueue_setup {", "struct kevent *__ke_vec;", "unsigned int __ke_vec_a;", "unsigned int __ke_vec_used;", "} * kqs_t;", "} * kqs_t;", "", "static pthread_mutex_t kqs_lock;", "static pthread_mutex_t te_lock;", "static kqs_t master_kqs = NULL;", "static pthread_key_t kqueue_setup_key;", "static noit_skiplist *timed_events = NULL;", "#define KQUEUE_DECL kqs_t kqs", "#define KQUEUE_SETUP kqs = (kqs_t) pthread_getspecific(kqueue_setup_key)", "", "#define ke_vec_used kqs->__ke_vec_used", "", "static void kqs_init(kqs_t kqs) {", "enum { initial_alloc = 64 };", "ke_vec_a = initial_alloc;", "ke_vec = (struct kevent *) malloc(ke_vec_a * sizeof (struct kevent));", "}", "static void", "ke_change (register int const ident,", "", "register int const flags,", "register void *const udata) {", "enum { initial_alloc = 64 };", "register struct kevent *kep;", "KQUEUE_DECL;", "", "KQUEUE_SETUP;", "if(!kqs) kqs = master_kqs;", "", "if(kqs == master_kqs) pthread_mutex_lock(&kqs_lock);", "if (!ke_vec_a) {", "ke_vec_a = initial_alloc;", "ke_vec = (struct kevent *) malloc(ke_vec_a * sizeof (struct kevent));", "kqs_init(kqs);", "}", "else if (ke_vec_used == ke_vec_a) {", "", "", "EV_SET(kep, ident, filter, flags, 0, 0, udata);", "if(kqs == master_kqs) pthread_mutex_unlock(&kqs_lock);", "}", "", "static int eventer_kqueue_impl_init() {", "struct rlimit rlim;", "master_thread = pthread_self();", "kqueue_fd = kqueue();", "if(kqueue_fd == -1) {", "", "}", "pthread_mutex_init(&kqs_lock, NULL);", "pthread_mutex_init(&te_lock, NULL);", "pthread_key_create(&kqueue_setup_key, NULL);", "master_kqs = calloc(1, sizeof(*master_kqs));", "kqs_init(master_kqs);", "getrlimit(RLIMIT_NOFILE, &rlim);", "maxfds = rlim.rlim_cur;", "master_fds = calloc(maxfds, sizeof(*master_fds));", "timed_events = calloc(1, sizeof(*timed_events));", "noit_skiplist_init(timed_events);", "noit_skiplist_set_compare(timed_events,", "eventer_timecompare, eventer_timecompare);", "noit_skiplist_add_index(timed_events,", "noit_compare_voidptr, noit_compare_voidptr);", "return 0;", "}", "", "}", "static void eventer_kqueue_impl_add(eventer_t e) {", "assert(e->mask);", "ev_lock_state_t lockstate;", "", "/* Timed events are simple */", "if(e->mask == EVENTER_TIMER) {", "pthread_mutex_lock(&te_lock);", "noit_skiplist_insert(timed_events, e);", "pthread_mutex_unlock(&te_lock);", "return;", "}", "", "/* file descriptor event */", "lockstate = acquire_master_fd(e->fd);", "master_fds[e->fd].e = e;", "if(e->mask & (EVENTER_READ | EVENTER_EXCEPTION))", "ke_change(e->fd, EVFILT_READ, EV_ADD | EV_ENABLE, e);", "if(e->mask & (EVENTER_WRITE))", "ke_change(e->fd, EVFILT_WRITE, EV_ADD | EV_ENABLE, e);", "release_master_fd(e->fd, lockstate);", "}", "static void eventer_kqueue_impl_remove(eventer_t e) {", "if(e->mask & (EVENTER_READ | EVENTER_WRITE | EVENTER_EXCEPTION)) {", "ev_lock_state_t lockstate;", "lockstate = acquire_master_fd(e->fd);", "if(e == master_fds[e->fd].e) {", "master_fds[e->fd].e = NULL;", "if(e->mask & (EVENTER_READ | EVENTER_EXCEPTION))", "ke_change(e->fd, EVFILT_READ, EV_DELETE | EV_DISABLE, e);", "if(e->mask & (EVENTER_WRITE))", "ke_change(e->fd, EVFILT_WRITE, EV_DELETE | EV_DISABLE, e);", "}", "release_master_fd(e->fd, lockstate);", "}", "else if(e->mask & EVENTER_TIMER) {", "pthread_mutex_lock(&te_lock);", "noit_skiplist_remove_compare(timed_events, e, NULL, noit_compare_voidptr);", "pthread_mutex_unlock(&te_lock);", "}", "else {", "abort();", "}", "}", "static void eventer_kqueue_impl_update(eventer_t e) {", "if(e->mask & EVENTER_TIMER) {", "pthread_mutex_lock(&te_lock);", "noit_skiplist_remove_compare(timed_events, e, NULL, noit_compare_voidptr);", "noit_skiplist_insert(timed_events, e);", "pthread_mutex_unlock(&te_lock);", "return;", "}", "ke_change(e->fd, EVFILT_READ, EV_DELETE | EV_DISABLE, e);", "ke_change(e->fd, EVFILT_WRITE, EV_DELETE | EV_DISABLE, e);", "if(e->mask & (EVENTER_READ | EVENTER_EXCEPTION))", "ke_change(e->fd, EVFILT_READ, EV_DELETE | EV_DISABLE, e);", "if(e->mask & (EVENTER_WRITE))", "ke_change(e->fd, EVFILT_WRITE, EV_DELETE | EV_DISABLE, e);", "}", "static eventer_t eventer_kqueue_impl_remove_fd(int fd) {", "eventer_t eiq = NULL;", "ev_lock_state_t lockstate;", "if(master_fds[fd].e) {", "lockstate = acquire_master_fd(fd);", "eiq = master_fds[fd].e;", "master_fds[fd].e = NULL;", "if(eiq->mask & (EVENTER_READ | EVENTER_EXCEPTION))", "ke_change(fd, EVFILT_READ, EV_DELETE | EV_DISABLE, eiq);", "if(eiq->mask & (EVENTER_WRITE))", "ke_change(fd, EVFILT_WRITE, EV_DELETE | EV_DISABLE, eiq);", "release_master_fd(fd, lockstate);", "}", "return eiq;", "}", "static void eventer_kqueue_impl_loop() {", "int is_master_thread = 0;", "pthread_t self;", "KQUEUE_DECL;", "KQUEUE_SETUP;", "", "self = pthread_self();", "if(pthread_equal(self, master_thread)) is_master_thread = 1;", "", "if(!kqs) {", "kqs = calloc(1, sizeof(*kqs));", "kqs_init(kqs);", "}", "pthread_setspecific(kqueue_setup_key, kqs);", "while(1) {", "struct timeval __now, __sleeptime;", "struct timespec __kqueue_sleeptime;", "int fd_cnt = 0;", "int max_timed_events_to_process;", "int newmask;", "", "__sleeptime = __max_sleeptime;", "", "/* Handle timed events...", "* we could be multithreaded, so if we pop forever we could starve", "* ourselves. */", "max_timed_events_to_process = timed_events->size;", "while(max_timed_events_to_process-- > 0) {", "eventer_t timed_event;", "", "gettimeofday(&__now, NULL);", "", "pthread_mutex_lock(&te_lock);", "/* Peek at our next timed event, if should fire, pop it.", "* otherwise we noop and NULL it out to break the loop. */", "timed_event = noit_skiplist_peek(timed_events);", "if(timed_event) {", "if(compare_timeval(timed_event->whence, __now) < 0) {", "timed_event = noit_skiplist_pop(timed_events, NULL);", "}", "else {", "sub_timeval(timed_event->whence, __now, &__sleeptime);", "timed_event = NULL;", "}", "}", "pthread_mutex_unlock(&te_lock);", "if(timed_event == NULL) break;", "", "/* Make our call */", "newmask = timed_event->callback(timed_event, EVENTER_TIMER,", "timed_event->closure, &__now);", "if(newmask)", "eventer_add(timed_event);", "else", "eventer_free(timed_event);", "}", "", "if(compare_timeval(__max_sleeptime, __sleeptime) < 0) {", "/* we exceed our configured maximum, set it down */", "memcpy(&__sleeptime, &__max_sleeptime, sizeof(__sleeptime));", "}", "", "/* If we're the master, we need to lock the master_kqs and make mods */", "if(master_kqs->__ke_vec_used) {", "struct timespec __zerotime = { 0, 0 };", "pthread_mutex_lock(&kqs_lock);", "fd_cnt = kevent(kqueue_fd,", "master_kqs->__ke_vec, master_kqs->__ke_vec_used,", "NULL, 0,", "&__zerotime);", "if(fd_cnt < 0) {", "fprintf(stderr, \"kevent: %s\\n\", strerror(errno));", "}", "master_kqs->__ke_vec_used = 0;", "pthread_mutex_unlock(&kqs_lock);", "}", "", "/* Now we move on to our fd-based events */", "__kqueue_sleeptime.tv_sec = __sleeptime.tv_sec;", "__kqueue_sleeptime.tv_nsec = __sleeptime.tv_usec * 1000;", "fd_cnt = kevent(kqueue_fd, ke_vec, ke_vec_used,", "ke_vec, ke_vec_a,", "&__kqueue_sleeptime);", "ke_vec_used = 0;", "if(fd_cnt < 0) {", "fprintf(stderr, \"kevent: %s\\n\", strerror(errno));", "}", "else {", "int idx;", "for(idx = 0; idx < fd_cnt; idx++) {", "ev_lock_state_t lockstate;", "struct kevent *ke;", "eventer_t e;", "int fd, evmask, oldmask;", "", "ke = &ke_vec[idx];", "e = (eventer_t)ke->udata;", "fd = ke->ident;", "assert(e == master_fds[fd].e);", "lockstate = acquire_master_fd(fd);", "assert(lockstate == EV_OWNED);", "", "evmask = 0;", "if(ke->filter == EVFILT_READ) evmask = EVENTER_READ;", "if(ke->filter == EVFILT_WRITE) evmask = EVENTER_WRITE;", "gettimeofday(&__now, NULL);", "oldmask = e->mask;", "newmask = e->callback(e, evmask, e->closure, &__now);", "", "if(newmask) {", "/* toggle the read bits if needed */", "if(newmask & (EVENTER_READ | EVENTER_EXCEPTION)) {", "if(!(oldmask & (EVENTER_READ | EVENTER_EXCEPTION)))", "ke_change(fd, EVFILT_READ, EV_ADD | EV_ENABLE, e);", "}", "else if(oldmask & (EVENTER_READ | EVENTER_EXCEPTION))", "ke_change(fd, EVFILT_READ, EV_DELETE | EV_DISABLE, e);", "", "/* toggle the write bits if needed */", "if(newmask & EVENTER_WRITE) {", "if(!(oldmask & EVENTER_WRITE))", "ke_change(fd, EVFILT_WRITE, EV_ADD | EV_ENABLE, e);", "}", "else if(oldmask & EVENTER_WRITE)", "ke_change(fd, EVFILT_WRITE, EV_DELETE | EV_DISABLE, e);", "", "/* Set our mask */", "e->mask = newmask;", "}", "else {", "eventer_free(e);", "}", "release_master_fd(fd, lockstate);", "}", "}", "}", "}", ""]], "pageTitle": "Reconnoiter ~ Changeset b62cf2be087943dcb29b6e068bd4262862fcb17d", "title": "", "url": "http://labs.omniti.com/labs/reconnoiter/changeset/b62cf2be087943dcb29b6e068bd4262862fcb17d/", "hasHeader": true, "headerPosition": "MIXED", "tableType": "RELATION", "tableNum": 4, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988650.53/warc/CC-MAIN-20150728002308-00278-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 138596687, "recordOffset": 138584997, "tableOrientation": "HORIZONTAL", "textBeforeTable": "configure.in Moved Copied Modified Removed Added Unmodified Legend: src/utils/noit_skiplist.h (added) src/utils/noit_skiplist.c (added) src/utils/Makefile.in (modified) (1\u00a0diff) src/noitd.c (modified) (2\u00a0diffs) src/noit_defines.h (modified) (1\u00a0diff) src/eventer/eventer_kqueue_impl.c (modified) (6\u00a0diffs) src/eventer/eventer_POSIX_fd_opset.c (modified) (1\u00a0diff) src/eventer/eventer.h (modified) (2\u00a0diffs) src/eventer/eventer.c (modified) (1\u00a0diff) configure.in (modified) (1\u00a0diff) Files: more work... fleshing out the eventer Message: Theo Schlossnagle <jesus@omniti.com> 1197870206 +0000 git-author:", "textAfterTable": "\u00a0 275 \u00a0 \u00a0 __kqueue_sleeptime.tv_sec = __sleeptime.tv_sec;\u00a0 \u00a0 276 \u00a0 \u00a0 __kqueue_sleeptime.tv_nsec = __sleeptime.tv_usec * 1000;\u00a0 \u00a0 277 \u00a0 \u00a0 fd_cnt = kevent(kqueue_fd, ke_vec, ke_vec_used,\u00a0 \u00a0 278 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ke_vec, ke_vec_a,\u00a0 \u00a0 279 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 &__kqueue_sleeptime);\u00a0 \u00a0 280 \u00a0 \u00a0 ke_vec_used = 0;\u00a0 \u00a0 281 \u00a0 \u00a0 if(fd_cnt < 0) {\u00a0 \u00a0 282 \u00a0 \u00a0 \u00a0 fprintf(stderr, \"kevent: %s\\n\", strerror(errno));\u00a0 \u00a0 283 \u00a0 \u00a0 }\u00a0 \u00a0 284 \u00a0 \u00a0 else {\u00a0 \u00a0 285 \u00a0 \u00a0 \u00a0 int idx;\u00a0 \u00a0 286 \u00a0 \u00a0 \u00a0 for(idx = 0; idx < fd_cnt; idx++) {\u00a0 \u00a0 287 \u00a0 \u00a0 \u00a0 \u00a0 ev_lock_state_t lockstate;\u00a0 \u00a0 288 \u00a0 \u00a0 \u00a0 \u00a0 struct kevent *ke;\u00a0 \u00a0 289 \u00a0 \u00a0 \u00a0 \u00a0 eventer_t e;\u00a0 \u00a0 290 \u00a0 \u00a0 \u00a0 \u00a0 int fd, evmask, oldmask;\u00a0 \u00a0 291 \u00a0 \u00a0 292 \u00a0 \u00a0 \u00a0 \u00a0 ke = &ke_vec[idx];\u00a0 \u00a0 293 \u00a0 \u00a0 \u00a0 \u00a0 e = (eventer_t)ke->udata;\u00a0 \u00a0 294 \u00a0 \u00a0 \u00a0 \u00a0 fd = ke->ident;\u00a0 \u00a0 295 \u00a0 \u00a0 \u00a0 \u00a0 assert(e == master_fds[fd].e);\u00a0 \u00a0 296 \u00a0 \u00a0 \u00a0", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}