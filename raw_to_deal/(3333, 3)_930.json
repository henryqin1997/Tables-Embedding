{"relation": [["Error Message", "ORU-10001 lock request error, status: N", "ORU-10015 error: N waiting for pipe status", "ORU-10016 error: N sending on pipe 'X'", "ORU-10017 error: N receiving on pipe 'X'", "ORU-10019 error: N on lock request", "ORU-10020 error: N on lock request", "ORU-10021 lock request error; status: N", "ORU-10022 lock request error, status: N", "ORU-10023 lock request error; status N", "ORU-10024 there are no alerts registered", "ORU-10025 lock request error; status N", "ORU-10037 attempting to wait on uncommitted signal from same session"], ["Procedure", "SIGNAL", "WAITANY", "SIGNAL", "SIGNAL", "WAIT", "WAITANY", "REGISTER", "SIGNAL", "WAITONE", "WAITANY", "REGISTER", "WAITONE"]], "pageTitle": "DBMS_ALERT", "title": "", "url": "http://docs.oracle.com/cd/B19306_01/appdev.102/b14258/d_alert.htm", "hasHeader": true, "headerPosition": "MIXED", "tableType": "RELATION", "tableNum": 1, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438044160065.87/warc/CC-MAIN-20150728004240-00054-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 73678919, "recordOffset": 73663281, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{20495=Message, of 1800 bytes or less, to associate with this alert., 891=The maximum time to wait for an alert (1000 days which is essentially forever).}", "lastModified": "Wed, 13 May 2015 05:07:10 GMT", "textBeforeTable": "Table 13-2 DBMS_ALERT Error Messages WAITANY procedure. If you use the WAITANY procedure, and if a signalling session does a signal but does not commit within one second of the signal, a polling loop is required so that this uncommitted alert does not camouflage other alerts. The polling loop begins at a one second interval and exponentially backs off to 30-second intervals. Shared mode. If your database is running in shared mode, a polling loop is required to check for alerts from another instance. The polling loop defaults to one second and can be set by the SET_DEFAULTS procedure. Usually, Oracle is event-driven; this means that there are no polling loops. There are two cases where polling loops can occur: It is possible to receive an alert, read the data, and find that no data has changed. This is because the data changed after the prior alert, but before the data was read for that prior alert. If the transaction is rolled back after the call to SIGNAL, no alert occurs. Chapter 70, \"DBMS_PIPE\" See Also: If the application does not require transaction-based alerts, the DBMS_PIPE package may provide a useful alternative. Alerts can be signalled more often than the corresponding application wait calls. In such cases, the older alerts are discarded. The application always gets the latest alert (based on", "textAfterTable": "Examples Suppose you want to graph average salaries by department, for all employees. Your application needs to know whenever EMP is changed. Your application would look similar to this code:  DBMS_ALERT.REGISTER('emp_table_alert'); <<readagain>>: /* ... read the emp table and graph it */ DBMS_ALERT.WAITONE('emp_table_alert', :message, :status); if status = 0 then goto <<readagain>>; else /* ... error condition */ The EMP table would have a trigger similar to this:  CREATE TRIGGER emptrig AFTER INSERT OR UPDATE OR DELETE ON emp BEGIN DBMS_ALERT.SIGNAL('emp_table_alert', 'message_text'); END; When the application is no longer interested in the alert, it makes this request:  DBMS_ALERT.REMOVE('emp_table_alert'); This reduces the amount of work required by the alert signaller. If a session exits (or dies) while registered alerts exist, the alerts are eventually cleaned up by future users of this package. The example guarantees that the application always sees the latest data, although it may not see every intermediate value. Summary of DBMS_ALERT Subprograms Table 13-3 DBMS_ALERT Package Subprograms Subprogram Description REGISTER Procedure Receives messages from an alert", "hasKeyColumn": true, "keyColumnIndex": 0, "headerRowIndex": 0}