{"relation": [["S.N.", "1.", "2.", "3.", "4.", "5.", "6."], ["Method & Purpose", "coroutine.create (f): Creates a new coroutine with a function f and returns an object of type \"thread\".", "coroutine.resume (co [, val1, ...]): Resumes the corountine co and passes the parameters if any. It returns status of operation and optional other return values.", "coroutine.running (): Returns the running coroutine or nil if called in the main thread.", "coroutine.status (co): Returns one of the values from running, normal, suspended or dead based on the state of the coroutine.", "coroutine.wrap (f): Like coroutine.create, the coroutine.wrap function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine.", "coroutine.yield (...): Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function."]], "pageTitle": "Lua Coroutines", "title": "", "url": "http://www.tutorialspoint.com/lua/lua_coroutines.htm", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 0, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990217.27/warc/CC-MAIN-20150728002310-00285-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 795354378, "recordOffset": 795346176, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{11394=\u00a9 Copyright 2015. All Rights Reserved.}", "lastModified": "Mon, 03 Aug 2015 20:40:19 GMT", "textBeforeTable": "The following table lists all the available functions for corountines in lua and their corresponding use. Functions available in coroutines The above definition may look vague. So let me tell it more clearly, assume we have two methods, one the main program method and a coroutine. When we call a coroutine using resume function, its starts executing and when we call yield function, it suspend executing. Again the same coroutine can continue executing with another resume function call from where it was suspended. This process can continue till the end of execution of the coroutine. Coroutines are collaborative in nature which allows two or more methods to execute in a controlled manner. With coroutines, at any given time, there is only one of its coroutines runs and this running coroutine only suspends its execution when it explicitly requests to be suspended. Introduction Next Page \u00a0 Previous Page google_ad_channel = \"\"; google_ad_type = \"image\"; google_ad_format = \"468x60_as\"; google_ad_height = 60; google_ad_width = 468; google_ad_client = \"pub-7133395778201029\";", "textAfterTable": "Example Let's look at an example to understand the concept of coroutines.  co = coroutine.create(function (value1,value2) local tempvar3 =10 print(\"coroutine section 1\", value1, value2, tempvar3) local tempvar1 = coroutine.yield(value1+1,value2+1) tempvar3 = tempvar3 + value1 print(\"coroutine section 2\",tempvar1 ,tempvar2, tempvar3) local tempvar1, tempvar2= coroutine.yield(value1+value2, value1-value2) tempvar3 = tempvar3 + value1 print(\"coroutine section 3\",tempvar1,tempvar2, tempvar3) return value2, \"end\" end) print(\"main\", coroutine.resume(co, 3, 2)) print(\"main\", coroutine.resume(co, 12,14)) print(\"main\", coroutine.resume(co, 5, 6)) print(\"main\", coroutine.resume(co, 10, 20)) When we run the above program, we will get the following output.  coroutine section 1\t3\t2\t10 main\ttrue\t4\t3 coroutine section 2\t12\tnil\t13 main\ttrue\t5\t1 coroutine section 3\t5\t6\t16 main\ttrue\t2\tend main\tfalse\tcannot resume dead coroutine What does the above example do? As mentioned before, we use the resume function to start the operation and yield function to stop the operation. Also, you can see how that there are multiple return values received by resume function of coroutine. I will explain each of the steps in the above program to make it clear. First, we create a coroutine and assign it to variable name co and the coroutine takes in two variables as its parameters. When we call the first resume function, the values 3 and 2 are retained in the temporary variables value1 and value2 till the end of the coroutine. To make you understand this, we have used a tempvar3 which is 10 initially and it gets updated to 13 and 16 by the subsequent calls of the coroutines since value1 is", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}