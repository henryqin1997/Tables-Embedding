{"relation": [["Parameter", "xctx", "node", "offset", "arg", "old"], ["In/Out", "IN", "IN", "IN", "IN", "OUT"], ["Description", "XML context", "CharacterData node; Text, Comment, or CDATA", "character offset where to start inserting", "data to insert", "previous data for node; data encoding"]], "pageTitle": "CharacterData Interface", "title": "", "url": "http://docs.oracle.com/cd/B13789_01/appdev.101/b10789/dom_c002.htm", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 13, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988399.65/warc/CC-MAIN-20150728002308-00267-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 75392086, "recordOffset": 75383884, "tableOrientation": "HORIZONTAL", "lastModified": "Mon, 22 Mar 2004 20:57:00 GMT", "textBeforeTable": "oratext **old) oratext *data, xmlnode *node, xmlctx *xctx, void XmlDomAppendData(  Syntax  The new node data will be allocated and managed by DOM, but if the previous node value was allocated and manager by the user, they are responsible for freeing it, which is why it is returned. Append a string to the end of a CharacterData node's data. If the node is not Text, Comment or CDATA, or if the string to append is NULL, does nothing. The appended data should be in the data encoding. It will not be verified, converted, or checked. XmlDomAppendData    Return substring of node's data. XmlDomSubstringData Set data for node. XmlDomSetCharData Replace part of node's data. XmlDomReplaceData Insert string into node's current data. XmlDomInsertData Return length of data for node. XmlDomGetCharDataLength Return data for node. XmlDomGetCharData Remove part of node's data.", "textAfterTable": "See Also: XmlDomGetCharData, XmlDomInsertData, XmlDomDeleteData, XmlDomReplaceData, XmlDomSplitText XmlDomDeleteData Remove a range of characters from a CharacterData node's data. If the node is not text, comment or CDATA, or if the offset is outside of the original data, does nothing. The offset is zero-based, so offset zero refers to the start of the data. Both offset and count are in characters, not bytes. If the sum of offset and count exceeds the data length then all characters from offset to the end of the data are deleted. The new node data will be allocated and managed by DOM, but if the previous node value was allocated and managed by the user, they are responsible for freeing it, which is why it is returned. Syntax void XmlDomDeleteData( xmlctx *xctx, xmlnode *node, ub4 offset, ub4 count, oratext **old) Parameter In/Out Description", "hasKeyColumn": true, "keyColumnIndex": 0, "headerRowIndex": 0}