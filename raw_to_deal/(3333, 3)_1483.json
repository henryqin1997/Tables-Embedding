{"relation": [["Flag or Switch", "-Woverloaded-virtual", "-Wreorder", "-Wsign-promo", "-Wnon-virtual-dtor", "-Weffc++"], ["Discussion", "Warn when a function declaration hides virtual functions from a base class.", "Warn when the order of member initializers given in the code does not match the order in which they must be executed.", "Warn when overload resolution chooses a promotion from unsigned or enumerated type to a signed type, over a conversion to an unsigned type of the same size.", "Warn when a class has virtual functions and an accessible non-virtual destructor.", "Warn about violations of the following style guidelines from Scott Meyers' Effective C++, Second Edition book."]], "pageTitle": "Difference between revisions of \"C-Based Toolchain Hardening\" - OWASP", "title": "Table 3: GCC C++ Warning Options", "url": "https://www.owasp.org/index.php?title=C-Based_Toolchain_Hardening&diff=159780&oldid=147115", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 3, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042982502.13/warc/CC-MAIN-20150728002302-00319-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 885857447, "recordOffset": 885820363, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{97324=Clang and LLVM have been aggressively developed since Apple lost its GPL compiler back in 2007 (due to Tivoization which resulted in GPLv3). Since that time, a number of developers and Goggle have joined the effort. While Clang will consume most (all?) GCC/Binutil flags and switches, the project supports a number of its own options, including a static analyzer. In addition, Clang is relatively easy to build with additional diagnostics, such as Dr. John Regher and Peng Li's Integer Overflow Checker (IOC)., 62316=In addition, project level integration is an opportunity to harden third party libraries you chose to include. Because you chose to include them, you and your users are responsible for them. If you or your users endure a SP800-53 audit, third party libraries will be in scope because the supply chain is included (specifically, item SA-12, Supply Chain Protection). The audits are not limited to those in the US Federal arena - financial institutions perform reviews too. A perfect example of violating this guidance is CVE-2012-1525, which was due to Adobe's inclusion of a defective Sablotron library., 60964=Project level integration presents opportunities to harden your program or library with domain specific knowledge. For example, if the platform supports Position Independent Executables (PIE or ASLR) and data execution prevention (DEP), then you should integrate with it. The consequences of not doing so could result in exploitation. As a case in point, see KingCope's 0-days for MySQL in December, 2012 (CVE-2012-5579 and CVE-2012-5612, among others). Integration with platform security would have neutered a number of the 0-days., 85227=The table below offers a set of compiler options to build your program. Static analysis warnings help catch mistakes early, while the linker options harden the executable at runtime. In the table below, \u201cGCC\u201d should be loosely taken as \u201cnon-ancient distributions.\u201d While the GCC team considers 4.2 ancient, you will still encounter it on Apple and BSD platforms due to changes in GPL licensing around 2007. Refer to GCC Option Summary, Options to Request or Suppress Warnings and Binutils (LD) Command Line Options for usage details., 47516=-O0 turns off optimizations and -g3 ensures maximum debug information is available. You may need to use -O1 so some analysis is performed. Otherwise, your debug build will be missing a number of warnings not present in release builds. -g3 ensures maximum debugging information is available for the debug session, including symbolic constants and #defines. -ggdb includes extensions to help with a debug session under GDB. For completeness, Jan Krachtovil stated -ggdb currently has no effect in a private email.}", "textBeforeTable": "In addition to what you should define, defining some macros and undefining others should trigger a security related defect. For example, -U_FORTIFY_SOURCES on Linux and _CRT_SECURE_NO_WARNINGS=1, _SCL_SECURE_NO_WARNINGS, _ATL_SECURE_NO_WARNINGS or STRSAFE_NO_DEPRECATE on Windows. Though Boost is missing from the list, it appears to lack recommendations, additional debug diagnostics, and a hardening guide. See BOOST Hardening Guide (Preprocessor Macros) for details. In addition, Tim Day points to [boost.build] should we not define _SECURE_SCL=0 by default for all msvc toolsets for a recent discussion related to hardening (or lack thereof). Additional macros include any macros needed to integrate properly and securely. It includes integrating the program with the platform (for example MFC or Cocoa/CocoaTouch) and libraries (for example, Crypto++ or OpenSSL). It can be a challenge because you have to have proficiency with your platform and all included libraries and frameworks. The list below illustrates the level of detail you will need when integrating. Additional Macros For more reading on asserting effectively, please see one of John Robbin's books, such as Debugging Applications. John is a legendary bug slayer in Windows circles, and he will show you how to do nearly everything, from debugging a simple program to bug slaying in multithreaded programs. Live hosts running production code should always define NDEBUG (i.e., release configuration), which means they do not assert or auto-abort. Auto-abortion is not acceptable behavior, and anyone who asks for the behavior", "textAfterTable": "SafeInt SAFEINT_DISALLOW_UNSIGNED_NEGATION=1 SAFEINT_DISALLOW_UNSIGNED_NEGATION=1 Microsoft _DEBUG=1, STRICT, _SECURE_SCL=1, _HAS_ITERATOR_DEBUGGING=1 _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES=1 _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT=1 STRICT _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES=1 _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT=1 Microsoft ATL & MFC _SECURE_ATL, _ATL_ALL_WARNINGS _ATL_CSTRING_EXPLICIT_CONSTRUCTORS _SECURE_ATL, _ATL_ALL_WARNINGS _ATL_CSTRING_EXPLICIT_CONSTRUCTORS STLPort _STLP_DEBUG=1, _STLP_USE_DEBUG_LIB=1 _STLP_DEBUG_ALLOC=1, _STLP_DEBUG_UNINITIALIZED=1 SQLite SQLITE_DEBUG, SQLITE_MEMDEBUG SQLITE_SECURE_DELETEc SQLITE_DEFAULT_FILE_PERMISSIONS=Nd SQLITE_SECURE_DELETEc SQLITE_DEFAULT_FILE_PERMISSIONS=Nd SQLCipher SQLITE_HAS_CODEC=1 SQLITE_TEMP_STORE=3e SQLITE_HAS_CODEC=1 SQLITE_TEMP_STORE=3e a Be careful with _GLIBCXX_DEBUG when using pre-compiled libraries such as Boost from a distribution. There are ABI incompatibilities, and the result will likely be a crash. You will have to compile Boost with _GLIBCXX_DEBUG or omit _GLIBCXX_DEBUG. b See Chapter 5, Diagnostics of the libstdc++ manual for details. c SQLite secure deletion zeroizes memory on destruction. Define as required, and always define in US Federal since zeroization is required for FIPS 140-2, Level 1. d N is 0644 by default, which means everyone has some access. e Force temporary tables into memory (no unencrypted data to disk). Compiler and Linker Compiler writers provide a rich set of warnings from the analysis of code during compilation. Both GCC and Visual Studio have static analysis capabilities to help find mistakes early in the development process. The built in static analysis capabilities of GCC and Visual", "hasKeyColumn": false, "keyColumnIndex": -1, "headerRowIndex": 0}