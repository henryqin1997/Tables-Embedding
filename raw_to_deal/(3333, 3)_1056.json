{"relation": [["Operation", "Initialize a semaphore", "Increment a semaphore", "Block on a semaphore count", "Decrement a semaphore count", "Destroy the semaphore state"], ["Related Function Description", "sem_init Syntax", "sem_post Syntax", "sem_wait Syntax", "sem_trywait Syntax", "sem_destroy Syntax"]], "pageTitle": "Synchronization With Semaphores - Multithreaded Programming Guide", "title": "", "url": "http://docs.oracle.com/cd/E26502_01/html/E35303/sync-11157.html", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 2, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042987866.61/warc/CC-MAIN-20150728002307-00051-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 76600515, "recordOffset": 76585181, "tableOrientation": "HORIZONTAL", "lastModified": "Wed, 31 Oct 2012 15:02:30 GMT", "textBeforeTable": "Table\u00a04-6 Routines for Semaphores When the semaphore count becomes zero, no more resources are present. Threads that try to decrement the semaphore when the count is zero block until the count becomes greater than zero. Conceptually, a semaphore is a nonnegative integer count. Semaphores are typically used to coordinate access to resources, with the semaphore count initialized to the number of free resources. Threads then atomically increment the count when resources are added and atomically decrement the count when resources are removed. Counting Semaphores Overview For more information about named semaphores, see the sem_open, sem_getvalue, sem_close, and sem_unlink man pages. The functions sem_open, sem_getvalue, sem_close, and sem_unlink are available to open, retrieve, close, and remove named semaphores. By using sem_open, you can create a named semaphore that has a name defined in the file system name space. Named semaphores are like process-shared semaphores, except that named semaphores are referenced with a pathname rather than a pshared value. Named semaphores are sharable by several processes. Named semaphores have an owner user-id, group-id, and a protection mode. POSIX semaphores can be unnamed or named. Unnamed semaphores are allocated in process memory and initialized. Unnamed semaphores might be usable by more than one process, depending on how the semaphore is allocated and initialized. Unnamed semaphores are either private, inherited through fork(), or are protected by access protections of the regular file", "textAfterTable": "Because semaphores need not be acquired and be released by the same thread, semaphores can be used for asynchronous event notification, such as in signal handlers. And, because semaphores contain state, semaphores can be used asynchronously without acquiring a mutex lock as is required by condition variables. However, semaphores are not as efficient as mutex locks. The scheduling policy determines the order in which blocked threads are awakened. The default scheduling policy, SCHED_OTHER, does not specify the order in which threads are awakened. Under the SCHED_FIFO and SCHED_RR real-time scheduling policies, threads are awakened in priority order. Semaphores must be initialized before use, however semaphores do not have attributes. Initializing a Semaphore Use sem-init to initialize the unnamed semaphore variable pointed to by sem to value amount. sem_init Syntax int sem_init(sem_t *sem, int pshared, unsigned int value); #include <semaphore.h> sem_t sem; int pshared; int ret; int value; /* initialize a private semaphore */ pshared = 0; value = 1; ret = sem_init(&sem, pshared, value); If the value of pshared is zero, then the semaphore cannot be shared between processes. If the value of pshared is nonzero, then the semaphore can be shared between processes. Multiple threads must not initialize the same semaphore. A semaphore must not be reinitialized while other threads might be using the semaphore. Initializing Semaphores With Intraprocess", "hasKeyColumn": true, "keyColumnIndex": 0, "headerRowIndex": 0}