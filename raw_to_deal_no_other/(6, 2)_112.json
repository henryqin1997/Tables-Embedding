{"relation": [["Name", "getBodyLength", "readInt", "readByte", "readUnsignedByte", "readBytes", "readShort", "readUnsignedShort", "readLong", "readFloat", "readDouble", "readBoolean", "readChar", "readUTF"], ["Description", "Get length of message body in bytes", "Read integer from message stream", "Read signed byte value from message stream", "Read unsigned byte value from message stream", "Read byte array from message stream", "Read signed short integer from message stream", "Read unsigned short integer from message stream", "Read long integer from message stream", "Read floating-point value from message stream", "Read double-precision value from message stream", "Read boolean value from message stream", "Read character from message stream", "Read UTF-8 string from message stream"]], "pageTitle": "Chapter\u00a02 Using the Java API (Sun GlassFish Message Queue 4.4 Developer's Guide for Java Clients)", "title": "", "url": "http://docs.oracle.com/cd/E19575-01/821-0029/aeqax/index.html", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 48, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042991019.80/warc/CC-MAIN-20150728002311-00159-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 67890127, "recordOffset": 67846224, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{86499=The Message Queue client runtime sets the JMSTimestamp header field to the time it delivers the message to the broker, expressed as a long integer in standard Java format (milliseconds since midnight, January 1, 1970 UTC). The message\u2019s lifetime, specified when the message is sent, is added to this value and the result is stored in the JMSExpiration header field. (The default lifetime value of 0, represented by the static constant Message.DEFAULT_TIME_TO_LIVE, denotes an unlimited lifetime. In this case, the expiration time is also set to 0 to indicate that the message never expires.) As with the message identifier, client applications that do not use a message\u2019s time stamp can improve performance by suppressing its generation with the message producer method setDisableMessageTimestamp (see Sending Messages).}", "lastModified": "Thu, 03 Feb 2011 14:29:30 GMT", "textBeforeTable": "Table\u00a02\u20131 Interface Classes for Messaging Domains JMS applications are free to use either of these messaging models, or even to mix them both within the same application. Historically, the JMS API provided a separate set of domain-specific object classes for each model. While these domain-specific interfaces continue to be supported for legacy purposes, client programmers are now encouraged to use the newer unified domain interface, which supports both models indiscriminately. For this reason, the discussions and code examples in this manual focus exclusively on the unified interfaces wherever possible. Table\u00a02\u20131 shows the API classes for all three domains. In the publish/subscribe (or pub/sub) model, a single message can be delivered from a producer to any number of consumers. The producer publishes the message to a topic, from which it is then delivered to all active consumers that have subscribed to the topic. Any number of producers can publish messages to a given topic, and each message can be delivered to any number of subscribed consumers. The model also supports the notion of durable subscriptions, in which a consumer registered with a topic need not be active at the time a message is published; when the consumer subsequently becomes active, it will receive the message. If no active consumers are registered for a topic, the topic does not hold the messages it receives unless it has inactive consumers with durable subscriptions.", "textAfterTable": "If a Message Queue client is a J2EE component, JNDI resources are provided by the J2EE container. In such cases, JNDI lookup code may differ from that shown here; see your J2EE provider documentation for details. Example\u00a02\u20131 Looking Up a Connection Factory // Create the environment for constructing the initial JNDI // naming context. Hashtable env = new Hashtable(); // Store the environment attributes that tell JNDI which initial context // factory to use and where to find the provider.// env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.fscontext.RefFSContextFactory\"); env.put(Context.PROVIDER_URL, \"file:///C:/imq_admin_objects\"); // Create the initial context. Context ctx = new InitialContext(env); // Look up the connection factory object in the JNDI object store. String CF_LOOKUP_NAME = \"MyConnectionFactory\"; ConnectionFactory myFactory = (ConnectionFactory) ctx.lookup (CF_LOOKUP_NAME); To Look Up a Connection Factory With JNDI Create the environment for constructing the initial JNDI naming context. How you create the initial context depends on whether you are using a file-system object store or a Lightweight Directory Access Protocol (LDAP) server for your Message Queue administered objects. The code shown here assumes a file-system store; for information about the corresponding LDAP object store attributes, see Using an LDAP User Repository in Sun GlassFish Message Queue 4.4 Administration Guide The constructor for the initial", "hasKeyColumn": true, "keyColumnIndex": 0, "headerRowIndex": 0}