{"relation": [["Field", "Name", "ID", "Nature", "Installation location", "Library locations", "Execution environment", "Interpreter arguments"], ["Description", "A label for the interpreter installation", "A logical identifier for the interpreter installation", "A logical identifier for the IDE (interpreter, source files, and so on)", "The path to the installation of the interpreter", "Paths to the interpreter's required libraries", "Environment variables and process configuration", "Parameters directed to the interpreter"]], "pageTitle": "Build an Eclipse development environment for Perl, Python, and PHP", "title": "", "url": "http://www.ibm.com/developerworks/opensource/tutorials/os-eclipse-octave/index.html", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 7, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042987228.91/warc/CC-MAIN-20150728002307-00219-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 514882191, "recordOffset": 514842166, "tableOrientation": "HORIZONTAL", "TableContextTimeStampBeforeTable": "{19703=27 October 2011 (First published 03 February 2009)}", "textBeforeTable": "Table 8. The data stored by IInterpreterInstall Although an IInterpreterInstallType object defines a class of interpreter installations, an IInterpreterInstall object must be created for each particular installation. This object serves as the interpreter's primary data storage object, and it holds the information in Table 8. The class attribute identifies an object that implements IInterpreterInstallType. Each installation type is given a name, an ID, a nature (a String that identifies the interpreter and source type), and the locations of the interpreter and any required libraries. In addition, each IInterpreterInstallType must create one or more IInterpreterInstall objects. </extension> </interpreterInstallType> id=\"org.dworks.octaveide.launch.OctaveInterpreterInstallType\"> class=\"org.dworks.octaveide.launch.OctaveInterpreterInstallType\" <interpreterInstallType <extension point=\"org.eclipse.dltk.launching.interpreterInstallTypes\">  Listing 12. Octave preference extensions The AddScriptInterpreterDialog constructor accepts an array of interpreter types and an object that implements IInterpreterInstall. Having multiple interpreter types allows the IDE to support multiple interpreters for the same language. The Octave IDE only supports one installation type, and it's identified in plugin.xml with an extension of org.eclipse.dltk.launching.interpreterInstallTypes. These preference extensions are shown in Listing 12.  The second method, createInterpreterDialog, forms the window that appears when the user clicks Add on the preference page. This window, shown in Figure 10, must furnish at least four pieces of information: the location of the interpreter executable, its name, its type, and the location of any libraries it requires to execute. To form this window, the createInterpreterDialog method requires an instance of the DLTK class AddScriptInterpreterDialog.  The abstract class InterpretersBlock requires that subclasses", "textAfterTable": "Finally, each IInterpreterInstall must provide access to an IInterpreterRunner object. This object is responsible for actually starting the interpreter, and the following discussion explains not only how it works but how it fits into the interpreter-IDE interaction as a whole. Back to top The DLTK interpreter and console The most important feature of a DLTK application isn't the text editor or preferences but the ability to launch an interpreter with a button click and view its output in the IDE console. The DLTK interpreter and console are closely entwined, and managing them in code is a complicated process. Before delving into all the classes and interfaces, here's a high-level look at the events that take place when the user clicks Run: The IDE responds to the button click by creating a launch object, collecting launch information, and adding a process to the launch. The creation of the launch notifies all launch listeners, including the DLTK console manager. The console manager acquires the launch information and uses it to create three objects: a console server, an interpreter object, and a console factory. The console server creates a socket (by default, port 25000) and waits for incoming connections. The console factory starts the interpreter and creates a console. The console manager accesses the Eclipse Console plug-in and adds the new console. DLTK classes handle much of this processing, but you still have", "hasKeyColumn": true, "keyColumnIndex": 0, "headerRowIndex": 0}