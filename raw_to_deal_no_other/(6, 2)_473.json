{"relation": [["Warning", "Warning", "UserWarning", "DeprecationWarning", "SyntaxWarning", "RuntimeWarning", "FutureWarning"], ["Description", "Root warning class", "A user-defined warning", "Warns about use of a deprecated feature", "Syntax issues", "Runtime issues", "Warns that a particular feature will be changing in a future release"]], "pageTitle": "idalton / JythonBook / source / chapter6.rst \u2014 Bitbucket", "title": "", "url": "https://bitbucket.org/idalton/jythonbook/src/c559df498a7e4c04d54c89a9c0a10f55494bd02f/chapter6.rst?at=tip", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 1, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988458.74/warc/CC-MAIN-20150728002308-00088-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 862765695, "recordOffset": 862739993, "tableOrientation": "HORIZONTAL", "textBeforeTable": "Below is a table of all exceptions that are built into the Python language along with a description of each. You can write any of these into a clause and try to handle them. Later in this chapter I will show you how you and them if you\u2019d like. Lastly, if there is a specific type of exception that you\u2019d like to throw that does not fit any of these, then you can write your own exception type object. How often have you been working in a program and performed some action that caused the program to abort and display a nasty error message? It happens more often than it should because most exceptions can be caught and handled nicely. By nicely, I mean that the program will not abort and the end user will receive a descriptive error message stating what the problem is, and in some cases how it can be resolved. The exception handling mechanisms within programming languages were developed for this purpose. Catching Exceptions Now let\u2019s go on to learn how to make this work in Python. Not only will we see how to handle and raise exceptions, but you\u2019ll also learn some other great techniques later in the chapter. } // execute code that must always be invoked } finally { // perform some exception handling } catch (ExceptionType messageVariable) { // perform some tasks that may throw an exception try {  For those who are unfamiliar, I will", "textAfterTable": "StandardError Base class for all built-in exceptions ArithmeticError Base for all arithmetic exceptions FloatingPointError Raised when a floating-point operation fails OverflowError Arithmetic operations that are too large ZeroDivisoinError Division or modulo operation with zero is divisor AssertionError Used when an assert statement fails AttributeError Attribute reference or failure to assign correctly EnvironmentError An error occurred outside of Python IOError Error in Input/Output operation OSError An error occurred in the os module EOFError input() or raw_input() tried to read past the end of a file ImportError Import failed to find module or name LookupError Base class for IndexError and KeyError IndexError A sequence index goes out of range KeyError Referenced a non-existent mapping (dict) key MemoryError Memory exhausted NameError Failure to find a local or global name UnboundLocalError Unassigned local variable is referenced ReferenceError Attempt to access a garbage-collected object RuntimeError Obsolete catch-all error NotImplementedError Raised when a feature is not implemented SyntaxError Parser encountered a syntax error IndentationError Parser encountered an indentation issue TabError Incorrect mixture of tabs and spaces SystemError Non-fatal interpreter error TypeError Inappropriate type was passed to a built-in operator or function ValueError Argument error not covered by TypeError or a more precise error", "hasKeyColumn": true, "keyColumnIndex": 0, "headerRowIndex": 0}