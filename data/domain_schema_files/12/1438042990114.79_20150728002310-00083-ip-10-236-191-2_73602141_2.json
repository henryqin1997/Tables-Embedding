{
    "relation": [
        [
            "access",
            "public",
            "public-read",
            "public-read",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public-read",
            "public",
            "public-read protected",
            "public",
            "public-read protected",
            "public",
            "public-read protected",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public-read package",
            "public",
            "public-read protected",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public-read package",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public",
            "public"
        ],
        [
            "name",
            "blocksMouse",
            "boundsInLocal",
            "boundsInParent",
            "cache",
            "cacheHint",
            "clip",
            "cursor",
            "disable",
            "disabled",
            "effect",
            "focused",
            "focusTraversable",
            "hover",
            "id",
            "layoutBounds",
            "layoutInfo",
            "layoutX",
            "layoutY",
            "managed",
            "onKeyPressed",
            "onKeyReleased",
            "onKeyTyped",
            "onMouseClicked",
            "onMouseDragged",
            "onMouseEntered",
            "onMouseExited",
            "onMouseMoved",
            "onMousePressed",
            "onMouseReleased",
            "onMouseWheelMoved",
            "opacity",
            "parent",
            "pickOnBounds",
            "pressed",
            "rotate",
            "rotationAxis",
            "scaleX",
            "scaleY",
            "scaleZ",
            "scene",
            "style",
            "styleClass",
            "transforms",
            "translateX",
            "translateY",
            "translateZ",
            "visible"
        ],
        [
            "type",
            "Boolean",
            "Bounds",
            "Bounds",
            "Boolean",
            "CacheHint",
            "Node",
            "Cursor",
            "Boolean",
            "Boolean",
            "Effect",
            "Boolean",
            "Boolean",
            "Boolean",
            "String",
            "Bounds",
            "LayoutInfoBase",
            "Number",
            "Number",
            "Boolean",
            "function(:KeyEvent):Void",
            "function(:KeyEvent):Void",
            "function(:KeyEvent):Void",
            "function(:MouseEvent):Void",
            "function(:MouseEvent):Void",
            "function(:MouseEvent):Void",
            "function(:MouseEvent):Void",
            "function(:MouseEvent):Void",
            "function(:MouseEvent):Void",
            "function(:MouseEvent):Void",
            "function(:MouseEvent):Void",
            "Number",
            "Parent",
            "Boolean",
            "Boolean",
            "Number",
            "Point3D",
            "Number",
            "Number",
            "Number",
            "Scene",
            "String",
            "String",
            "Transform[]",
            "Number",
            "Number",
            "Number",
            "Boolean"
        ],
        [
            "Can Read",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        [
            "Can Init",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "subclass",
            "",
            "subclass",
            "",
            "subclass",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "subclass",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        [
            "Can Write",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "subclass",
            "",
            "subclass",
            "",
            "subclass",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "subclass",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        [
            "Default Value",
            "false",
            "",
            "",
            "false",
            "CacheHint.DEFAULT",
            "null",
            "null",
            "false",
            "false",
            "null",
            "false",
            "false",
            "false",
            "empty string",
            "",
            "",
            "0",
            "0",
            "true",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "1.0",
            "null",
            "false",
            "false",
            "0.0",
            "Rotate.Z_AXIS",
            "1.0",
            "1.0",
            "1.0",
            "null",
            "empty string",
            "empty string",
            "empty",
            "0",
            "0",
            "0",
            "true"
        ],
        [
            "description",
            "If true, consumes mouse events in this Node and does not send them to other nodes further up the scene graph. If true, consumes mouse events in this Node and does not send them to other nodes further up the scene graph. If a Node wants to block mouse events from going to nodes which are visually obscured by this Node, then set blocksMouse to true.false Profile: common",
            "The rectangular bounds of this Node in the node's untransformed local coordinate space. The rectangular bounds of this Node in the node's untransformed local coordinate space. For nodes that extend javafx.scene.shape.Shape, the local bounds will also include space required for a non-zero stroke that may fall outside the shape's geometry that is defined by position and size attributes. The local bounds will also include any clipping set with clip as well as effects set with effect. Note that this method does not take the node's visibility into account; the test is based on the geometry of this Node only. This variable will always be a non-null value. Note that boundsInLocal is automatically recomputed whenever the geometry of a node changes. For this reason, it is an error to bind any of these values in a node to an expression that depends upon this variable. For example, the \"x\" or \"y\" variables of a shape should never be bound to boundsInLocal for the purpose of positioning the node. Profile: common",
            "The rectangular bounds of this Node which include its transforms. The rectangular bounds of this Node which include its transforms. boundsInParent is calculated by taking its local bounds (defined by boundsInLocal) and applying the transform created by setting the following additional variables: transforms[] sequence scaleX, scaleY rotate layoutX, layoutY translateX, translateY The resulting bounds will be conceptually in the coordinate space of the Node's parent, however the node need not have a parent to calculate these bounds. Note that this method does not take the node's visibility into account; the test is based on the geometry of this Node only. This variable will always be a non-null value. Note that boundsInParent is automatically recomputed whenever the geometry of a node changes, or when any of the following change: the transforms sequence, the translateX, translateY, layoutX, layoutY, scaleX, scaleY, or rotate variable. For this reason, it is an error to bind any of these values in a node to an expression that depends upon this variable. For example, the \"x\" or \"y\" variables of a shape, or translateX, translateY should never be bound to boundsInParent for the purpose of positioning the node. Profile: common",
            "A performance hint to the system to indicate that this Node should be cached as a bitmap. A performance hint to the system to indicate that this Node should be cached as a bitmap. Rendering a bitmap representation of a node will be faster than rendering primitives in many cases, especially in the case of primitives with effects applied (such as a blur). However, it also increases memory usage. This hint indicates whether that trade-off (increased memory usage for increased performance) is worthwhile. Also note that on some platforms such as GPU accelerated platforms there is little benefit to caching Nodes as bitmaps when blurs and other effects are used since they are very fast to render on the GPU. The cacheHint variable provides additional options for enabling more aggressive bitmap caching.false See Also: Node.cacheHint Profile: common",
            "Additional hint for controlling bitmap caching. Additional hint for controlling bitmap caching. Under certain circumstances, such as animating nodes that are very expensive to render, it is desirable to be able to perform transformations on the node without having to regenerate the cached bitmap. An option in such cases is to perform the transforms on the cached bitmap itself. This technique can provide a dramatic improvement to animation performance, though may also result in a reduction in visual quality. The cacheHint variable provides a hint to the system about how and when that trade-off (visual quality for animation performance) is acceptable. It is possible to enable the cacheHint only at times when your node is animating. In this way, expensive nodes can appear on screen with full visual quality, yet still animate smoothly. Example: expensiveNode.cache = true; expensiveNode.cacheHint = CacheHint.QUALITY; ... // Do an animation expensiveNode.cacheHint = CacheHint.SPEED; Timeline { keyFrames: [ KeyFrame { time: 2s values: [ expensiveNode.scaleX => 2.0, expensiveNode.scaleY => 2.0, expensiveNode.rotate=> 360, expensiveNode.cacheHint => CacheHint.QUALITY ] } ] }.play(); Note that cacheHint is only a hint to the system. Depending on the details of the node or the transform, this hint may be ignored. If Node.cache is false, cacheHint is ignored.CacheHint.DEFAULT See Also: Node.cache Profile: common",
            "Specifies a Node to use to define the the clipping shape for this Node. Specifies a Node to use to define the the clipping shape for this Node. This clipping Node is not a child of this Node in the scene graph sense. Rather, it is used to define the clip for this Node. For example, you can use an javafx.scene.image.ImageView Node as a mask to represent the Clip. Or you could use one of the geometric shape Nodes such as javafx.scene.shape.Rectangle or javafx.scene.shape.Circle. Or you could use a javafx.scene.text.Text node to represent the Clip. See the class documentation for Node for scene graph structure restrictions on setting the clip. If these restrictions are violated by a change to the clip variable, the change is ignored and the previous value of the clip variable is restored. Note: this is a conditional feature. See ConditionalFeature.SHAPE_CLIP for more information.null Profile: common conditional shape_clip",
            "Defines the mouse cursor for this Node and subnodes. Defines the mouse cursor for this Node and subnodes. If null, then the cursor of the first parent node with a non-null cursor will be used. If no Node in the scene graph defines a cursor, then the cursor of the Scene will be used.null Profile: common",
            "Sets the individual disabled state of this Node. Sets the individual disabled state of this Node. Setting disable to true will cause this Node and any subnodes to become disabled. This variable should be used only to set the disabled state of a Node. For querying the disabled state of a Node, the disabled variable should instead be used, since it is possible that a Node was disabled as a result of an ancestor being disabled even if the individual disable state on this Node is false.false Profile: common",
            "Indicates whether or not this Node is disabled. Indicates whether or not this Node is disabled. A Node will become disabled if disable is set to true on either itself or one of its ancestors in the scene graph. A disabled Node should render itself differently to indicate its disabled state to the user. Such disabled rendering is dependent on the implementation of the Node. The shape classes contained in javafx.scene.shape do not implement such rendering by default, therefore applications using shapes for handling input must implement appropriate disabled rendering themselves. The user-interface controls defined in javafx.scene.control will implement disabled-sensitive rendering, however. A disabled Node does not receive mouse or key events.false Profile: common",
            "Specifies an effect to apply to this Node. Specifies an effect to apply to this Node. Note: this is a conditional feature. See ConditionalFeature.EFFECT for more information.null Profile: common conditional effect",
            "Indicates whether this Node currently has the input focus. Indicates whether this Node currently has the input focus. To have the input focus, a node must be the Scene's focus owner, and the scene must be in a Stage that is visible and active. See requestFocus() for more information.false Profile: common",
            "Specifies whether this Node should be a part of focus traversal cycle. Specifies whether this Node should be a part of focus traversal cycle. When this property is true focus can be moved to this Node and from this Node using regular focus traversal keys. On a desktop such keys are usually TAB for moving focus forward and SHIFT+TAB for moving focus backward. When a Scene is created, the system gives focus to a Node whose focusTraversable variable is true and that is eligible to receive the focus, unless the focus had been set explicitly via a call to requestFocus().false Profile: common",
            "Whether or not this Node is being hovered over. Whether or not this Node is being hovered over. Typically this is due to the mouse being over the node, though it could be due to a pen hovering on a graphics tablet or other form of input. NOTE: the current implementation of hover relies on mouse enter and exit events to determine whether this Node is in the hover state; this means that this feature is currently supported only on systems that have a mouse. Future implementations may provide alternative means of supporting hover.false Profile: common",
            "The id of this Node. The id of this Node. This simple string identifier is useful for finding a specific Node within the scene graph. While the id of a Node should be unique within the scene graph, this uniqueness is not enforced. This is analogous to the \"id\" attribute on an HTML element.empty string Profile: common",
            "The rectangular bounds that should be used for layout calculations on this Node. The rectangular bounds that should be used for layout calculations on this Node. layoutBounds may differ from the visual bounds of the node and is computed differently depending on the node type. See javafx.scene.shape.Shape, javafx.scene.text.Text, Group, and javafx.scene.layout.Resizable for detailed descriptions on how layoutBounds are computed. Note that the layoutX, layoutY, translateX, and translateY variables are not included in the layoutBounds. This is important because layout code must first determine the current size and location of the Node (using layoutBounds) and then set layoutX and layoutY to adjust the translation of the Node so that it will have the desired layout position. Because the computation of layoutBounds is often tied to a node's geometric variables, it is an error to bind any such variables to an expression that depends upon layoutBounds. For example, the \"x\" or \"y\" variables of a shape should never be bound to layoutBounds for the purpose of positioning the node. Profile: common",
            "Hook for node-specific layout information used by layout containers. Hook for node-specific layout information used by layout containers. If the node is not a child of a container which supports layout info, this variable will be ignored. Note that layoutInfo object literals may be shared across nodes, which means altering the vars on a LayoutInfo will affect all such nodes.",
            "Defines the x coordinate of the translation that is added to this Node's transform for the purpose of layout. Defines the x coordinate of the translation that is added to this Node's transform for the purpose of layout. The value should be computed as the offset required to adjust the position of the node from its current layoutBounds.minX position (which might not be 0) to the desired location. For example, if textnode should be positioned at finalX: textnode.layoutX = finalX - textnode.layoutBounds.minX; Failure to subtract layoutBounds.minX may result in misplacement of the node. The node's final translation will be computed as layoutX + translateX, where layoutX establishes the node's stable position and translateX optionally makes dynamic adjustments to that position. If the node is managed and has a javafx.scene.layout.Container as its parent, then the container will set layoutX according to its own layout policy. If the node is unmanaged or parented by a Group or Scene, then the application may set layoutX directly to position it.0 Profile: common",
            "Defines the y coordinate of the translation that is added to this Node's transform for the purpose of layout. Defines the y coordinate of the translation that is added to this Node's transform for the purpose of layout. The value should be computed as the offset required to adjust the position of the node from its current layoutBounds.minY position (which might not be 0) to the desired location. For example, if textnode should be positioned at finalY: textnode.layoutY = finalY - textnode.layoutBounds.minY; Failure to subtract layoutBounds.minY may result in misplacement of the node. The node's final translation will be computed as layoutY + translateY, where layoutY establishes the node's stable position and translateY optionally makes dynamic adjustments to that position. If the node is managed and has a javafx.scene.layout.Container as its parent, then the container will set layoutY according to its own layout policy. If the node is unmanaged or parented by a Group or Scene, then the application may set layoutY directly to position it.0 Profile: common",
            "Defines whether or not this node's layout will be managed by it's parent. Defines whether or not this node's layout will be managed by it's parent. Each parent class follows a strategy for laying out managed children during the scene's layout pass: Group: sets the size of any Resizable children to their preferred size; does not alter the size of non-Resizable children; does not position children. javafx.scene.layout.Container classes: set the size of any javafx.scene.layout.Resizable content according to its layout rules and each Resizable's sizing preferences; does not alter the size of non-Resizable content; will position nodes (setting layoutX/layoutY) according to its layout rules. CustomNode: by default it behaves like Group, however its layout behavior may be overridden by a subclass. Parents will ignore unmanaged children for the purposes of layout and it is the application's responsibility to set the size and position of an unmanaged node. By default all nodes are managed. If a Parent node is unmanaged, then it will act as a root for layout, which means that layout requests beneath it will cause only the branch rooted by the parent node to be relayed out.true",
            "Defines a function to be called when this Node has input focus and a key has been pressed.",
            "Defines a function to be called when this Node has input focus and a key has been released.",
            "Defines a function to be called when this Node has input focus and a key has been typed.",
            "Defines a function to be called when a mouse button has been clicked (pressed and released) on this Node.",
            "Defines a function to be called when a mouse button is pressed on this Node and then dragged.",
            "Defines a function to be called when the mouse enters this Node.",
            "Defines a function to be called when the mouse exits this Node.",
            "Defines a function to be called when mouse cursor moves within this Node but no buttons have been pushed.",
            "Defines a function to be called when a mouse button has been pressed on this Node.",
            "Defines a function to be called when a mouse button has been released on this Node.",
            "Defines a function to be called when the mouse scroll wheel has moved.",
            "Specifies how opaque (that is, solid) the Node appears. Specifies how opaque (that is, solid) the Node appears. A Node with 0% opacity is fully translucent. That is, while it is still visible and rendered, you generally won't be able to see it. The exception to this rule is when the ZNode is combined with a blending mode and blend effect in which case a translucent Node may still have an impact in rendering. An opacity of 50% will render the node as being 50% transparent. A visible node with any opacity setting still receives mouse events and can receive keyboard focus. For example, if you want to have a large invisible rectangle overlay all Nodes in the scene graph in order to intercept mouse events but not be visible to the user, you could create a large Rectangle that had an opacity of 0%. Opacity is specified as a value between 0 and 1. Values less than 0 or greater than 1 are clipped to 0 and 1 respectively. On some platforms ImageView might not support opacity variable.1.0 Profile: common",
            "The parent of this Node. The parent of this Node. If this Node has not been added to a scene graph, then parent will be null.null Profile: common",
            "Defines how the picking computation is done for this node when triggered by a MouseEvent or a contains function call. Defines how the picking computation is done for this node when triggered by a MouseEvent or a contains function call. If pickOnBounds is true, then picking is computed by intersecting with the bounds of this node, else picking is computed by intersecting with the geometric shape of this node.false Profile: common",
            "Whether or not the Node is pressed. Whether or not the Node is pressed. Typically this is true when the primary mouse button is down, though subclasses may define other mouse button state or key state to cause the node to be \"pressed\".false Profile: common",
            "Defines the angle of rotation about the Node's center, measured in degrees. Defines the angle of rotation about the Node's center, measured in degrees. This is used to rotate the Node. This rotation factor is not included in layoutBounds by default, which makes it ideal for rotating the entire node after all effects and transforms have been taken into account. The pivot point about which the rotation occurs is the center of the untransformed layoutBounds. Note that because the pivot point is computed as the center of this Node's layout bounds, any change to the layout bounds will cause the pivot point to change, which can move the object. For a leaf node, any change to the geometry will cause the layout bounds to change. For a group node, any change to any of its children, including a change in a child's geometry, clip, effect, position, orientation, or scale, will cause the group's layout bounds to change. If this movement of the pivot point is not desired, applications should instead use the Node's transforms[] sequence, and add a javafx.scene.transform.Rotate transform, which has a user-specifiable pivot point.0.0 Profile: common",
            "Defines the axis of rotation of this Node. Defines the axis of rotation of this Node. Note: this is a conditional feature. See ConditionalFeature.SCENE3D for more information.Rotate.Z_AXIS Profile: common conditional scene3d",
            "Defines the factor by which coordinates are scaled about the center of the object along the X axis of this Node. Defines the factor by which coordinates are scaled about the center of the object along the X axis of this Node. This is used to stretch or animate the node either manually or by using an animation. This scale factor is not included in layoutBounds by default, which makes it ideal for scaling the entire node after all effects and transforms have been taken into account. The pivot point about which the scale occurs is the center of the untransformed layoutBounds.1.0 Profile: common",
            "Defines the factor by which coordinates are scaled about the center of the object along the Y axis of this Node. Defines the factor by which coordinates are scaled about the center of the object along the Y axis of this Node. This is used to stretch or animate the node either manually or by using an animation. This scale factor is not included in layoutBounds by default, which makes it ideal for scaling the entire node after all effects and transforms have been taken into account. The pivot point about which the scale occurs is the center of the untransformed layoutBounds.1.0 Profile: common",
            "Defines the factor by which coordinates are scaled about the center of the object along the Z axis of this Node. Defines the factor by which coordinates are scaled about the center of the object along the Z axis of this Node. This is used to stretch or animate the node either manually or by using an animation. This scale factor is not included in layoutBounds by default, which makes it ideal for scaling the entire node after all effects and transforms have been taken into account. The pivot point about which the scale occurs is the center of the rectangular bounds formed by taking boundsInLocal and applying all the transforms in the transforms[] sequence. Note: this is a conditional feature. See ConditionalFeature.SCENE3D for more information.1.0 Profile: common conditional scene3d",
            "The Scene that this Node is part of. The Scene that this Node is part of. If the Node is not part of a scene, then this variable will be null.null Profile: common",
            "A string representation of the CSS style associated with this specific Node. A string representation of the CSS style associated with this specific Node. This is analogous to the \"style\" attribute of an HTML element. Note that, like the HTML style attribute, this variable contains style properties and values and not the selector portion of a style rule. Parsing this style might not be supported on some limited platforms. It is recommended to use a standalone CSS file instead.empty string Profile: common",
            "A String identifier which can be used to logically group Nodes, specifically for an external style engine. A String identifier which can be used to logically group Nodes, specifically for an external style engine. This variable is analogous to the \"class\" attribute on an HTML element.empty string Profile: common",
            "Defines the sequence of javafx.scene.transform.Transform objects to be applied to this Node. Defines the sequence of javafx.scene.transform.Transform objects to be applied to this Node. This sequence of transforms is applied before translateX, translateY, scaleX, and scaleY, rotate transforms.empty Profile: common",
            "Defines the x coordinate of the translation that is added to this Node's transform. Defines the x coordinate of the translation that is added to this Node's transform. The node's final translation will be computed as layoutX + translateX, where layoutX establishes the node's stable position and translateX optionally makes dynamic adjustments to that position. This variable can be used to alter the location of a node without disturbing its layoutBounds, which makes it useful for animating a node's location.0 Profile: common",
            "Defines the y coordinate of the translation that is added to this Node's transform. Defines the y coordinate of the translation that is added to this Node's transform. The node's final translation will be computed as layoutY + translateY, where layoutY establishes the node's stable position and translateY optionally makes dynamic adjustments to that position. This variable can be used to alter the location of a node without disturbing its layoutBounds, which makes it useful for animating a node's location.0 Profile: common",
            "Defines the Z coordinate of the translation that is added to the transformed coordinates of this Node. Defines the Z coordinate of the translation that is added to the transformed coordinates of this Node. This value will be added to any translation defined by the transforms sequence and layoutZ. This variable can be used to alter the location of a Node without disturbing its layout bounds, which makes it useful for animating a node's location. Note: this is a conditional feature. See ConditionalFeature.SCENE3D for more information.0 Profile: common conditional scene3d",
            "Specifies whether this Node and any subnodes should be rendered as part of the scene graph. Specifies whether this Node and any subnodes should be rendered as part of the scene graph. A node may be visible and yet not be shown in the rendered scene if, for instance, it is off the screen or obscured by another Node. Invisible nodes never receive mouse events or keyboard focus, and never maintain keyboard focus when they become invisible.true Profile: common"
        ]
    ],
    "pageTitle": "JavaFX 1.3.1 API | javafx.ext.swing.SwingComponent | Java FX",
    "title": "",
    "url": "http://docs.oracle.com/cd/E17802_01/javafx/javafx/1.3/docs/api/javafx.ext.swing/javafx.ext.swing.SwingComponent.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 2,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990114.79/warc/CC-MAIN-20150728002310-00083-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 73623747,
    "recordOffset": 73602141,
    "tableOrientation": "HORIZONTAL",
    "lastModified": "Wed, 09 Jun 2010 15:11:08 GMT",
    "textBeforeTable": "javafx.scene.layout.Resizable Inherited Variables The component's name, which may be null. String name public The foreground color of this component. Color foreground public The font for this component. Font font public description Default Value Can Write Can Init Can Read type name access Variable Summary Profile: desktop conditional swing Base class for all encapsulated Swing components. Overview functions variables overview Jump to Section: Known subclasses: javafx.ext.swing.SwingAbstractButton, javafx.ext.swing.SwingButton,",
    "textAfterTable": "0 Defines the x coordinate of the translation that is added to this Node's transform. Defines the x coordinate of the translation that is added to this Node's transform. The node's final translation will be computed as layoutX + translateX, where layoutX establishes the node's stable position and translateX optionally makes dynamic adjustments to that position. This variable can be used to alter the location of a node without disturbing its layoutBounds, which makes it useful for animating a node's location.0 Profile: common \u00a0 public translateY Number 0 Defines the y coordinate of the translation that is added to this Node's transform. Defines the y coordinate of the translation that is added to this Node's transform. The node's final translation will be computed as layoutY + translateY, where layoutY establishes the node's stable position and translateY optionally makes dynamic adjustments to that position. This variable can be used to alter the location of a node without disturbing its layoutBounds, which makes it useful for animating a node's location.0 Profile: common \u00a0",
    "hasKeyColumn": true,
    "keyColumnIndex": 1,
    "headerRowIndex": 0
}