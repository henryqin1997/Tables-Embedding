{
    "relation": [
        [
            "Function",
            "age(timestamp, timestamp)",
            "age(timestamp)",
            "clock_timestamp()",
            "current_date",
            "current_time",
            "current_timestamp",
            "date_part(text, timestamp)",
            "date_part(text, interval)",
            "date_trunc(text, timestamp)",
            "extract(field from timestamp)",
            "extract(field from interval)",
            "isfinite(timestamp)",
            "isfinite(interval)",
            "justify_days(interval)",
            "justify_hours(interval)",
            "justify_interval(interval)",
            "localtime",
            "localtimestamp",
            "now()",
            "statement_timestamp()",
            "timeofday()",
            "transaction_timestamp()"
        ],
        [
            "Return Type",
            "interval",
            "interval",
            "timestamp with time zone",
            "date",
            "time with time zone",
            "timestamp with time zone",
            "double precision",
            "double precision",
            "timestamp",
            "double precision",
            "double precision",
            "boolean",
            "boolean",
            "interval",
            "interval",
            "interval",
            "time",
            "timestamp",
            "timestamp with time zone",
            "timestamp with time zone",
            "text",
            "timestamp with time zone"
        ],
        [
            "Description",
            "Subtract arguments, producing a \"symbolic\" result that uses years and months",
            "Subtract from current_date",
            "Current date and time (changes during statement execution); see Section 9.9.4",
            "Current date; see Section 9.9.4",
            "Current time of day; see Section 9.9.4",
            "Current date and time (start of current transaction); see Section 9.9.4",
            "Get subfield (equivalent to extract); see Section 9.9.1",
            "Get subfield (equivalent to extract); see Section 9.9.1",
            "Truncate to specified precision; see also Section 9.9.2",
            "Get subfield; see Section 9.9.1",
            "Get subfield; see Section 9.9.1",
            "Test for finite time stamp (not equal to infinity)",
            "Test for finite interval",
            "Adjust interval so 30-day time periods are represented as months",
            "Adjust interval so 24-hour time periods are represented as days",
            "Adjust interval using justify_days and justify_hours, with additional sign adjustments",
            "Current time of day; see Section 9.9.4",
            "Current date and time (start of current transaction); see Section 9.9.4",
            "Current date and time (start of current transaction); see Section 9.9.4",
            "Current date and time (start of current statement); see Section 9.9.4",
            "Current date and time (like clock_timestamp, but as a text string); see Section 9.9.4",
            "Current date and time (start of current transaction); see Section 9.9.4"
        ],
        [
            "Example",
            "age(timestamp '2001-04-10', timestamp '1957-06-13')",
            "age(timestamp '1957-06-13')",
            "",
            "",
            "",
            "",
            "date_part('hour', timestamp '2001-02-16 20:38:40')",
            "date_part('month', interval '2 years 3 months')",
            "date_trunc('hour', timestamp '2001-02-16 20:38:40')",
            "extract(hour from timestamp '2001-02-16 20:38:40')",
            "extract(month from interval '2 years 3 months')",
            "isfinite(timestamp '2001-02-16 21:28:30')",
            "isfinite(interval '4 hours')",
            "justify_days(interval '30 days')",
            "justify_hours(interval '24 hours')",
            "justify_interval(interval '1 mon -1 hour')",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        [
            "Result",
            "43 years 9 mons 27 days",
            "43 years 8 mons 3 days",
            "",
            "",
            "",
            "",
            "20",
            "3",
            "2001-02-16 20:00:00",
            "20",
            "3",
            "true",
            "true",
            "1 month",
            "1 day",
            "29 days 23:00:00",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    ],
    "pageTitle": "PostgreSQL: Documentation: 8.2: Date/Time Functions and Operators",
    "title": "",
    "url": "http://www.postgresql.org/docs/8.2/static/functions-datetime.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 2,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990112.92/warc/CC-MAIN-20150728002310-00118-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 660840016,
    "recordOffset": 660824410,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{19287=The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 to 1. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican., 26661=The number of the week of the year that the day is in. By definition (ISO 8601), the first week of a year contains January 4 of that year. (The ISO-8601 week starts on Monday.) In other words, the first Thursday of a year is in week 1 of that year. (for timestamp values only), 23378=PostgreSQL releases before 8.0 did not follow the conventional numbering of millennia, but just returned the year field divided by 1000., 27047=Because of this, it is possible for early January dates to be part of the 52nd or 53rd week of the previous year. For example, 2005-01-01 is part of the 53rd week of year 2004, and 2006-01-01 is part of the 52nd week of year 2005., 16512=When adding an interval value to (or subtracting an interval value from) a timestamp with time zone value, the days component advances (or decrements) the date of the timestamp with time zone by the indicated number of days. Across daylight saving time changes (with the session time zone set to a time zone that recognizes DST), this means interval '1 day' does not necessarily equal interval '24 hours'. For example, with the session time zone set to CST7CDT, timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' will produce timestamp with time zone '2005-04-03 12:00-06', while adding interval '24 hours' to the same initial timestamp with time zone produces timestamp with time zone '2005-04-03 13:00-06', as there is a change in daylight saving time at 2005-04-03 02:00 in time zone CST7CDT., 21458=For date and timestamp values, the number of seconds since 1970-01-01 00:00:00-00 (can be negative); for interval values, the total number of seconds in the interval, 23267=Years in the 1900s are in the second millennium. The third millennium starts January 1, 2001., 23669=The seconds field, including fractional parts, multiplied by 1000. Note that this includes full seconds.}",
    "textBeforeTable": "Table 9-25. Date/Time Operators All the functions and operators described below that take time or timestamp inputs actually come in two variants: one that takes time with time zone or timestamp with time zone, and one that takes time without time zone or timestamp without time zone. For brevity, these variants are not shown separately. Also, the + and * operators come in commutative pairs (for example both date + integer and integer + date); we show only one of each such pair. Table 9-26 shows the available functions for date/time value processing, with details appearing in the following subsections. Table 9-25 illustrates the behaviors of the basic arithmetic operators (+, *, etc.). For formatting functions, refer to Section 9.8. You should be familiar with the background information on date/time data types from Section 8.5. 9.9. Date/Time Functions and Operators Next Fast Forward Chapter 9. Functions and Operators Fast Backward Prev PostgreSQL 8.2.23 Documentation 8.48.38.2 / /",
    "textAfterTable": "current_date date Current date; see Section 9.9.4 \u00a0 \u00a0 current_time time with time zone Current time of day; see Section 9.9.4 \u00a0 \u00a0 current_timestamp timestamp with time zone Current date and time (start of current transaction); see Section 9.9.4 \u00a0 \u00a0 date_part(text, timestamp) double precision Get subfield (equivalent to extract); see Section 9.9.1 date_part('hour', timestamp '2001-02-16 20:38:40') 20 date_part(text, interval) double precision Get subfield (equivalent to extract); see Section 9.9.1 date_part('month', interval '2 years 3 months') 3 date_trunc(text, timestamp) timestamp Truncate to specified precision; see also Section 9.9.2 date_trunc('hour', timestamp '2001-02-16 20:38:40') 2001-02-16 20:00:00 extract(field from timestamp) double precision Get subfield; see Section 9.9.1 extract(hour from timestamp '2001-02-16 20:38:40') 20 extract(field from interval) double precision Get subfield; see Section 9.9.1 extract(month from interval '2 years 3 months') 3 isfinite(timestamp) boolean Test for finite time stamp (not equal to infinity) isfinite(timestamp '2001-02-16 21:28:30') true isfinite(interval) boolean Test for finite interval isfinite(interval '4 hours') true justify_days(interval) interval Adjust interval so 30-day time",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}