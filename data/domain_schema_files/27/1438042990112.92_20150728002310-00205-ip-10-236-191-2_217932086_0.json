{
    "relation": [
        [
            "Module",
            "USB Plug",
            "USB Plug",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino",
            "Arduino"
        ],
        [
            "Pin",
            "GND",
            "+5v",
            "GND",
            "VCC (+3.3v)",
            "10",
            "11",
            "12",
            "13",
            "GND",
            "RAW (+5v)",
            "3",
            "GND",
            "RAW (+5v)",
            "4"
        ],
        [
            "\u2194",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        [
            "Module",
            "Arduino",
            "Arduino",
            "CC2500",
            "CC2500",
            "CC2500",
            "CC2500",
            "CC2500",
            "CC2500",
            "LED",
            "LED",
            "LED",
            "Ping",
            "Ping",
            "Ping"
        ],
        [
            "Pin",
            "GND",
            "RAW",
            "GND",
            "VCC",
            "CSN (SS)",
            "SI (MOSI)",
            "SO (MISO)",
            "SCK",
            "GND",
            "VCC",
            "RX",
            "GND",
            "5V",
            "SIG"
        ]
    ],
    "pageTitle": "Hacking My Vagina : scanlime",
    "title": "",
    "url": "http://scanlime.org/2012/11/hacking-my-vagina/",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 0,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990112.92/warc/CC-MAIN-20150728002310-00205-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 217955951,
    "recordOffset": 217932086,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{20501=At this point, I had enough information about the protocol to try and build my own emulation of the original remote. This was before I had ordered any CC2500 breakout boards, so I used the remote itself as a dumb CC2500 radio by holding the original MSP430 microcontroller in reset. This was the setup I used to develop an Arduino library that could configure the CC2500 radio correctly and send packets like the ones above., 10224=The CC2500 is a really nice configurable 2.4 GHz radio and modem chip with an SPI interface. It\u2019s part of a line of highly integrated radios made by Chipcon, now owned by Texas Instruments. They\u2019re quite similar to the competing nRF24L01 radio made by Nordic Semiconductor. The CC2500 also has a popular sub-1 GHz sibling, the CC1100. This chip was featured in the ToorCon 14 badge, and the imminently hackable IM-ME toy., 19576=Each packet contains a motor strength update, as an 8-bit number which seems to have a usable range of 0 through 128. The packets themselves always have 9 bytes of payload provided by the microcontroller, plus a CRC and header which is generated by the CC2500 itself. Here\u2019s the payload of a typical packet:, 24630=This lists the exact parts I used in my prototype, but nearly everything here is commonly available from multiple manufacturers. In particular, many different vendors on eBay usually carry CC2500 breakout boards. Some of these have special features such as nicer antennas or power amplifiers. Keep an eye out for those., 21547=At this point, the project was seeming pretty straightforward: Off-the-shelf Arduino, CC2500 breakout board, sonar sensor, and LED display. But how would I power all of this? The sonar and LEDs are both pretty power-hungry, and I would be using the radio much more heavily than the original remote. I would need to budget nearly 100 mA, with 5v rails for the sonar and LED and 3.3v for the radio and Arduino., 56541=Copyright \u00a9 2014 M. Elizabeth Scott \u00b7 RSS Feed \u00b7 Log in, 9533=In order to replace the original remote control, first I had to understand it. My first stop was the FCC ID database, to see if they had any info that would help me know if it was even worthwhile to crack the remote open. I was in luck. The internal photos clearly showed an MSP430 microcontroller and CC2500 radio. Hackability was looking good so far., 1981=Posted by Micah on Saturday, November 24, 2012 \u00b7 Leave a Comment\u00a0, 41840=Filed under Sex Toys \u00b7 Tagged with arduino, cc2500, microcontroller, mini-project, reverse engineering, sonar, toys, wireless, 10997=I wouldn\u2019t even bother with trying to read or reprogram the original microcontroller. By sniffing this SPI bus, I could reverse engineer the proper radio settings and protocol to use. Then I could wire up any CC2500 to any microcontroller I want, and control the vibrator over the air.}",
    "lastModified": "Sat, 04 Oct 2014 20:29:57 GMT",
    "textBeforeTable": "After the epoxy set, I soldered everything up point-to-point style with wire-wrapping wire: Since these components are largely held in place by the shape of the enclosure, they only need a small amount of epoxy to keep them from sliding out of their holes. Note that the underside of the sonar module is exposed to the battery compartment. Make sure you go easy on the epoxy. Any blobby epoxy or messy wiring could get in the way of the battery pack. The top half assembles in a similar manner. The sonar and LED modules both press into their respective slots. When they\u2019re all the way in, the front face of the LED module and the front of each sonar transducer should be approximately flush with the front of the enclosure. I used the battery pack itself to help line up the USB connector while the epoxy sets. You\u2019ll notice a little bit of wiggle when the connectors are mated. To make sure the battery pack plugs and unplugs smoothly, make sure that you seat the USB plug such that it\u2019s pressed all the way to the back of the socket. This will ensure the plug isn\u2019t stuck at a funny angle. It\u2019s probably a good idea to avoid getting any epoxy on the RF components on the front side of the radio, as it may",
    "textAfterTable": "There will be six wires running between the top and bottom half. It\u2019s okay to leave these a little bit long; there will be room to fold them up in the hollow space above the LED module. Firmware Time Bolt the enclosure together, making sure the wires end up in the hollow area instead of pinched in the edges of the controller. Now it\u2019s ready for some firmware! The Arduino sketch is in the project\u2019s GitHub repository. I designed the enclosure to work with common 3.3v FTDI cables. The programming slot is probably a bit too narrow for the FTDI Basic, but perhaps it works. I already had a Prop Plug handy, so I\u2019ve been using that with a simple passive adaptor. The firmware is currently pretty basic. It takes sonar measurements as fast as it can, feeding those into a median filter. Median filters are a little bit magical when it comes to discarding outliers from noisy-ish data. There\u2019s a smidgen of state machinery to manage the \u201clock\u201d mode. Finally, it scales the distance reading to a motor power level and sends packets to the radio and LED modules about 80 times a second. The Next Thing Where to go from here? Well, there is certainly room for",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}