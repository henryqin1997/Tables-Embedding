{
    "relation": [
        [
            "Property",
            "eclipselink.cache.coordination.protocol",
            "eclipselink.cache.coordination.channel",
            "eclipselink.cache.coordination.propagate-asynchronously",
            "eclipselink.cache.coordination.thread.pool.size",
            "eclipselink.cache.coordination.remove-connection-on-error",
            "eclipselink.cache.coordination.naming-service",
            "eclipselink.cache.coordination.jndi.user",
            "eclipselink.cache.coordination.jndi.password",
            "eclipselink.cache.coordination.rmi.url",
            "eclipselink.cache.coordination.rmi.multicast-group",
            "eclipselink.cache.coordination.rmi.multicast-group.port",
            "eclipselink.cache.coordination.rmi.announcement-delay",
            "eclipselink.cache.coordination.rmi.packet-time-to-live",
            "eclipselink.cache.coordination.jms.topic",
            "eclipselink.cache.coordination.jms.factory",
            "eclipselink.cache.coordination.jms.host",
            "eclipselink.cache.coordination.jms.reuse-topic-publisher"
        ],
        [
            "Description",
            "Enable cache coordination using the communication protocol: rmi - Use Java RMI to broadcast changes. rmi-iiop - Use Java RMI over CORBA IIOP to broadcast changes. jms - Use the Java Messaging Service to broadcast changes. jms-publishing - Allows an EJB MessageDrivenBean to be used to broadcast changes. The MDB must be configured separately. - The fully qualified class name of a custom implementation of a TransportManager.",
            "Sets the channel for cache coordination. All persistence units using the same channel will be coordinated.",
            "Configures if changes are broadcast using a separate thread. If set to false the transaction will wait for all servers to be notified before returning. Note that JMS is always asynchronous.",
            "Configures thread pool size for cache coordination threads. RMI cache coordination will spawn one thread per node to send change notifications. RMI also spawns a thread to listen for new node notifications. JMS cache coordination will spawn one thread to receive JMS change notification messages (unless an MDB is used). JMS also spawns a thread to process the change notification (unless an MDB is used). A size of 0 indicates no thread pool should be used, and threads will be spawned when required.",
            "Set if a connection should be removed if a communication error occurs when coordinating with it. This is normally used for RMI coordination in case a server goes down (it will reconnect when it comes back up).",
            "Set the naming service to use to look-up and register the RMI cache coordination service, either: jndi - The server's Java Naming and Directory Interface is used. If the server's JNDI is replicated in an application server cluster, then the rmi.url option is not required. rmi - The RMI registry is used. This can be used if JNDI is not available, or the JNDI implementation does not support RMI objects.",
            "Set the application server user name to connect to JNDI with. This is only required if JNDI requires authentication.",
            "Set the application server user password to connect to JNDI with. This is only required if JNDI requires authentication. This is normally not required if connecting to a local service.",
            "Only required by RMI cache coordination. Sets the URL of the host server. This is the URL that other cluster members should use to connect to this host. This may not be required in a clustered environment where JNDI is replicated. This can also be set as a System property or using a SessionCustomizer to avoid a separate persistence.xml per server.",
            "Only used for RMI coordination. Sets the multicast socket group address. The multicast group is used to find other members of the cluster.",
            "Only used for RMI coordination. Sets the multicast socket group port. The multicast group is used to find other members of the cluster.",
            "Only used for RMI coordination. Sets the number of milliseconds to wait for announcements from other cluster members on start-up.",
            "Only used for RMI coordination. Sets the multicast socket packet time to live. The multicast group is used to find other members of the cluster. Set the number of hops the data packets of the session announcement will take before expiring. The default is 2, a hub and an interface card to prevent the data packets from leaving the local network. Note that if sessions are hosted on different LANs that are part of WAN, the announcement sending by one session may not reach other sessions. In this case, consult your network administrator for the right time-to-live value or test your network by increase the value until sessions receive announcement sent by others.",
            "Only used for JMS coordination. Sets the JMS topic name. All persistence units sharing the same JMS topic from the same JMS service will be coordinated.",
            "Only used for JMS coordination. Sets the JMS topic connection factory JNDI look-up name. If the server's JNDI is replicated in an application server cluster, then the jms.host option is not required.",
            "Only used for JMS coordination. Sets the URL for the JMS server hosting the topic. This may not be required in a clustered environment where JNDI is replicated.",
            "Only used for JMS coordination. Sets the JSM transport manager to cache a TopicPubliser and reuse it for all cache coordination publishing. Caching the publisher is supported by some JMS implementations, and may improve efficiency."
        ],
        [
            "Default",
            "no coordination",
            "EclipseLinkCommandChannel",
            "true",
            "32",
            "true",
            "jndi",
            "no authentication",
            "no authentication",
            "local",
            "239.192.0.0",
            "3121",
            "1000",
            "2",
            "jms/EclipseLinkTopic",
            "jms/EclipseLinkTopicConnectionFactory",
            "local",
            "false"
        ],
        [
            "Required?",
            "Required",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional",
            "Optional"
        ]
    ],
    "pageTitle": "Difference between revisions of \"EclipseLink/UserGuide/JPA/Basic JPA Development/Caching/Coordination\" - Eclipsepedia",
    "title": "Cache Coordination Persistence Unit Properties",
    "url": "http://wiki.eclipse.org/index.php?title=EclipseLink/UserGuide/JPA/Basic_JPA_Development/Caching/Coordination&diff=303778&oldid=206576",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 2,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988310.3/warc/CC-MAIN-20150728002308-00099-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 256401575,
    "recordOffset": 256380068,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{133026=Copyright \u00a9 2014 The Eclipse Foundation. All Rights Reserved.}",
    "textBeforeTable": "Cache coordination is configured using persistence unit properties. The following cache coordination properties are supported: Configuring Cache Coordination Cache coordination greatly reduces to chance of an application getting stale data, but does not eliminate the possibility. Optimistic locking should still be used to ensure data integrity. Even in a single server application stale data is still possible within a persistence context unless pessimistic locking is used. Optimistic (or pessimistic) locking is always required to ensure data integrity in any multi-user system. Cache coordination works by broadcasting changes for each transaction to the other servers in the cluster. Each other server will receive the change notification, and either invalidate the changed objects in their cache, or update the cached objects state with the changes. Cache coordination occurs after the database commit, so only committed changes are broadcast. Cache coordination enables a set of persistence units deployed to different servers in the cluster (or on the same server) to synchronize their changes. Cache coordination works by each persistence unit on each server in the cluster being able to broadcast notification of transactional object changes to the other persistence units in the cluster. EclipseLink supports cache coordination over RMI and JMS. The cache coordination framework is also extensible so other options could be developed. Use database events to invalidate changed data in the cache (such as EclipseLink's support for Oracle DCN/QCN). Use a distributed cache (such as Oracle TopLink Grid's integration of EclipseLink",
    "textAfterTable": "EclipseLink persistence.xml cache coordination RMI example <?xml version=\"1.0\" encoding=\"UTF-8\"?> <persistence xmlns=\"http://java.sun.com/xml/ns/persistence\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence persistence_2_0.xsd\"  version=\"2.0\"> <persistence-unit name=\"acme\" transaction-type=\"RESOURCE_LOCAL\"> <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider> <exclude-unlisted-classes>false</exclude-unlisted-classes> <properties> <property name=\"eclipselink.cache.coordination.protocol\" value=\"rmi\"/> </properties> </persistence-unit> </persistence> EclipseLink persistence.xml cache coordination JMS example <?xml version=\"1.0\" encoding=\"UTF-8\"?> <persistence xmlns=\"http://java.sun.com/xml/ns/persistence\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence persistence_2_0.xsd\"  version=\"2.0\"> <persistence-unit name=\"acme\" transaction-type=\"RESOURCE_LOCAL\"> <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider> <exclude-unlisted-classes>false</exclude-unlisted-classes> <properties> <property name=\"eclipselink.cache.coordination.protocol\" value=\"jms\"/> <property name=\"eclipselink.cache.coordination.jms.topic\" value=\"jms/ACMETopic\"/> <property name=\"eclipselink.cache.coordination.jms.factory\" value=\"jms/ACMETopicConnectionFactory\"/> </properties> </persistence-unit> </persistence> Cache Coordination and Oracle WebLogic Both RMI and JMS cache coordination work with Oracle WebLogic. When a WebLogic cluster is used JNDI is",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}