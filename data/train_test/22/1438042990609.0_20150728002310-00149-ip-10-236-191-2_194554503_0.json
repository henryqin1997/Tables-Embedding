{
    "relation": [
        [
            "Prototype",
            "void *pemalloc(size_t size, zend_bool persistent)",
            "void *pecalloc(size_t nmemb, size_t size, zend_bool persistent)",
            "void *perealloc(void *ptr, size_t size, zend_bool persistent)",
            "void pefree(void *ptr, zend_bool persistent)",
            "void *safe_pemalloc(size_t nmemb, size_t size, size_t offset, zend_bool persistent)",
            "char *pestrdup(const char *s, zend_bool persistent)",
            "char *pestrndup(const char *s, unsigned int length, zend_bool persistent)"
        ],
        [
            "Description",
            "Allocate size bytes of memory.",
            "Allocate a buffer for nmemb elements of size bytes and makes sure it is initialized with zeros.",
            "Resize the buffer ptr, which was allocated using emalloc to hold size bytes of memory.",
            "Free the buffer pointed by ptr. The buffer had to be allocated by pemalloc.",
            "Allocate a buffer for holding nmemb blocks of each size bytes and an additional offset bytes. This is similar to pemalloc(nmemb * size + offset) but adds a special protection against overflows.",
            "Allocate a buffer that can hold the NULL-terminated string s and copy the s into that buffer.",
            "Similar to pestrdup while the length of the NULL-terminated string is already known."
        ]
    ],
    "pageTitle": "PHP: Data persistence - Manual",
    "title": "Persistent memory APIs",
    "url": "http://php.net/manual/pt_BR/internals2.memory.persistence.php",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 0,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990609.0/warc/CC-MAIN-20150728002310-00149-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 194562705,
    "recordOffset": 194554503,
    "tableOrientation": "HORIZONTAL",
    "lastModified": "Tue, 04 Aug 2015 04:10:13 GMT",
    "textBeforeTable": "Nota: All of the following functions take the additional persistent parameter, should this be false, the engine will use its regular allocators (emalloc) and the memory should not be considered persistent. Where memory is allocated as persistent, system allocators are invoked, under most circumstances they are still not able to return NULL pointers just as the Main memory APIs. A common use of persistent memory is to enable persistent SQL server connections, though this practice is frowned upon, it is none the less the most common use of this feature. In this context, data persistence is taken to mean any data that is intended to survive the current request. The memory management within the engine is very focused on request bound allocations, but this is not always practical or appropriate. Persistent memory is sometimes required in order to satisfy requirements of external libraries, it can also be useful while Hacking. Data persistence Report a Bug Edit English Brazilian Portuguese Chinese (Simplified) French German Japanese Korean Romanian Russian Spanish Turkish Other Change language: Memory management PHP no N\u00facleo: Um guia do Hacker para a",
    "textAfterTable": "Cuidado It is important to remember that memory allocated to be persistent is not optimized or tracked by the engine; it is not subject to memory_limit, additionally, all variables that are created by the Hacker for the engine must not use persistent memory. add a note User Contributed Notes There are no user contributed notes for this page. Memory management Basic memory management Data persistence Thread-\u200bSafe Resource Manager Copyright \u00a9 2001-2015 The PHP Group My PHP.net Contact Other PHP.net sites Mirror sites Privacy policy",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}