{
    "relation": [
        [
            "Device",
            "Logitech (M-BJ58/M-BJ69) Optical Wheel Mouse",
            "Logitech Internet Keyboard",
            "FTDI FT232 USB-Serial (on Arduino)",
            "CSR Bluetooth Dongle",
            "Imation 4GB Flash Drive",
            "AVerMedia Volar DVB-T dongle",
            "Logitech, Inc. QuickCam Messanger (sic)",
            "Logitech, Inc. Premium Stereo USB Headset 350",
            "FPGA4U, without firmware (Cypress Semiconductor Corp. CY7C68013 EZ-USB FX2 USB 2.0 Development Kit)",
            "FPGA4U, with firmware (Altera compatible)"
        ],
        [
            "USB ID",
            "046d:c00e/046d:c018",
            "046d:c309",
            "0403:6001",
            "0a12:0001",
            "0718:0348",
            "07ca:b808",
            "046d:08da",
            "046d:0a02",
            "04b4:8613",
            "09fb:6001"
        ],
        [
            "Speed",
            "LS",
            "LS",
            "FS",
            "FS",
            "HS",
            "HS",
            "FS",
            "FS",
            "HS",
            "HS"
        ],
        [
            "Endpoints & types",
            "EP1 IN, interrupt",
            "EP1 IN, interrupt (keyboard itself) EP2 IN, interrupt (wheel on the side, like a mouse)",
            "EP1 IN, bulk (Arduino->host) EP2 OUT, bulk (host->Arduino)",
            "EP1 IN, interrupt EP2 IN, bulk EP2 OUT, bulk EP3 IN, iso EP3 OUT, iso",
            "EP1 OUT, bulk EP2 IN, bulk EP3 IN, interrupt",
            "EP1 OUT, bulk EP1 IN, bulk EP2 IN, bulk EP3 IN, bulk",
            "EP1 IN, isochronous (video) EP2 IN, interrupt (button status) EP3 IN, isochronous (audio)",
            "EP1 OUT, isochronous (audio stereo output, max 192 bytes per packet) EP3 IN, interrupt (button status) EP4 IN, isochronous (audio input, 96 bytes per packet)",
            "Many, for testing (only control is used for firmware loading)",
            "EP1 IN, bulk (JTAG emulation) EP2 OUT, bulk (JTAG emulation)"
        ],
        [
            "Status",
            "OK",
            "OK",
            "OK",
            "OK",
            "OK",
            "OK",
            "OK (audio+video at the same time doesn't work)",
            "OK",
            "OK",
            "OK"
        ],
        [
            "Branch",
            ">=stable-20100618",
            "stable-20100618",
            ">=stable-20100618",
            ">=stable-20100618",
            ">=stable-20100702",
            ">=stable-20100618",
            ">stable-20100717",
            ">stable-20100717",
            "TBA",
            "TBA (latest stable has a problem with that)"
        ],
        [
            "Notes",
            "",
            "",
            "Programming + bidirectional serial communication",
            "Scanning devices (hcitool -i hci1 scan), and file transfers (odp and ussp-push) work. Didn't check anything that would use isochronous endpoints.",
            "Works hdparm -t --direct /dev/sdX. On PC: 19.76 MB/sec; on BeagleBoard: 17.64 MB/sec; on PC through the BeagleBoard proxy: 19.18 MB/sec.",
            "No visible problem.",
            "No visible problem (video 640x480 OR audio). Needs musb_hdrc parameter fifo_mode=6. The FIFO mode is required, because EP1 needs 768 bytes per packet (and the default is only 512). The DMA has been fixed to handle ISO packets properly. Enabling both video + audio at the same time doesn't work (bandwidth allocation problem, but this is probably an USB hub problem).",
            "aplay -D default:CARD=Headset - works). Needs musb_hdrc parameter fifo_mode=7. The FIFO mode is required, because EP4 needs 96 bytes per packet (and the default is only 32).",
            "Firmware loading using fxload works. The device then resets, and appears as a new device on the BeagleBoard. Restarting sniff claims the new device.",
            "nios2-terminal works."
        ]
    ],
    "pageTitle": "BeagleBoard/GSoC/2010 Projects/USBSniffer - eLinux.org",
    "title": "",
    "url": "http://elinux.org/index.php?title=BeagleBoard/GSoC/2010_Projects/USBSniffer&oldid=22607",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 0,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042989331.34/warc/CC-MAIN-20150728002309-00321-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 78286739,
    "recordOffset": 78271328,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{3605=Google Summer of Code 2010 Project}",
    "textBeforeTable": "Tested devices Use the device, it should work. Run ./load: this will (re)load the g_proxy driver. Run ./unbind: This will unbind the device from the normal Linux driver. Plug your PC to the BeagleBoard USB slave port (this can be done earlier as well). Plug your device (through a USB hub if it is a low/full-speed device). Run ./setup on the BeagleBoard, this will unload the g_ether gadget driver. or the manual way (mostly for testing purpose, as it does not log packets): Use the device, it should work, and packets are captured. Run ./sniff, and follow the instructions. Data transfers will be logged to /media/ram/dump. This resulting file can be displayed using wireshark. Plug your device (through a USB hub if it is a low/full-speed device). Then, you have 2 options, the automatic way: Copy the content of the arm directory to the BeagleBoard git checkout origin/stable-20100730 -b stable-20100730 cd helper-scripts/ git clone git://gitorious.org/beagleboard-usbsniffer/helper-scripts.git Clone the helper scripts git tree, branch stable-20100730 [4]: Copy these on the BeagleBoard, and run opkg install name.ipk for both packages. The 2 packages can be found in $OE_BASE/build/tmp-angstrom_2008_1/deploy/glibc/ipk/armv7a: libpcap_1.1.1-r1.5_armv7a.ipk and tcpdump_4.1.1-r1.5_armv7a.ipk. Build libpcap and tcpdump, this can be done with a command like bitbake libpcap tcpdump provided you have the environment set properly (i.e., source ~/.oe/environment or",
    "textAfterTable": "MUSB testing code Some instructions on how to use the code to trigger the MUSB bug with short isochronous packets: Checkout [5]. There are 2 directories: host, and device. For the device side (on the beagleboard), you need to cross-compile usbtest. You need libaio, which can be built using Angstrom, and gadgetfs in the Linux kernel. Then, the gadgetfs driver is loaded as follows: modprobe gadgetfs mkdir /dev/gadget/ -p mount -t gadgetfs none /dev/gadget ./usbtest -v -s 512 -p 2 -a 1 -I0 -x 18 The host code must be run on your host PC. It requires the usbtest module (CONFIG_USB_TEST=m), then isochronous IN transfers are tested with the following command: ./testusb -a -t 16 -g 1 -c 10 While running the test, you can monitor the USB traffic using usbmon, you should see isochronous packets of length 18, i.e., something like this: ... S Zi:2:100:1 -115:8:5232 1 -18:0:512 512 < ... C Zi:2:100:1 0:8:5240:0 1 0:0:18 18 = e6010203 e6050607 e6090a0b e60d0e0f e611 Every 4 bytes contains some kind of packet id (incrementing), the rest of the bytes are given by a mod 63 counter. Bulk transfers can also be tested, with the following commands (device and host): ./usbtest -a 5 -s 514 ./testusb -a -t 4 -c 10 -s 1024 testusb will complain, since the packet is short (514 instead of 1024), but usbmon still shows that the transfer has",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}