{
    "relation": [
        [
            "Hash Table",
            "",
            "TCP established",
            "TCP bind",
            "IP route cache",
            "Inode-cache",
            "Dentry cache",
            "Total"
        ],
        [
            "memory < 512MiB RAM",
            "32b/64b",
            "96k/192k",
            "64k/128k",
            "128k/256k",
            "64k/128k",
            "32k/64k",
            "384k/768k"
        ],
        [
            "memory >=512MiB RAM",
            "32b/64b",
            "384k/768k",
            "256k/512k",
            "512k/1M",
            "64k/128k",
            "32k/64k",
            "1248k/2496k"
        ]
    ],
    "pageTitle": "System Size - eLinux.org",
    "title": "",
    "url": "http://www.elinux.org/index.php?title=System_Size&oldid=238520",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 0,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990217.27/warc/CC-MAIN-20150728002310-00340-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 439226227,
    "recordOffset": 439208485,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{15506=In 2012, Tim Bird studied a few different techniques related to automatic size reduction and whole-system optimization. Specifically, he studied the following items:, 23125=It is possible to reduce the RAM runtime footprint for a product, by lazily loading shared libraries, and by breaking up library dependencies. Panasonic did some research into a process called Deferred Library Loading, which they presented at ELC 2007., 15867=Tim also found some very interesting academic research on link-time re-writing and cold-code compression. Tim's work will be presented at LinuxCon Japan in May, 2013. He is working on his outline for the talk at: System Size Auto-Reduction, 30411=Catalin Marinas of ARM has been recently (as of 2.6.17?) been posting a memory leak detector for the Linux kernel. It may get mainlined in the future. Here's a link to the LKML discussions around it: http://lkml.org/lkml/2006/6/11/39}",
    "textBeforeTable": "Here is a table showing different kernel hash tables, and their approximate size for a 2.6 kernel. (Table taken from page 25 of http://logfs.org/~joern/data_structures.pdf ) Often, the focus of memory size reduction for the kernel is on the size of the statically compiled image for the kernel. However, the kernel also allocates memory dynamically when it runs. On loading, the kernel creates several tables for things like network and file system structures. Runtime size of kernel These patches can shrink kernel size by ~10% by improving dead code/data elimination at link time. They are being pushed to mainline. Due to a linker bug, their acceptance depends on a newer, fixed linker (will be in binutils-2.21). Good news are that the bug affects only certain architectures (parisc), so the patches are usable even with \"old\" linker. Section garbage collection patchset See [1] for all available optimization switches. See Compiler_Optimization for more details on effects of optimization options. Another option, -mregparm=3, seems to be x86 specific, it instructs the compiler to use registers for the first three function arguments. by John Rigby The -fwhole-program --combine option set is equivalent to grouping all source files and making all variables static. These options are still supported by gcc, but not longer offered in BusyBox configuration options. What happened? Since version 3.4, gcc offered a -funit-at-a-time",
    "textAfterTable": "kernel stack size There used to be a configuration option for reducing the size of the kernel stack for each process to 4K. By default (as of 2011), the default kernel stack size is 8K. If you have a lot of processes, then using 4K stacks can reduce the kernel stack usage. Some notes about this are at: Kernel Small Stacks Auto-reduction In 2012, Tim Bird studied a few different techniques related to automatic size reduction and whole-system optimization. Specifically, he studied the following items: link-time optimization of the kernel syscall elimination global constraints kernel stack reduction Tim also found some very interesting academic research on link-time re-writing and cold-code compression. Tim's work will be presented at LinuxCon Japan in May, 2013. He is working on his outline for the talk at: System Size Auto-Reduction File system compression For read-only data, it is useful to utilize a compressed file system. The following are used heavily in embedded systems: Cramfs and SquashFS, for block storage. JFFS2 and its successor UBIFS, for flash (MTD) storage. Note that Cramfs and Squashfs, due to their \"write-only-once\" nature, can also be used on MTD storage. See the File Systems page for more information. Shrinking your application Compiler options for program size You",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}