{
    "relation": [
        [
            "Method",
            "public CustomType(String str)",
            "public static CustomType CustomType.fromString(String str)",
            "public static CustomType CustomType.fromString(String str, StoreContext ctx)",
            "public static CustomType AnyClass.fromString(String str)",
            "public static CustomType AnyClass.fromString(String str, StoreContext ctx)"
        ],
        [
            "Extension",
            "none",
            "JPA: @Factory(\"fromString\") JDO:",
            "JPA: @Factory(\"fromString\") JDO:",
            "JPA: @Factory(\"AnyClass.fromString\") JDO:",
            "JPA: @Factory(\"AnyClass.fromString\") JDO:"
        ]
    ],
    "pageTitle": "5.5.\u00a0Persistent Fields",
    "title": "",
    "url": "http://docs.oracle.com/cd/E28280_01/apirefs.1111/e13946/ref_guide_pc_scos.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 4,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990112.50/warc/CC-MAIN-20150728002310-00215-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 78620871,
    "recordOffset": 78604925,
    "tableOrientation": "HORIZONTAL",
    "lastModified": "Thu, 28 Feb 2013 08:03:48 GMT",
    "textBeforeTable": "Table\u00a05.2.\u00a0Factory Options Given a field of type CustomType that externalizes to a string, the table below demonstrates several possible factory methods and their corresponding metadata extensions. The JPA org.apache.openjpa.persistence.Factory annotation or JDO factory metadata extension contains the name of a method that will be invoked to instantiate the field from the external form stored in the database. Specify a static method name. The method will will be invoked with the externalized value and must return an instance of the field type. The method can also take an optional StoreContext parameter for access to a persistence context. If a factory is not specified, Kodo will use the constructor of the field type that takes a single argument of the external type, or will throw an exception if no constructor with that signature exists. JPA: @Externalizer(\"AnyClass.toString\") JDO: <extension vendor-name=\"kodo\" key=\"externalizer\" value=\"AnyClass.toString\"/> public static String AnyClass.toString(CustomType ct, StoreContext ctx) JPA: @Externalizer(\"AnyClass.toString\") JDO: <extension vendor-name=\"kodo\" key=\"externalizer\" value=\"AnyClass.toString\"/> public static String AnyClass.toString(CustomType ct) JPA: @Externalizer(\"toString\") JDO: <extension vendor-name=\"kodo\" key=\"externalizer\" value=\"toString\"/> public String CustomType.toString(StoreContext ctx) JPA:",
    "textAfterTable": "If your externalized field is not a standard persistent type, you must explicitly mark it persistent. In JPA, you can force a persistent field by annotating it with org.apache.openjpa.persistence.Persistent annotation. In JDO, set the field's persistence-modifier to true. If you want the field to be in the default fetch group, also set its default-fetch-group metadata attribute to true. See Chapter\u00a05, Metadata for complete coverage of JDO metadata. Note If your custom field type is mutable and is not a standard collection, map, or date class, Kodo will not be able to detect changes to the field. You must mark the field dirty manully, or create a custom field proxy. See OpenJPAEntityManager.dirty for how to mark a field dirty manually in JPA. See JDOHelper.makeDirty for how to mark a field dirty in JDO. See Section\u00a05.5.4, \u201cProxies\u201d for a discussion of proxies. You can externalize a field to virtually any value that is supported by Kodo's field mappings (embedded relations are the exception; you must declare your field to be a persistence-capable type in order to embed it). This means that a field can externalize",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}