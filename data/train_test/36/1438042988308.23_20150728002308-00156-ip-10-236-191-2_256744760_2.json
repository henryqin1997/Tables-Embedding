{
    "relation": [
        [
            "Task",
            "Create new object without children",
            "Create new object without children",
            "Create new child object for existing parent: unidirectional relationship",
            "Create new child object for existing parent: unidirectional relationship",
            "Create new child object for existing parent: bidirectional relationship",
            "Create new child object for existing parent: bidirectional relationship",
            "Modify existing object known to exist in the database.",
            "Modify a Collection of objects"
        ],
        [
            "UnitOfWork Method",
            "registerObject",
            "registerNewObject",
            "Parent: registerObjectChild: no registration necessary",
            "Parent: registerObjectChild: registerObject",
            "Parent: registerObjectChild: no registration necessary",
            "Parent: registerObjectChild: registerNewObject",
            "registerExistingObject",
            "registerObjects"
        ],
        [
            "Result",
            "New object is reference to cache object after commit.",
            "New object is reference to cache object after commit.Performance enhancement: no clone created.",
            "EclipseLink cascades registration to all new child objects reachable from the registered object: no need to register new child objects.",
            "New object is reference to cache object after commit.",
            "EclipseLink cascades registration to all new child objects reachable from the registered object: no need to register new child objects.",
            "New object can be queried prior to commit (without using conforming query).Calling registerObject on child is an error.",
            "Performance enhancement: no call to Descriptor method doesExist.",
            "Convenience method: equivalent to calling registerObject for each object in the Collection."
        ]
    ],
    "pageTitle": "Difference between revisions of \"Using Advanced Unit of Work API (ELUG)\" - Eclipsepedia",
    "title": "",
    "url": "http://wiki.eclipse.org/index.php?title=Using_Advanced_Unit_of_Work_API_(ELUG)&diff=67875&oldid=67874",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 2,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988308.23/warc/CC-MAIN-20150728002308-00156-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 256784671,
    "recordOffset": 256744760,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{120369=This method always goes to the database for the initial read operation of an object whose descriptor is configured as isolated. By avoiding the shared session cache, you do not need to use the more complicated descriptor and query APIs to disable cache hits or always refresh. For more information about isolated client sessions, see Isolated Client Sessions. This is particularly useful for achieving serializable transaction isolation (see #What You May Need to Know About Serializable Read Levels, 143794=Copyright \u00a9 2014 The Eclipse Foundation. All Rights Reserved.}",
    "textBeforeTable": "UnitOfWork Object Registration API This table summarizes the UnitOfWork object registration methods. What You May Need to Know About Object Registration In general, this method is rarely used. It can be useful if you create a new object, but then decide to delete it in the same unit of work (which is not recommended). The unit of work unregisterObject method lets you unregister a previously registered object from a unit of work. An unregistered object will be ignored in the unit of work, and any uncommitted changes made to the object up to that point will be discarded. How to Unregister Working Clones For more information about aggregate objects, see Creating Relational Aggregate Descriptors. If you get an aggregate from a cache version owner, then the aggregate is the cache version. If you get an aggregate from a working clone owner, then the aggregate is a working clone. When working with aggregates, you should always use an aggregate within the context of its owner: Aggregate mapped objects should never be registered in a EclipseLink unit of work\u2013doing so will generate an exception. Aggregate cloning and registration is automatic based on the owner of the aggregate object. In other words, if you register the owner of an aggregate, the aggregate is automatically cloned. When you get a working copy of an aggregate owner,",
    "textAfterTable": "If a new object is reachable from a clone, you do not need to register it. When working with new objects, remember the following: Only reachable or registered objects will be persisted. Reachable new objects or objects that have been registered with registerNewObject are considered to be working copies in the unit of work. If you call registerObject with a new object, the clone the method returns, and the argument you pass in, are considered the cache version. The registerNewObject method registers a new object as if it was a clone. At commit time, the unit of work creates another instance of the object to be the cache version of that object. Use the registerNewObject method in situations where the following applies: You do not need a handle to the cache version of the object after the commit transaction and you do not want to work with clones of new objects. You must pass a clone into the constructor of a new object, then register the new object. Note that if you call registerNewObject on an object, EclipseLink does not cascade registration to new children of that object. Children will be persisted but you cannot query them before commit (unless you use conforming queries). To make children visible to queries before commit, you must do one of the following: register the parent using registerObject",
    "hasKeyColumn": true,
    "keyColumnIndex": 1,
    "headerRowIndex": 0
}