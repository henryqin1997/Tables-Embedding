{
    "relation": [
        [
            "Metric",
            "E",
            "dice",
            "overlap",
            "maxdev",
            "L",
            "H",
            "euclidean",
            "manhattan",
            "difference"
        ],
        [
            "Attributes",
            "All Attribute Types",
            "Frame Span, Shape types",
            "Frame Span, Shape types",
            "Frame Span, Shape types",
            "String Value",
            "String Value",
            "Point",
            "Point",
            "Numerics"
        ],
        [
            "Definition",
            "Equivalence",
            "Twice the shared area, divided by the sum of the two areas.",
            "The fraction of the target that the candidate overlaps.",
            "The maximum either of the candidate or target deviation.",
            "Normalized Levenshtein (Edit) distance",
            "Hamming Distance",
            "Normalized Euclidean distance",
            "Normalized Manhattan distance",
            "Normalized difference"
        ],
        [
            "Formula",
            "0 if target equals candidate, 1 otherwise.",
            "1-2*sz(T^C)/(sz(T)+sz(C))",
            "1-sz(T^C)/sz(T)",
            "Maximum( sz(C-T)/sz(C) , sz(T-C)/sz(T) )",
            "E = Edit distance. Normalized using normalization factor alpha as follows: 1 - exp(-alpha * E)",
            "1 if length is different. Otherwise, for D = number of characters that are different, L = Length, returns D/L",
            "E = Euclidean distance, normalized as follows: 1 - exp(-alpha * E)",
            "M = Euclidean distance, normalized as follows: 1 - exp(-alpha * M)",
            "For D = abs(C \u00c3 T), distance is 1 - exp(-alpha * D)"
        ]
    ],
    "pageTitle": "Using ViPER-PE",
    "title": "",
    "url": "http://viper-toolkit.sourceforge.net/docs/pe/",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 3,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988308.23/warc/CC-MAIN-20150728002308-00074-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 248277015,
    "recordOffset": 248252922,
    "tableOrientation": "HORIZONTAL",
    "textBeforeTable": "Note: It is possible to short-circuit the evaluation and apply target matching without doing the statistic comparison or even the localization phase. You may set this with the level property, as described in the appendix. Object Analysis is divided into multiple phases: detection, localization, statistical comparison and target matching. Each phase is a finer level of analysis. Detection determines that some object was found in a set of frames for each target. Localization and statistical comparison make sure that a possible match has similar attributes. Finally, the target matching phase checks many-many candidate-target pairings, dealing with split and merged objects. Object analysis attempts to match candidate objects to target objects. It attempts to answer the question, How close are two descriptors? Using this idea, it determines which targets and candidates are close together, and then generates the precision and recall of the number of candidates matching targets. This involves defining some distance space for descriptors, preferably a metric one. For ViPER-PE, all distances are normalized between zero and one. A complete listing of the available metrics is included in the appendix. Object Analysis: Matching Candidates to Targets Given that the field of video understanding is wide open, little agreement exists upon a proper set of performance metrics. As such, ViPER-PE includes several different types of analysis, each of which is configurable. The three analysis types included in ViPER are object-matching, framewise comparison and track comparison. Performance evaluation involves comparing generated data, called",
    "textAfterTable": "standard output, and the empty string for none. -raw raw_file The file to receive the raw data output. Defaults to none. Set to \u00c3\"-` for standard output, and the empty string for none. -P<propertyname> Specify any property by its long name. -pr The file name of the properties file. target_match If using an object evaluation in your EPF, this parameter specifies the methods of object analysis: ALL, SINGLE, SINGLE-BEST, or MULTIPLE. =================== ============= ===== Given a valid set of properties, viper-pe will generate readable output in the file specified in the \u00c3\"-o\u00c3\u2022 option and machine readable data in the file from the \u00c3\"-raw\u00c3\u2022 option. It will display error messages to the system\u00c3\u2022s error stream, and informative messages to the stream in the -l option. From a Unix install, you should be able to invoke the command viper-pe from any location, assuming you have set the PATH variable by sourcing the viper.config file from csh, or dotting the viper-config.sh script from sh. From Windows, you will have to write a batch file, or invoke the slightly more complex command java \u00c3jar viper-pe.jar. For example, a simple command would be:  viper-pe \u00c3pr textdetect.pr -epf dice-graphic.epf -g all.gtf.xml \u00c3r UMD/RDF/all.rdf.xml -o dice-graphic.out -raw dice-graphic.raw Setting the Evaluation Parameters The evaluation parameters file is given as a list of sections, delimited with #BEGIN_<section> and #END_<section> lines. The",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}