{
    "relation": [
        [
            "mnemonic",
            "(LOAD n)",
            "(LOAD&PUSH n)",
            "(CONST n)",
            "(CONST&PUSH n)",
            "(STORE n)"
        ],
        [
            "operand range",
            "0 \u2264 n < 15",
            "0 \u2264 n < 25",
            "0 \u2264 n < 21",
            "0 \u2264 n < 30",
            "0 \u2264 n < 8"
        ]
    ],
    "pageTitle": "37.5.\u00a0The instruction set",
    "title": "",
    "url": "http://www.gnu.org/software/clisp/impnotes/instr-set.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 17,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042986444.39/warc/CC-MAIN-20150728002306-00129-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 479232623,
    "recordOffset": 479214834,
    "tableOrientation": "HORIZONTAL",
    "lastModified": "Wed, 07 Jul 2010 17:37:23 GMT",
    "textBeforeTable": "37.5.1.\u00a0Instructions for constants 37.5.17. Shortcut instructions 37.5.16. Combined instructions 37.5.15. Instructions for some inlined functions 37.5.14. Instructions for HANDLER-BIND 37.5.13. Instructions for UNWIND-PROTECT 37.5.12. Instructions for CATCH and THROW 37.5.11. Instructions for TAGBODY and GO 37.5.10. Instructions for BLOCK and RETURN-FROM 37.5.9. Instructions for multiple values 37.5.8. Instructions for optional and keyword parameters 37.5.7. Instructions for function calls 37.5.6. Instructions for lexical environment, creation of closures 37.5.5. Instructions for control flow, jumps 37.5.4. Instructions for stack operations 37.5.3. Instructions for dynamic variables 37.5.2. Instructions for lexical variables 37.5.1. Instructions for constants 37.5.\u00a0The instruction set \u00a0Next Chapter\u00a037.\u00a0The CLISP bytecode specification Prev\u00a0 37.5.\u00a0The instruction set",
    "textAfterTable": "37.5.2.\u00a0Instructions for lexical variables mnemonic description semantics (LOAD n) Load a directly accessible local variable into values. value1 := *(STACK+n), mv_count := 1 (LOADI k1 k2 n) Load an indirectly accessible local variable into values. k := k1 + jmpbufsize * k2, value1 := *(*(SP+k)+ n), mv_count := 1 (LOADC n m) Load a closed-up variable, defined in the same function and directly accessible, into values. value1 := SVREF(*(STACK+n),1+m), mv_count := 1 (LOADV k m) Load a closed-up variable, defined in an outer function, into values.",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}