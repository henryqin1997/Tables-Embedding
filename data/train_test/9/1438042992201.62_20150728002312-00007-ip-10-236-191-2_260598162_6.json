{
    "relation": [
        [
            "Nodes",
            "Port",
            "Collaboration",
            "CollaborationRole",
            "CollaborationUse",
            "InformationItem",
            "Parameter",
            "Activity",
            "Interaction",
            "ProtocolStateMachine",
            "StateMachine",
            "FunctionBehavior",
            "OpaqueBehavior"
        ],
        [
            "Addition",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No"
        ],
        [
            "Removal",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No",
            "No"
        ]
    ],
    "pageTitle": "Difference between revisions of \"EMF Compare/UML Compare\" - Eclipsepedia",
    "title": "",
    "url": "http://wiki.eclipse.org/index.php?title=EMF_Compare/UML_Compare&diff=319040&oldid=252106",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 6,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042992201.62/warc/CC-MAIN-20150728002312-00007-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 260614556,
    "recordOffset": 260598162,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{105613=Copyright \u00a9 2014 The Eclipse Foundation. All Rights Reserved.}",
    "textBeforeTable": "Second, we have to extend the internal contents of the base EObject with the stereotype application EObject in order to match base EObject with all their properties (including the ones from the applied stereotypes). First we have to provide our own IMatchScopeProvider implementation (or GenericMatchScopeProvider subclass) to also provide our own IMatchScope implementation to ignore EObject in the direct contents of the resources corresponding to stereotype applications. This test will be implemented in the isInScope() method of the IMatchScope. The first one forced us to subclass the GenericMatchEngine. We have two things to do: The second one is simply addressed by the compare extension mechanism. We will define specific extension to handle properties diff on stereotype application and to attached them to their base EObject. Compute the differences of stereotypes application properties and attached them to their base objects. Ignore the EObjects that store the stereotypes properties from the match engine in the object matching phase but instead include their properties in the \"base\" EObject during their matching. There are two issues to properly support UML profiles in UML compare engine: Profile / Stereotype support With this infrastructure, we are able to provide a scalable system to extend the GenericDiffEngine for UML difference computation. For each AbstractDiffExtension, a Factory is implemented and the pair of method handles/create gives the semantic of creation of this extension. The handles method should return quickly to",
    "textAfterTable": "?, means it is still unknown if it needs an extension (because we did not find a way to create the element from the Papyrus editor) TODO, means it needs to be implemented as an extension Done, means it has been implemented as an extension Class diagram Nodes Addition Removal Class No No ClassifierTemplateParameter No No Comment No No Component No No Constraint \u00a0? \u00a0? DataType No No DurationObservation \u00a0? \u00a0? Enumeration No No EnumerationLiteral No No Interface No No InstanceSpecification No No PrimitiveType No No Model No No Operation No No",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}