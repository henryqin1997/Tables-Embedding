{
    "relation": [
        [
            "Name",
            "FREQ",
            "INTERVAL",
            "BYMONTH",
            "BYWEEKNO",
            "BYYEARDAY",
            "BYDATE",
            "BYMONTHDAY",
            "BYDAY",
            "BYHOUR",
            "BYMINUTE",
            "BYSECOND",
            "BYSETPOS",
            "INCLUDE",
            "EXCLUDE",
            "INTERSECT",
            "PERIODS",
            "BYPERIOD"
        ],
        [
            "Description",
            "This specifies the type of recurrence. It must be specified. The possible predefined frequency values are YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, and SECONDLY. Alternatively, specifies an existing schedule to use as a user-defined frequency.",
            "This specifies a positive integer representing how often the recurrence repeats. The default is 1, which means every second for secondly, every day for daily, and so on. The maximum value is 999.",
            "This specifies which month or months you want the job to execute in. You can use numbers such as 1 for January and 3 for March, as well as three-letter abbreviations such as FEB for February and JUL for July.",
            "This specifies the week of the year as a number. It follows ISO-8601, which defines the week as starting with Monday and ending with Sunday; and the first week of a year as the first week, which is mostly within the Gregorian year. That last definition is equivalent to the following two variants: the week that contains the first Thursday of the Gregorian year; and the week containing January 4th. The ISO-8601 week numbers are integers from 1 to 52 or 53; parts of week 1 may be in the previous calendar year; parts of week 52 may be in the following calendar year; and if a year has a week 53, parts of it must be in the following calendar year. As an example, in the year 1998 the ISO week 1 began on Monday December 29th, 1997; and the last ISO week (week 53) ended on Sunday January 3rd, 1999. So December 29th, 1997, is in the ISO week 1998-01; and January 1st, 1999, is in the ISO week 1998-53. byweekno is only valid for YEARLY. Examples of invalid specifications are \"FREQ=YEARLY; BYWEEKNO=1; BYMONTH=12\" and \"FREQ=YEARLY;BYWEEKNO=53;BYMONTH=1\".",
            "This specifies the day of the year as a number. Valid values are 1 to 366. An example is 69, which is March 10 (31 for January, 28 for February, and 10 for March). 69 evaluates to March 10 for non-leap years and March 9 in leap years. -2 will always evaluate to December 30th independent of whether it is a leap year.",
            "This specifies a list of dates, where each date is of the form [YYYY]MMDD. A list of consecutive dates can be generated by using the SPAN modifier, and a date can be adjusted with the OFFSET modifier. An example of a simple BYDATE clause is the following: BYDATE=0115,0315,0615,0915,1215,20060115 The following SPAN example is equivalent to BYDATE=0110,0111,0112,0113,0114, which is a span of 5 days starting at 1/10: BYDATE=0110+SPAN:5D The plus sign in front of the SPAN keyword indicates a span starting at the supplied date. The minus sign indicates a span ending at the supplied date, and the \"^\" sign indicates a span of n days or weeks centered around the supplied date. If n is an even number, it is adjusted up to the next odd number. Offsets adjust the supplied date by adding or subtracting n days or weeks. BYDATE=0205-OFFSET:2W is equivalent to BYDATE=0205-14D (the OFFSET: keyword is optional), which is also equivalent to BYDATE=0122.",
            "This specifies the day of the month as a number. Valid values are 1 to 31. An example is 10, which means the 10th day of the selected month. You can use the minus sign (-) to count backward from the last day, so, for example, BYMONTHDAY=-1 means the last day of the month and BYMONTHDAY=-2 means the next to last day of the month.",
            "This specifies the day of the week from Monday to Sunday in the form MON, TUE, and so on. Using numbers, you can specify the 26th Friday of the year, if using a YEARLY frequency, or the 4th THU of the month, using a MONTHLY frequency. Using the minus sign, you can say the second to last Friday of the month. For example, -1 FRI is the last Friday of the month.",
            "This specifies the hour on which the job is to run. Valid values are 0 to 23. As an example, 10 means 10 a.m.",
            "This specifies the minute on which the job is to run. Valid values are 0 to 59. As an example, 45 means 45 minutes past the chosen hour.",
            "This specifies the second on which the job is to run. Valid values are 0 to 59. As an example, 30 means 30 seconds past the chosen minute.",
            "This selects one or more items by position in the list of timestamps that result after the whole calendaring expression is evaluated. It is useful for requirements such as running a job on the last workday of the month. Rather than attempting to express this with the other BY clauses, you can code the calendaring expression to evaluate to a list of every workday of the month, and then add the BYSETPOS clause to select only the last item of that list. Assuming that workdays are Monday through Friday, the syntax would then be: FREQ=MONTHLY; BYDAY=MON,TUE,WED,THU,FRI; BYSETPOS=-1 Valid values are 1 through 9999. A negative number selects an item from the end of the list (-1 is the last item, -2 is the next to last item, and so on) and a positive number selects from the front of the list. The BYSETPOS clause is always evaluated last. BYSETPOS is only supported with the MONTHLY and YEARLY frequencies. The BYSETPOS clause is applied to the list of timestamps once per frequency period. For example, when the frequency is defined as MONTHLY, the Scheduler determines all valid timestamps for the month, orders that list, and then applies the BYSETPOS clause. The Scheduler then moves on to the next month and repeats the procedure. Assuming a start date of Jun 10, 2004, the example evaluates to: Jun 30, Jul 30, Aug 31, Sep 30, Oct 29, and so on.",
            "This includes one or more named schedules in the calendaring expression. That is, the set of timestamps defined by each included named schedule is added to the results of the calendaring expression. If an identical timestamp is contributed by both an included schedule and the calendaring expression, it is included in the resulting set of timestamps only once. The named schedules must have been defined with the CREATE_SCHEDULE procedure.",
            "This excludes one or more named schedules from the calendaring expression. That is, the set of timestamps defined by each excluded named schedule is removed from the results of the calendaring expression. The named schedules must have been defined with the CREATE_SCHEDULE procedure.",
            "This specifies an intersection between the calendaring expression results and the set of timestamps defined by one or more named schedules. Only the timestamps that appear both in the calendaring expression and in one of the named schedules are included in the resulting set of timestamps. For example, assume that the named schedule last_sat indicates the last Saturday in every month, and that for the year 2005, the only months where the last day of the month is also a Saturday are April and December. Assume also that the named schedule end_qtr indicates the last day of each quarter in 2005: 3/31/2005, 6/30/2005, 9/30/2005, 12/31/2005 The following calendaring expression results in these dates: 3/31/2005, 4/30/2005, 6/30/2005, 9/30/2005, 12/31/2005 FREQ=MONTHLY; BYMONTHDAY=-1; INTERSECT=last_sat,end_qtr In this example, the terms FREQ=MONTHLY; BYMONTHDAY=-1 indicate the last day of each month.",
            "This identifies the number of periods that together form one cycle of a user defined frequency. It is used in the repeat_interval expression of the schedule that defines the user defined frequency. It is mandatory when the repeat_interval expression in the main schedule contains a BYPERIOD clause. The following example defines the quarters of a fiscal year. FREQ=YEARLY;BYDATE=0301,0601,0901,1201;PERIODS=4",
            "This selects periods from a user defined frequency. For example, if a main schedule names a user defined frequency schedule that defines the fiscal quarters shown in the previous example, the clause BYPERIOD=2,4 in the main schedule selects the 2nd and 4th fiscal quarters."
        ]
    ],
    "pageTitle": "DBMS_SCHEDULER",
    "title": "",
    "url": "http://www.comp.dit.ie/btierney/oracle11gdoc/appdev.111/b28419/d_sched.htm",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 10,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042991019.80/warc/CC-MAIN-20150728002311-00277-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 376448715,
    "recordOffset": 376377430,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{50616=For example, assume that the named schedule last_sat indicates the last Saturday in every month, and that for the year 2005, the only months where the last day of the month is also a Saturday are April and December. Assume also that the named schedule end_qtr indicates the last day of each quarter in 2005:, 60502=\"FREQ=YEARLY;BYMONTH=JAN,JUL\" with start date 01/21/2003 becomes \"FREQ=YEARLY;BYMONTH=JAN,JUL;BYMONTHDAY=21\", which means every year on January 21 and July 21., 60153=When not enough BY clauses are present to determine what the next date is, this information is retrieved from the start date. For example, \"FREQ=YEARLY\" with a start date of 02/15/2003 becomes \"FREQ=YEARLY;BYMONTH=FEB; BYMONTHDAY=15\", which means every year on the 15th of February., 42846=As an example, in the year 1998 the ISO week 1 began on Monday December 29th, 1997; and the last ISO week (week 53) ended on Sunday January 3rd, 1999. So December 29th, 1997, is in the ISO week 1998-01; and January 1st, 1999, is in the ISO week 1998-53., 55009=In this example, the dates 1/30, 2/20, and 7/25 are added to the main schedule. However, the Scheduler does not include dates that fall in months that are skipped by the INTERVAL clause. If the start date of the main schedule is 1/1/2005, then 2/20 isn't added. On the dates that are added, the embedded schedule follows the execution pattern of the main schedule: jobs are executed at 9:00 a.m. and 5:00 p.m. on 1/30 and 7/25. If the embedded schedule does not itself have a start date, it inherits the start date from the main schedule., 34868=The Scheduler uses a rich calendaring syntax to enable you to define repeating schedules, such as \"every Tuesday and Friday at 4:00 p.m.\" or \"the second Wednesday of every month.\" This calendaring syntax is used in calendaring expressions in the repeat_interval argument of a number of package subprograms. Evaluating a calendaring expression results in a set of discrete timestamps., 44339=BYDATE=0115,0315,0615,0915,1215,20060115, 61336=Note that when the byweekno clause is used, it is possible that the dates returned are from a year other than the current year. For example, if returning dates for the year 2004 and the calendar string is \"FREQ=YEARLY;BYWEEKNO=1,53\" for the specified week numbers in 2004, it will return the dates:, 63403=Repeating jobs with frequencies smaller than daily follow their frequencies exactly across daylight savings adjustments. For example, suppose that a job is scheduled to repeat every 3 hours, the clock is moved forward from 1:00 a.m. to 2:00 a.m., and the last time the job ran was midnight. Its next scheduled time will be 4:00 a.m. Thus, the 3 hour period between subsequent job runs is retained. The same applies when the clock is moved back. This behavior is not the case for repeating jobs that have frequencies of daily or larger. For example, if a repeating job is supposed to be executed on a daily basis at midnight, it will continue to run at midnight if the clock is moved forward or backward. When the execution time of such a daily (or larger frequency) job happens to fall inside a window where the clock is moved forward, the job executes at the end of the window., 58656=The preceding schedule executes on 04/15/05 9:00:00, 04/15/06 9:00:00, 04/15/07 9:00:00, and so on., 68454=then the execution times on 05/02 and 09/22 are 8:00 a.m., 1:00 p.m., and 6:00 p.m., 48508=The BYSETPOS clause is applied to the list of timestamps once per frequency period. For example, when the frequency is defined as MONTHLY, the Scheduler determines all valid timestamps for the month, orders that list, and then applies the BYSETPOS clause. The Scheduler then moves on to the next month and repeats the procedure. Assuming a start date of Jun 10, 2004, the example evaluates to: Jun 30, Jul 30, Aug 31, Sep 30, Oct 29, and so on., 60731=The byweekno clause is only allowed if the frequency is YEARLY. It cannot be used with other frequencies. When it is present, it will return all days in that week number. If you want to limit it to specific days within the week, you have to add a BYDAY clause. For example, \"FREQ=YEARLY;BYWEEKNO=2\" with a start date of 01/01/2003 will return:, 59122=Because an INCLUDE clause is present, date-related information is not retrieved from the start date. However, time-specific information is, so the preceding schedule executes on 07/01/05 9:00:00, 07/01/06 9:00:00, 07/01/08 9:00:00, and so on., 70011=Many companies in the retail industry share the same fiscal year. The fiscal year starts on the Sunday closest to February 1st, and subsequent quarters start exactly 13 weeks later. The fiscal year schedule for the retail industry can be defined as the following:, 67548=on 01/01/2004 or 01/15/2004, in both cases the expression evaluates to Friday 01/02/2004, and Tuesday 01/06/2004. The only difference is that when the expression is evaluated on 01/15/2004, the Scheduler determines that there are no matches in January because the timestamps found are in the past, and it moves on to the matches in the next month, February.}",
    "lastModified": "Tue, 27 Nov 2007 20:25:20 GMT",
    "textBeforeTable": "Table 114-7 Values for repeat_interval In calendaring syntax, * means 0 or more. minus = \"-\" numofdays = 1 through 376 numofweeks = 1 through 53 dur_days = numofdays \"D\" dur_weeks = numofweeks \"W\" duration_val = dur-weeks | dur_days span = (\"+\" | \"-\" | \"^\") \"SPAN:\" duration_val offset = (\"+\" | \"-\") [\"OFFSET:\"] duration_val periodnum = 1 through 100 period_list = periodnum (\",\" periodnum)* byperiod_clause = \"BYPERIOD\" \"=\" period_list periods_clause = \"PERIODS\" \"=\" periodnum named_schedule = [schema \".\"] schedule schedule_clause = named_schedule [ offset ] schedule_list = schedule_clause (\",\" schedule_clause)* intersect_clause = \"INTERSECT\" \"=\" schedule_list exclude_clause = \"EXCLUDE\" \"=\" schedule_list include_clause = \"INCLUDE\" \"=\" schedule_list setpos_num = 1 through 9999 setpos = [minus] setpos_num setpos_list = setpos (\",\" setpos)* bysetpos_clause = \"BYSETPOS\" \"=\" setpos_list second = 0 through 59 second_list = second ( \",\" second)* bysecond_clause = \"BYSECOND\" \"=\" second_list minute = 0 through 59 minute_list = minute ( \",\" minute)* byminute_clause = \"BYMINUTE\" \"=\" minute_list hour = 0 through 23 hour_list = hour ( \",\" hour)* byhour_clause = \"BYHOUR\" \"=\" hour_list day = \"MON\" | \"TUE\" | \"WED\" | \"THU\" | \"FRI\" | \"SAT\" | \"SUN\" daynum = 1 through 5 /* if frequency is monthly */ daynum = 1 through 53 /* if frequency is yearly */ weekdaynum = [minus] daynum byday = [weekdaynum] day byday_list = byday ( \",\" byday)* byday_clause = \"BYDAY\" \"=\" byday_list monthdaynum = 1 through 31 monthday = [minus] monthdaynum monthday_list =",
    "textAfterTable": "Combining Schedules There are two ways to combine schedules: Using a combined schedule expression, which is a list of individual schedules For example, to create a schedule for all company holidays, you provide a list of individual schedules, where each schedule in the list defines a single holiday. The Scheduler evaluates each individual schedule, and then returns a union of the timestamps returned by each individual schedule. You can follow the initial list of individual schedules with include, exclude, and intersect clauses to create more complex combinations. Embedding other schedules into the main schedule using include, exclude, and intersect clauses With this method, the embedded schedules inherit certain attributes from the main schedule. Timestamps generated by the INCLUDE clause that fall into periods that are skipped by the main schedule are ignored. This is the case when the main schedule skips periods due to the INTERVAL clause, the BYPERIOD clause, or the BYMONTH clause for freq=monthly. Days that are added by the INCLUDE clause follow the hourly/minutely/secondly execution pattern of the main schedule. When the INCLUDE clause is present, no date-specific defaults are retrieved from the start date (but time-specific defaults can be). (See \"Start Dates and Repeat Intervals\", later in this section.) For example, a repeat_interval of FREQ=MONTHLY;INCLUDE=HOLIDAY executes only on holidays and not on the month/day defaults retrieved from the start date. The following is an example:",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}