{
    "relation": [
        [
            "Name",
            "CursorSize",
            "CursorVisible",
            "EditionMode",
            "ExitOnDie",
            "FaceName",
            "FontSize",
            "FontWeight",
            "HistoryBufferSize",
            "HistoryNoDup",
            "MenuMask",
            "QuickEdit",
            "ScreenBufferSize",
            "ScreenColors",
            "WindowSize"
        ],
        [
            "Default value",
            "25",
            "1",
            "0",
            "1",
            "No default",
            "0x0C08",
            "0",
            "50",
            "0",
            "0",
            "0",
            "0x1950",
            "0x000F",
            "0x1950"
        ],
        [
            "Purpose",
            "Percentage of cell height to which the cursor extents",
            "Whether the cursor is visible or not",
            "The way the edition takes place in the console: 0 is insertion mode, 1 is overwrite mode.",
            "Whether the console should close itself when last running program attached to it dies",
            "Name of the font to be used for display. When none is given, wineconsole tries its best to pick up a decent font",
            "The high word in the font cell height, and the low word is the font cell width. The default value is 12 pixels in height and 8 pixels in width.",
            "Weigth of the font. If none is given (or 0) wineconsole picks up a decent font size",
            "Number of entries in history buffer (not actually used)",
            "Whether the history should store twice the same entry",
            "This mask only exists for Wine console handling. It allows to know which combination of extra keys is needed to open the configuration window on right click. The mask can include MK_CONTROL or MK_SHIFT bits. This can be needed when programs actually need the right click to be passed to them instead of being intercepted by wineconsole.",
            "If null, mouse events are sent to the application. If non null, mouse events are used to select text on the window. This setting must really be set on a application per application basis, because it deals with the fact the CUI application will use or not the mouse events.",
            "The high word is the number of font cells in the height of the screen buffer, while the low word is the number of font cells in the width of the screen buffer.",
            "Default color attribute for the screen buffer (low char is the foreground color, and high char is the background color)",
            "The high word is the number of font cells in the height of the window, while the low word is the number of font cells in the width of the window. This window is the visible part of the screen buffer: this implies that a screen buffer must always be bigger than its window, and that the screen buffer can be scrolled so that every cell of the screen buffer can be seen in the window."
        ]
    ],
    "pageTitle": "Wine Developer's Guide",
    "title": "",
    "url": "http://ftp.winehq.org/pub/wine/docs/en/winedev-guide.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 20,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042987775.70/warc/CC-MAIN-20150728002307-00128-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 97958019,
    "recordOffset": 97812863,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{12225=Selector 0x1f7 (0x40320000, 0x0000ffff, r-x) So 0x1f7 has a base address of 0x40320000, the segment's last address is 0x4032ffff (limit 0xffff), and it's readable and executable. So an address of 0x1f7:0x2300 would be the linear address of 0x40322300., 19297=I think that the call to MessageBox() in this example is not caused by a wrong result value of some previously executed function (it's happening quite often like that), but instead the message box complains about a runtime error at 0x0004:0x1056., 18933=As the segment value of the address is only 4, I think that that is only an internal program value. But the offset address reveals something quite interesting: offset 1056 is very close to the return address of FREELIBRARY():, 11455=Now the strange thing is the calculation that's behind these addresses: just calculate segment*16 + offset in order to get a \"linear DOS\" address. So e.g. 0x0f04:0x3628 results in 0xf040 + 0x3628 = 0x12668. And the highest address you can get is 0xfffff (1MB), of course.}",
    "TableContextTimeStampAfterTable": "{61371=Based on gcov, we now know that line 1275 is executed once. And since all of our other tests have remain unchanged, we can assume that the one time it is executed is to satisfy the testcase we added where we check for it. Thus we have validated a line of code. While this is a cursory example, it demonstrates the potential usefulness of this tool., 356434=It depends on the Windows version, I think. Windows 95 and Windows NT 4 certainly had very different models when I looked. I'm pretty sure the Windows 98 version of RPCRT4 was able to dispatch messages directly to individual apartments. I'd be surprised if some similar functionality was not added to Windows 2000. After all, if an object on machine A wanted to use an object on machine B in an apartment C, wouldn't it be most efficient if the RPC system knew about apartments and could dispatch the message directly to it? And if RPC does know how to efficiently dispatch to apartments, why should COM duplicate this functionality? There were, however, no unified way to tell RPC about them across Windows versions, so in that old patch of mine, I let the COM/OLE dlls do the apartment dispatch, but even then, the RPC runtime was always involved. After all, it could be quite tricky to tell whether the call is merely interthread, without involving the RPC runtime..., 55045=If you found that something broke between wine-1.1.42 and wine-1.1.44 (these are [WWW] release tags). To start regression testing we run:, 209111=Up until about the start of 2004, the Linux address space very much resembled the Windows 9x layout: the kernel sat in the top gigabyte, the bottom pages were unmapped to catch null pointer dereferences, and the rest was free. The kernels mmap algorithm was predictable: it would start by mapping files at low addresses and work up from there., 153052=Programming language types, e.g. from a typedef definition. May have other uses, too., 363681=In the Windows 2000 release of COM, several new types of apartment were added, the most important of which are RTAs (the rental threaded apartment) in which concurrent access are serialised by COM using an apartment-wide lock but thread affinity is not guaranteed.}",
    "lastModified": "Tue, 04 Feb 2014 17:17:12 GMT",
    "textBeforeTable": "Table 1-1. WineDbg misc. commands 1.7.1. Misc 1.7. WineDbg Command Reference The $ThreadId and $ProcessId variables can be handy to set conditional breakpoints on a given thread or process. All CPU registers are also available, using '$' as a prefix. You can use info regs to get a list of available CPU registers. registers ID of the W-thread currently examined by the debugger $ProcessId ID of the W-thread currently examined by the debugger $ThreadId winedbg defines its own set of variables. The configuration variables from above are part of them. Some others include: In lots of cases, you can also use regular expressions for looking for a symbol. When specifying an identifier by its name, if several symbols with the same name exist, the debugger will prompt for the symbol you want to use. Pick up the one you want from its number. In cast operation, when specifying a structure or an union, you must use the struct or union keyword (even if your program uses a typedef). Identifiers can take a '!' in their names. This allow mainly to access symbols",
    "textAfterTable": "Table 1-3. WineDbg break & watch points enable N enables (break|watch)point N disable N disables (break|watch)point N delete N deletes (break|watch)point N cond N removes any existing condition to (break|watch)point N cond N expr adds condition expr to (break|watch)point N. expr will be evaluated each time the breakpoint is hit. If the result is a zero value, the breakpoint isn't triggered. break\u00a0* N adds a breakpoint at address N break id adds a breakpoint at the address of symbol id break id N adds a breakpoint at line N inside symbol id break N adds a breakpoint at line N of current source file break adds a breakpoint at current $PC address watch\u00a0* N adds a watch command (on write) at address N (on 4 bytes) watch id adds a watch command (on write) at the address of symbol id info break lists",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}