{
    "relation": [
        [
            "Date",
            "28 juin 1999",
            "9 janv. 2002",
            "9 juin 2003",
            "3 nov. 2003",
            "2 juil. 2007"
        ],
        [
            "Code",
            "FPAY",
            "AS",
            "FPAY",
            "AS",
            "FPAY"
        ],
        [
            "\ufffdv\ufffdnement",
            "Fee payment",
            "Assignment",
            "Fee payment",
            "Assignment",
            "Fee payment"
        ],
        [
            "Description",
            "Year of fee payment: 4",
            "",
            "Year of fee payment: 8",
            "",
            "Year of fee payment: 12"
        ]
    ],
    "pageTitle": "Brevet US5481699 - Durable atomic storage update manager - Google\ufffdBrevets",
    "title": "",
    "url": "http://www.google.fr/patents/US5481699",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 8,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988598.68/warc/CC-MAIN-20150728002308-00254-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 478353007,
    "recordOffset": 478293727,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{154401=As shown by step 842, the log record is actually written as part of the call appearing in APPENDIX 1, 56:1910. The log record address (or unique identifier) for the log record just written in this last log record field in (ftxp.lastLogRecord is also returned. When the log record eventually gets written, the ftxp.lastLogRecord field will have the value of the current, just-written, field. When the next done record subtransaction for this transaction is written, it will set the backlink field to this record. In this fashion, each successive record that gets written to the log will point (or backlink) to the previously written record., 181964=The log for the relevant domain is accessed (step 1002) and the last log record is found at step 1004 using a done rec variable containing the log record contents. In APPENDIX 1, 74:266, a pointer to a buffer \"dlrp\" pointer is used to obtain the last log record or logger end, using coding techniques well known to those skilled in the relevant art., 176594=After the bookkeeping chores of step 920 are complete, at step 922 the routine calls the undo procedure for those agents specified in the done record at hand (APPENDIX 1, 41:1066). At step 922, the routine passes in the ftx transaction handle and a pointer to the undo record in the done record. It will be recalled that the undo record that was passed on an original ftx-- done call exists as part of the log record. As noted earlier, the ftx-- undo, ftx-- rootdone and ftx-- redo procedure are agent-specific. With respect to FIG. 11D, step 922, the undo routine is now called via a pointer to the data in that record for the relevant agent (APPENDIX 1, 41:1042 denotes the agent)., 140593=Step 702 represents various bookkeeping tasks such as locating the structure initialized by the rbf-- pin-- page service. Preferably the specific page within the current level within the ftx structure is described, as at code line 1514., 196274=In FIG. 12E, as shown by step 1080, a test is made to determine whether the RD counter variable equals the rootdone record count. If yes, then by definition the routine is at the last root done record, and all root done records have been buffered. Thus, in this situation the member number is set to zero at step 1082, designating that no further root done records are present. On the other hand, if step 1080 does not indicate that the last root done record is at hand, at step 1084 the member field count is incremented by one., 152497=In the following description, it should be emphasized that while modified pages eventually get written to persistent storage by a buffer manager, they are not necessarily immediately written to disk. At step 840, the procedure sets the log record backlink to the last log record field in the ftx structure, essentially by passing a parameter into the logger write call. The call that actually writes the log record from the descriptor thus constructed may be found in APPENDIX 1, 56:1910-1915., 178632=As depicted by FIG. 11C, the routine next goes to step 906 and the loop is reexecuted until a test result branches to step 934. At step 934 (Appendix 1, 43:1129-1130), a test determines whether all done records for the transaction tree have been exhausted (e.g., processing could have terminated for other reasons)., 190568=It will be recalled from step 1046 that when the log record representing the end of a particular transaction tree was obtained, the routine deallocated that tree's record. Thus, at the end of all log records, for any transaction tree that is incomplete, there will still be an allocated ftx structure. Much of the remainder of the applicable code in APPENDIX 1 deals with such incomplete transaction trees, either rolling such trees forward, or backing them out., 139996=As shown in step 700, the routine obtains various input parameters, including the bitfile page handle (e.g., a reference to the page just pinned by the rbf-- pin-- page service), a start address in memory for the record (or extent) being modified, and a record size parameter (e.g., the number of bytes offset from the start address that have been, or are to be, modified). The relevant code is found in APPENDIX 1, 48:1470-1474, which code preferably is called before any modifications are made, thus providing an option to rollback partial transactions., 188411=After step 1036, or if branched directly from step 16, step 1038 is reached and a test made to determine whether there are any operational redo records in the done record under consideration (APPENDIX 1, 79:571). If step 1038 determines the relevant field count to be zero, no operation redo records exist and the routine passes to step 1042 (FIG. 12C). But if the field count at step 1038 is not zero, then there are operation redo records and the routine passes to step 1040, which invokes a redo procedure for the particular agent id. As depicted by step 1040, the routine passes the agent id the ftx handle and a pointer to the op redo record data in the relevant done record (see FIG. 5, optional field 338). See APPENDIX 1, 580:576, 580., 156005=Preferably the buffer manager tracks the first time the oldest log address was associated with any given modified page, as well as when modified pages are actually written to persistent storage. As such, the buffer manager always knows the oldest log record address that has not been written for any modified buffer. The buffer manager returns this information in step 838 in FIG. 10B, namely the log record address associated with the oldest buffer that has not yet been written to disk. At step 840, the oldest buffer not yet written to disk is returned, and is referred to in step 844 as the oldest buffer being released. At step 844, this buffer is given a log record address that was returned in step 838. The relevant source code begins at APPENDIX 1, 57:1954 and shows a loop traversing this structure. The modified pages are released at code line 1982, with the subroutine at code line 1983 being passed the last log record address. At step 846, the routine reduces the current level number for this transaction by one, and at step 848 the routine exits (see APPENDIX 1, 37:806)., 191050=If the routine at step 1050 determines no ftx structures are allocated, then at step 1052 a test is made to determine whether the current recovery pass is the maximum pass number (e.g., n=2 in the presently preferred embodiment). If at step 1052 it is determined the present pass is not the maximum pass number (e.g., assume the present pass is pass n=1), at step 1054 the present pass number is incremented by one (e.g., increased in this example from n=1 to the maximum n=2). Step 1054 then branches back to step 1010 (FIG. 12A) and the routine continues from there., 147880=Assume first that step 810 determines a subtransaction is being completed. The relevant code appears in APPENDIX 1, 37:773 and a size parameter test at step 820 in FIG. 10B determines whether an undo record is present. If so, an undo record is being passed to this routine and step 822 adds a description of that undo record to the log descriptor. The relevant subroutine is denoted addone-- undo and is found at APPENDIX 1, 53:1718. Code line 1773 sets the undo record byte count field in the log record header to the value of that count (where 0 denotes not present, and a non-0 value means data will follow as depicted in FIG. 5)., 197527=At step 1094 the routine tests whether the member number is zero. A non-zero member number implies that records were skipped because they were at an improper recovery pass level. However if for such skipped records, eventually the member number will be zero, whereupon the procedure is complete. Upon completion, at step 1096 the ftx structure (having served its purpose) is deallocated, and the routine loops back to step 1050 (FIG. 12C) to learn whether there are further incomplete ftx structures to be dealt with., 135738=Having thus obtained a reference to the ftx structure, as shown in step 606, the routine then provides another pointer internally to the current level within that structure. Preferably this is accomplished by setting a current level pointer (using level number information embedded within the ftx transaction handle) to locate that internal data structure. See APPENDIX 1, 46:1304. Essentially the rbf-- pinpg service is establishing a page that will be referenced later in the process., 184473=If step 1016 does not find an existing appropriate structure for the same transaction id, at step 1018, an allocation is made for an ftx structure. Preferably there is set an ftxp pointer to the ftx structure that will be referenced in the following description of FIGS. 12A-12E. Initializations then set the ftx structure's lrh ftx id field equal to that of the done record just read, the domain id field is set, and the root done record count is initialized to zero. However if step 1016 did locate an appropriate structure, no allocation is required and the routine goes to step 1020 where an ftxp pointer to the just located ftx structure is set. See APPENDIX 1, 77:447-477., 197174=At step 1090 the routine increments the root done count by one and tests at step 1092 whether now all root done records have been processed. If not, the routine branches back to step 1070 (FIG. 12D) for further processing. However if step 1092 determines all root done records have been executed, then the routine drops to step 1094., 194801=The routine at step 1066 sets an RD count variable to the current level member minus one (APPENDIX 1, 81:654). The RD count variable is analogous to the root done variable employed in ftx-- done (see FIGS. 10D, 10E). Next, at step 1068 various system parameters are initialized (APPENDIX 1, 81: 666-671) and at step 1070, an rd rec variable is set to point to the RD count buffered root done record. In this manner, the RD count variable is used as an index into the buffered root done record in the ftx structure (APPENDIX 1, 81:676)., 191638=But if the determination at step 1052 is that the current recovery pass is indeed the final pass, the routine is completes at step 1056 and the sequence is terminated., 148544=Regardless of the determination of step 820, the operation eventually passes to step 824, and a determination is made as to whether a root done record is being specified by this particular subtransaction completion. If yes (i.e., size\u22600) the root done operational record is added to the log descriptor by step 826 (APPENDIX 1, 54:1774, addone-- rtdn)., 187139=If page redo data exists, the routine branches to step 1036 for updating of all record extents with the page data as the buffered record extent data in the done record with the relevant redo data. Preferably the data in the record is simply copied into the pages describing where the data belongs. See for example field 428 in FIG. 6. For each bitfile page described by the ftxLog record, the data for each extent is copied into the appropriate page and is written back to persistent storage in essentially a redo recovery action. But data that was modified is overwritten on these pages in persistent storage. Once these data are copied, it is known that all original modifications have been again modified., 192615=However if the step 1062 determination is that the current atomic recovery pass does not exceed the recovery pass variable for the present loop, the routine drops to step 1064. At step 1064 the routine invokes the ftx-- fail routine described earlier, using the current ftx' handle and recovery pass value information. The routine then branches back to step 1050 to search for another ftx structure with which to deal. One outcome of invoking the ftx-- fail routine is that the routine also deallocates the ftx structure at hand., 195882=As shown by step 1076, the routine then invokes the root-- done procedure for this record's agent id, and passes that information as the ftxHandle parameter, and as a pointer to the buffered rootdone record. See APPENDIX 1, 81:693-698. At step 1078 the routine sets the log descriptor needed to write the log record to point to the particular log record header., 137753=The per page descriptor (APPENDIX 1, 46:1338-1339) retains both the page handle (returned from the internal pin page function) and the page address. As indicated by step 614, the rbg-- pinpg service provides a page memory pointer output parameter (pageMemP) that is returned at code line 1342, and represents the same field that was stored internally., 189174=With respect to FIG. 12C, step 1042, a test is made to learn whether the current level is zero (APPENDIX 1, 79:587). If zero, the routine branches to step 1044 to test whether the current member is zero. Since the final record in the transaction sequence will be level 0 member 0, (0,0), all actions associated with the transaction tree will have been completely processed to this point. Thus is reading through the log, when a (0,0) record is reached, the routine is done with the entire tree., 177926=In FIG. 11E, further bookkeeping is done at step 926 causing the log descriptor to point to the log record header in the ftx structure (APPENDIX 1, 42:1096-1099). At step 928, the page value redo descriptor information and the done record redo subroutine are advantageously added by copying steps 836-838 (FIG. 10B). (APPENDIX 1, 42:1103). The crash redo field is thus set to a value associated with the oldest buffer not yet written., 176056=At step 916, by testing for a zero count field the routine knows whether the done record includes an undo record. A zero count signifies no undo record, in which case the routine branches to step 934 in FIG. 11E for eventual termination (see APPENDIX 1, 41:1038). A non-zero field result at step 916 means there is an undo record (APPENDIX 1, 41:1041) in which case the routine branches to step 920 where routine bookkeeping sets the field levels to the current value for the record at hand (APPENDIX 1, 41:1060-1061)., 177341=Step 924 represents bookkeeping tasks that setup a log record header. Having thus executed an undo routine, a log record is now written as a redo record to reflect what occurred in the undo routine. An initial function at step 924 sets the field level to the inverse of the level of the original done record. Preferably the remaining parameters are simply copied from the done record, and the relevant undo, rootdone and op redo byte count portions of the done record are set to zero (since undo, rootdone and op redo are not present). See APPENDIX 1, 42:1081-1089., 138135=By definition, no extents have been stored to this point, and step 616 is initialized by code line 1320 to reset the extent count field to zero before any extents can be allocated. As shown by step 618, the routine next sets the bitfile page handle (bitfilePageH), which is returned to the caller as the caller's reference at step 620 for use with the rbf-- pin-- record service (to be described). The bitfile page handle enables the present invention to return to the data structure whose fields have just been filled in., 193186=To review briefly, step 1064 concerned the case where an incomplete transaction tree was found. The recovery pass for the incomplete tree are its nodes, and where the present node was equal to the recovery pass value, the undo procedure was invoked. The ftx-- fail procedure was called and the routine backed out of all nodes associated with the particular recovery pass. The relevant code is included within the ftx-- fail routine, which is why the recovery pass information was included in ftx-- fail in the first place., 183590=According to step 1016, for each record read in, there is built in the in-memory structure (see FIG. 6) precisely the same structure constructed during normal log sequence. This mirror structure is made to track and to replay in memory the steps occurring when run time execution occurred. In step 1016, when operation commences, no ftx structures will exist. Thereafter, for each log record read, step 1016 tests whether there has already been allocated an ftx structure containing the transaction identification that is in the log record in the ftx id field in the log record donerec.ftx id. This test can be found in APPENDIX 1, 77:439-445, wherein the code value -2 denotes a presently in use condition, and wherein BS-- UID-- EQL is a macro comparing the ftx id field in the log record and the ftx id field in the ftx structure at hand., 152167=In FIG. 10B, at step 838 the routine sets the log record header's crash redo field to the log record address associated with the oldest buffer not written to disk, see APPENDIX 1, 56:1899. A relevant log done record and unpin page subroutine is called at APPENDIX 1, 37:802, and appears at APPENDIX 1, 56:1882., 192321=At step 1062 the routines tests whether the atomic recovery pass field for the current level exceeds the recovery pass variable for the present routine loop. If \"yes\", the routine branches back to step 1050 and looks for another ftx structure (APPENDIX 1, 80:626)., 195367=A check is then made at step 1072 to learn whether this particular done record is for a node action at the same recovery pass as the present recovery pass. If the recovery pass variables are the same, the routine branches to step 1094 (FIG. 12E). However, if the recovery pass variables do not agree, the routine drops to step 36 where various fields in are set in the ftx structure's header area, which fields include recovery pass, and the agent id obtained from the buffered root done record., 140871=As shown by step 704 in FIG. 9, the relative byte offset within a page (recboff) and the byte count (which was passed into step 704 directly as record size) are calculated using various parameters. The parameters include the stored page address (which was returned as a page memory pointer output parameter and internally stored in the pin page descriptor) and the reference address (passed into step 704 by code line 1521). At APPENDIX 1, 50: 1531-1561, a check is made to determine that the currently specified byte range is contained either in a previously specified byte range, or is adjacent to such a range. If such is the case, preferably the byte range may advantageously be described with a single extent rather than with two extents, thus avoiding describing the same information twice., 182983=The main loop of the ftx-- recovery service commences with step 1014, with the relevant code commencing at APPENDIX 1, 76:348. As indicated by step 1014, the log record is read at the at the address for the log record whose variable was just set into done record. In addition, the log record variable is reset to the next log record in the log line (APPENDIX 1, 76:384-342. If there are multiple calls, the entire record is buffered, but for ease of illustration, the flow charts of FIGS. 12A-12E assume the entire record is contained within a single logical record, done rec., 180216=At step 936 a determination is made as to whether the entire tree has been failed, in which case the procedure branches to step 946 (FIG. 11F), eliminating further steps. However, if the entire transaction has not failed, the routine branches to step 938. At step 938, the log record header is again initialized to nil (APPENDIX 1, 43:1136-1144). At step 940 step 838 (FIG. 10B) is copied to establish a crash redo address. At step 942 the log record backlink is set to the end of record., 136766=Steps 610 and 612 accomplish various initializations and preferably are sequentially interchangeable. As shown by step 610, the page value redo descriptive fields within the pin page descriptor selected by step 608 are set. As shown by APPENDIX 1, 46:1335, preferably the bitfile identification is set from the bit file identification parameter, while the relevant page number is set from the page parameter (code line 1337). In the presently preferred embodiment, an internal pin page function is called by code line 1322, which function acquires from disk (if necessary) the contents of the page for the page specified and for the bit file identified by the bit file identification using the access handle. Further, if necessary, this internal function reserves memory space for that page in the buffer cache, and returns a buffer cache address. The page adder referred to at code line 1323 preferably is an output parameter stored in the page descriptor, step 612., 181540=The present invention has a recovery granularity based upon a single log per domain. Thus in FIG. 12A, at step 1000, the routine has but one parameter to recover, namely the identify of the domain being recovered. In the preferred embodiment (APPENDIX 1, 74:246-248, a pointer to an internal structure describing the domain is passed, although in essence all that is needed is the domain identity per se., 189688=A \"yes\" determination at step 1044 means both tests have been passed, and the ftx structure (having served its purpose) may be deallocated and its space returned to a free list at step 1046 (see APPENDIX 1, 80:591-592. But if both current level and current member do not test as zero, the routine leads to step 1048., 135057=At shown by step 602, the rbf-- pinpg service obtains returned output parameters including a bitfile page handle and a page memory pointer, the relevant code for which is found at APPENDIX 1, 23:1251. Step 602 also returns input parameters including a bitfile identifier (preferably implemented in code as a handle to a structure that contains the bitfile identifier), a page number within that bitfile, and a handle to the ftx structure (ftxH). Step 604 preferably causes the routine to set an ftx pointer from an ftx handle lookup. This procedure is implemented from the ftx handle that is passed to provide a memory address for use as a reference., 185603=At step 1024, the routine provides an appropriate ftx handle for the ftx structure, and sets the temporary current level pointer to the internal per level structure in the ftx that is appropriate to current level line. See APPENDIX 1, 78:483-492. As shown by step 1026, the fields in the current level structure atomic r pass are set to the recovery pass field of the done record under consideration, and the member field in the current level structure is set to the member field in current done record. See APPENDIX 1,78:484-485., 190034=At this juncture, the log record (which is actually the next log record from step 1014, FIG. 12A) is tested to see whether it is the end of record (APPENDIX 1, 595). If at step 1048 the log record is not the end of record, then there must be another record and the routine branches to step 1012 (FIG. 12A) for further processing. But equality is determined at step 1014, then there are no more records to be read in the log, and at step 1050 the routine tests to see whether there are any allocated ftx structures., 149883=The routine at step 836 performs an important task, essentially describing the redo information by adding all page value redo descriptors to the log descriptor, thus logging the redo information. In APPENDIX 1, 37:791 an add done record redo subroutine is called, the subroutine appearing at APPENDIX 1, 55:1821-1864. At step 836, the routine causes the page value redo descriptor information, which was built-up with the sequence of pin-- page and pin-- record calls, to be described as part of the log record. These pin records are the redo information that, in conjunction with pin page information, describes what has been modified by this transaction., 186153=At step 1028 the routine tests whether this recovery pass is the first pass. If yes, and if the root done record count in the done record is not zero, if there is a record to buffer, buffering occurs in step 1030, wherein the root done record from the done record under consideration in the ftx structure is buffered, and the root done record count field in the ftx structure is incremented by one. See APPENDIX 1, 78:502-526, 79:527-529., 175331=In FIG. 11D, the routine at step 912 tests whether the recovery pass atomic r pass parameter was zero, the relevant code appearing in APPENDIX 1, 41:1022. If not zero, a further test is made at step 914 to determine if the specific atomic recovery pass parameter is less than the recovery pass parameter for the just-read record. If yes, the routine branches to step 934 in FIG. 11E, otherwise the routine continues to step 916. If the atomic recovery pass parameter is zero, the routine leads to step 918 to test whether the just-read record's level is less than the transaction structure's current level. If yes, the routine branches to step 934 in FIG. 11E where the sequence will eventually terminate., 186611=At this juncture, it is understood that the operation is presently on the first recovery pass and thus the current recovery pass is set to one. With respect to step 1032 in FIG. 12B, a test is now made to see whether the current recovery pass value is the same as the recovery pass field in the done record. If there is disagreement, the routine branches to step 1042 (FIG. 12C). However if the values are the same, the routine branches to step 1034 to test whether page redo data exists in this done record., 196823=Regardless of the outcome of the test at step 1080, the routine will go to step 1086 where the last log record field is initialized to the to the end of record. At step 1088, the routine copies the procedures of steps 836-846 (FIG. 10B), essentially creating a backlink since no backlink exists for the rootdone records in the log., 193761=In this fashion, partial trees associated with the current recovery pass level are undone. By systematically incrementing the recovery pass variable and making additional passes through the structure, eventually the routine will undo the entire tree. Step 1060 recognizes that the initial recovery passes may only undo part of the entire tree structure, and a finding of current level=0 implies that some level 0 done records have been written. This in turn implies that the present transaction must be completed, which means there may exist root done records requiring re-execution (APPENDIX 1, 80:646)., 26681=This is a division, of application Ser. No. 07/905,901 filed Jun. 26, 1992, now abandoned., 185171=Initialization for the specific log record just read occurs with step 1022, wherein the last log record field is set to the \"this log record\" address. The current level field in the ftx structure is set to the absolute value of the level in the done record. Taking the absolute value is necessary because some records are negative since undo can be logged as a negative value (APPENDIX 1, 78:481, 482)., 191825=With further reference to step 1050, if allocated ftx structures are determined to exist (e.g., step 1050 tests \"yes\"), these structures must be dealt with. The routine then branches and preferably sets up ftxp, ftxh, and current level pointers at step 1058 to better enable the routine to deal with the remaining ftx structures at the field level. At step 1060 the current level is tested and if not zero, the routine branches to step 1062 (see APPENDIX 1, 80:617)., 155060=After the ftx transaction is completely done, the routine at step 844 in FIG. 10B unpins all pages pinned at the start of the transaction by the rbf-- pinpg service depicted in FIG. 8, see APPENDIX 1, 57:1982. Unpinning allows these pages to be written back to persistent storage, a procedure not possible during pinning. Preferably the unpinned pages need not be immediately written to persistent storage., 136255=As shown by step 608, a pin page pointer (ppp.ptr) is set to an unused page descriptor for a page within a current level structure within the ftx structure of FIG. 6. Preferably there is an array of pre-allocated embedded descriptors to facilitate step 608 in accomplishing these essentially bookkeeping procedures. As shown in APPENDIX 1, 46:1306, within the current level, the number of pages that are pinned is incremented because the rbf-- pinpg service will pin another page., 182746=At step 1010, the routine sets a local log rec variable to the start record value, and at step 1012 a \"this log record\" variable is set equal to the log record before the log record was changed in step 1014., 182343=At step 1006, a start rec variable is set to the crash redo field address field found in the last log record that was read, an address that has been dutifully logged with every record. APPENDIX 1, 74:288 is the code for obtaining the start rec into the logger address. At step 1008, the recovery pass variable (r pass) is set to one for the first recovery pass. (APPENDIX 1, 75:303).}",
    "textBeforeTable": "Citations de brevets Modifications and variations may be made to the disclosed embodiments without departing from the subject and spirit of the invention as defined by the following claims. At step 1094 the routine tests whether the member number is zero. A non-zero member number implies that records were skipped because they were at an improper recovery pass level. However if for such skipped records, eventually the member number will be zero, whereupon the procedure is complete. Upon completion, at step 1096 the ftx structure (having served its purpose) is deallocated, and the routine loops back to step 1050 (FIG. 12C) to learn whether there are further incomplete ftx structures to be dealt with. At step 1090 the routine increments the root done count by one and tests at step 1092 whether now all root done records have been processed. If not, the routine branches back to step 1070 (FIG. 12D) for further processing. However if step 1092 determines all root done records have been executed, then the routine drops to step 1094. Regardless of the outcome of the test at step 1080, the routine will go to step 1086 where the last log record field is initialized to the to the end of record. At step 1088, the routine copies the procedures of steps 836-846 (FIG. 10B), essentially creating a backlink since no backlink exists for the rootdone records in the log. In FIG. 12E, as shown",
    "textAfterTable": "US5297279 * 30 mai 1990 22 mars 1994 Texas Instruments Incorporated System and method for database management supporting object-oriented programming US5335343 * 6 juil. 1992 2 ao\ufffdt 1994 Digital Equipment Corporation Distributed transaction processing using two-phase commit protocol with presumed-commit without log force US5369757 * 18 juin 1991 29 nov. 1994 Digital Equipment Corporation Recovery logging in the presence of snapshot files by ordering of buffer pool flushing * Cit\ufffd par l'examinateur R\ufffdf\ufffdrenc\ufffd par Brevet citant Date de d\ufffdp\ufffdt Date de publication D\ufffdposant Titre US5778168 * 11 sept. 1995 7 juil. 1998 Sun Microsystems, Inc. Transaction device driver technique for a journaling file system to ensure atomicity of write operations to a computer mass storage device US5832516 * 21 janv. 1997 3 nov. 1998 Oracle Corporation Caching data in recoverable objects",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}