{
    "relation": [
        [
            "Date",
            "May 18, 2001",
            "Nov 30, 2005",
            "Jul 28, 2008",
            "Dec 9, 2008",
            "Dec 9, 2008",
            "Dec 20, 2011",
            "Jun 8, 2012",
            "Jun 20, 2012"
        ],
        [
            "Code",
            "AS",
            "AS",
            "REMI",
            "FPAY",
            "SULP",
            "AS",
            "AS",
            "FPAY"
        ],
        [
            "Event",
            "Assignment",
            "Assignment",
            "Maintenance fee reminder mailed",
            "Fee payment",
            "Surcharge for late payment",
            "Assignment",
            "Assignment",
            "Fee payment"
        ],
        [
            "Description",
            "",
            "Owner name: JPMORGAN CHASE BANK, N.A., AS ADMINISTRATIVE AGENT Free format text: SECURITY AGREEMENT;ASSIGNOR:SS&C TECHNOLOGIES, INC.;REEL/FRAME:016824/0687 Effective date: 20051123",
            "",
            "Year of fee payment: 4",
            "",
            "Owner name: SS&C TECHNOLOGIES, INC., CONNECTICUT Free format text: RELEASE BY SECURED PARTY;ASSIGNOR:JPMORGAN CHASE BANK, N.A.;REEL/FRAME:027421/0417 Effective date: 20111215",
            "Owner name: DEUTSCHE BANK AG NEW YORK BRANCH, NEW YORK Free format text: SECURITY INTEREST;ASSIGNOR:SS&C TECHNOLOGIES, INC.;REEL/FRAME:028349/0827 Effective date: 20120314",
            "Year of fee payment: 8"
        ]
    ],
    "pageTitle": "Patent US20020035606 - Method and system for straight through processing - Google Patents",
    "title": "",
    "url": "http://www.google.com/patents/US20020035606?dq=6,373,753",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 14,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042981969.11/warc/CC-MAIN-20150728002301-00133-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 457981263,
    "recordOffset": 457943449,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{54886=[0001] This application is based upon, and claims the benefit of, U.S. Provisional Patent Application No. 60/205,372 filed on May 18, 2000, which is herein incorporated by reference in its entirety., 107780=[0089] Referring to FIG. 11, an overview of the XeMsg interface is presented. As previously stated, XeMsg 1114 is a component interface that may be utilized by applications to read and write data to XML messages. Depending on the circumstances, XML messages are read either from XML file 1102 stored, for example, in a database, or the XML messages are read off of a message queue 1104. Messages are then read by a queuing subsystem, internal to XeMsg, referred to as XeQ 1108., 105462=[0085] Referring to FIG. 10, a high level overview of the structure and function of an exemplary Xe enabled system is presented. These events are generated by a system 1002 and broadcast across the system's messaging bus 1004. Events are then intercepted by an Xe enabled application 1006 that is listening to the messaging bus 1004. An XML file containing case data 1008 relating to the specific even is loaded. The XML file 1008 contains the necessary parameters for XeMsg to determine which queue is next in the workflow process. After the application has manipulated the data it instructs XeMsg to place the message on the next queue 1010., 130002=[0130] After all the data has been written to the buffer 1510 and the XeML message is complete, it may be necessary for an application to create several outgoing XeML messages to be passed to the next application in the workflow process. An example of this would be where an application queries a database and a result set is returned. Here, each record in the result set is written to an individual XeML message. In this instance, the XeDoc object is cloned, 1514 then the data is written to the buffer 1510, with the process repeated for each record. In this fashion, an individual message is created for each record., 109259=[0092] Once XeDoc 1110 has read the file off of the buffer, the file is passed through an XML parser. As the XML data is parsed, it is loaded into an internal symbol table 1112. Keeping the parsed data in a symbol table 1112 within XeMsg 1114, as opposed to re-accessing the DOM every time the application needs workflow instructions or data, has an added speed advantage. This functionality further allows for the conversion of data to a more convenient and efficient internal form., 68595=[0033] Referring to FIG. 2, a sample workflow process that is required between the TMA 102 and PMA 106 applications is generally shown. TMA 102 purchases and allocates 1000 shares of \u2018ABC\u2019 corporation stock to various client portfolios 202. In response to this purchase and allocation, the PMA 106 database must be updated with these allocations 204., 108329=[0090] XeQ 1108 is responsible for handling XeMsg's interaction with the outside world, be it external files or an enterprise queuing system. XeQ 1108 is primarily responsible for interacting with an external queuing system to read in XML file that are waiting to be acted on. Once XeQ 1108 has read an XML file, it is placed in an internal buffer, which is then acted on by XeDoc 1110., 110460=[0094] The interface 1116 provides applications with several functions that may be utilized to access the instructions and data contained in the XeML message. The function set provides a condensed yet robust manner by which all necessary workflow, translation and state information can be accessed. The functionality is somewhat analogous to that provided by Reduced Instruction Set Chips (RISC), which allow for the same degree of functionality as Complex Instruction Set Chips (CISC) but through the use of fewer more powerful instructions. The use of a small instruction set allows for easier programming and less external processing is required to execute the instructions. For example, a typical Xe enabled service that listens to a queue would include the following lines of Xe function calls:, 121441=[0114] Referring to FIG. 12., the application will call the XeMsg initCase( ) function, passing the filename of the case document as a parameter to the function. The function causes XeQ 1204 to read in the XeML file 1202. The file is then passed off to XeDoc 1206, at which point the data file is placed in an internal buffer 1208. XeDoc 1206 also has an integrated XML parser 1210. The file is read out of the buffer 1208 and passed through the parser 1210. The data is then loaded into XeMsg's internal symbol tables 1212. As the parser reads tags from the file, the data contained in the XML tag is loaded into the appropriate data structure within the table 1212. The same process is executed when XeML data is read off a queue 1214. Instead of calling the initCase ( ) function, the application will utilize XeMsg's initQ( ) function, passing the queue name as the parameter to the function., 124137=[0117] Referring to FIG. 14, a workflow identifier contained in each XeML message's label is used to support threading 1402. For a particular workflow, Active Server Page instances 1404 that are Xe enabled are passed a workflow identifier in the URL (Unified Resource Locator). Each instance of an XeASP 1404 uses XeMsg to selectively remove messages form a shared input queue 1406 by referencing the unique identifier contained in the URL that is passed to it. All execution of business logic, such as interfacing with databases, is handled by the Xe enabled application. For example, an application might be a data access object responsible for logging into a database, executing a SQL query, and then placing the XeML message on the next queue to be acted on by the next application in the workflow process., 132671=[0134] In order for the current data being returned by the controlling application to be written to outgoing queue, the transaction must be \u201ccommitted\u201d, meaning all processing is complete and the application is ready to hand off its data to the next responsible application. This is accomplished by a call to commitTxn ( ). Referring once again to FIG. 15, after commitTxn ( ) is called and the transaction is committed, XeQ 1504 will take the file from each buffer 1510 and pass it to the message queue 1512 of the next application in the workflow process., 108787=[0091] The advantages of having files manipulated in a buffer, as opposed to accessing the data directly from its source file, is that the XeDoc 1110 subsystem does not need to be concerned with where the data originated, i.e., whether the data was read directly from a file or off of a queue. Furthermore, breaking XeMsg 1114 into separate subsystems results in making each component easier to modify and support., 134460=[0137] When a translation needs to be performed, translate ( ) will first resolve the proper map for the value of the right hand side of the equation 1602. After the proper map has been identified 1606, the data key identified by the map is located 1604. Since the value of the data key being mapped points to another map, the next map must be resolved. The next map 1608 and its associated data key 1610 are located. The value of the data key is resolved and the value mapped to is returned. In the example presented by FIG. 16, the value returned by the translate ( \u201cDst1\u201d ) function will be the value \u201cBuy\u201d., 129284=[0129] When the sendMessage ( ) function is called, XeMsg must take the data contained internally 1502 and write it out to the specified queue 1512. XeDoc 1506 will read data out of the internal symbol tables 1502 and pass it through its integrated parser 1508. The parser takes the data and parses it back into XML code that is placed on the XeDoc buffer 1510. Furthermore, the function will sequentially set the next latent stage to active and the currently active stage to latent. This assures that when the next application utilizes the getElement ( ) function for example, it will properly reference the correct workflow steps., 100403=[0075] This code will recursively evaluate the expression Src1 by first resolving Src2. Src2 will be resolved by multiplying the value of Sr5 and Src6, which equals 100,000. The value of Src2 will then be divided by 1000 to arrive at 100, which is then added to the value of Src3 to achieve a final result of 100. The arithmetic functionality may also be combined with the mapping function. For example, the following code:, 109814=[0093] When an application requests that XeMsg 1114 read or write data, the information contained in the internal symbol table 1112 is manipulated. After the application has completed working with the data, it uses the interface 1116 to instruct XeMsg as to the proper queue to next place the message 1106. XeDoc 1110 then reads the information from the internal symbol table 1112, reformats the data and places it in the buffer. Finally, XeQ 1108 reads the data out of the buffer and passes it off to the next queue 1106 in the workflow process., 106735=[0087] Another Xe enabled application 1022 then reads the XML data off its message queue 1020. This is the final step in the workflow process, and the application 1022 will be extracting and translating data used to enrich the message by application 1012. The extracted data, now in an appropriate format, is then passed to the end system 1024 where its internal business logic will take over., 106198=[0086] The next application 1012 in the process reads the XML file off the queue 1010 and extracts workflow information. This application accesses an ODBC compliant database 1016 and retrieves all information necessary to login and query the database from the XML message. After the query is complete, an individual message is created for each record in the result set 1018. The data is then written back to the XML message and placed on the next queue 1020., 69038=[0034] Referring to FIG. 3, this process could be broken down into stages as is shown. Two parallel workflow processes are initiated in response to TMA 102 allocating the 1000 shares of \u2018ABC\u2019 stock 308. The first workflow process with Stages 1A, 2A and 3A updates the PMA database with the allocations. The second workflow process with Stages 1B, 2B, 3B and 4B verifies that the PMA master file contains the information for the stock symbol allocated and updates the PMA master file if the information is not there. The type of information contained in the master file is company name and address as well as relevant financial data (e.g. dividends)., 122458=[0115] XeMsg pulls XeML messages from the queue in a number of ways. Referring to FIG. 13, a single queue 1302 is associated with an Xe enabled application 1304. When instructed, XeMsg will go to the identified queue 1302 and retrieve a single message 1306 off the queue to be processed. In other situations, an XeML message may be enriched with other types of XML data 1312, not in the XeML format. The Xe enabled application 1310 will query its associated queue 1308 and retrieve the XeML message and associated XML data 1312. Other configurations could include an Xe enabled application 1314 that sends one or more messages 1318 to a queue 1316. In addition, an Xe enabled application 1320 could send XeML messages 1322 to more than one queue 1324. FIG. 3 illustrates four of the possible configurations and is not meant to imply that other configurations are not possible.}",
    "textBeforeTable": "Patent Citations [0148] While preferred embodiments have been shown and described, various modifications and substitutions may be made thereto without departing from the spirit and scope of the invention. Accordingly, it is to be understood that the present invention has been described by way of illustrations and not limitation. [0147] As described above, the present invention can be embodied in the form of computer-implemented processes and apparatuses for practicing those processes. The present invention can also be embodied in the form of computer program code containing instructions embodied in tangible media, such as floppy diskettes, CD-ROM's, hard drives, or any other computer-readable storage medium, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention. The present invention can also be embodied in the form of computer program code, for example, whether stored in a storage medium, loaded into and/or executed by a computer, or transmitted over some transmission medium (embodied in the form of a propagated signal propagated over a propagation medium, with the signal containing the instructions embodied therein), such as over electrical wiring or cabling, through fiber optics, or via electromagnetic radiation, wherein, when the computer program code is loaded into an executed by a computer, the computer becomes an apparatus for practicing the invention. When implemented on a general-purpose microprocessor, the computer program code segments configure the",
    "textAfterTable": "US7337132 * Oct 17, 2001 Feb 26, 2008 Sun Microsystems, Inc. Customizable two step mapping of extensible markup language data in an e-procurement system and method US7386478 Oct 15, 2001 Jun 10, 2008 Sun Microsystems, Inc. Dynamic criteria based line-grouping mechanism and method for purchase order generation US7386567 Sep 30, 2004 Jun 10, 2008 Oracle International Corporation Techniques for changing XML content in a relational database US7406478 Aug 11, 2005 Jul 29, 2008 Oracle International Corporation Flexible handling of datetime XML datatype in a database system US7441249 * Nov 12, 2004 Oct 21, 2008 International Business Machines Corporation Activity monitoring without accessing a process object US7451110 May 18, 2001 Nov 11, 2008 Network Resonance, Inc. System, method and computer program product for providing an efficient trading market US7464154 May 18, 2001 Dec 9, 2008 Network Resonance, Inc. System, method and computer program product for analyzing data from network-based structured message stream",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}