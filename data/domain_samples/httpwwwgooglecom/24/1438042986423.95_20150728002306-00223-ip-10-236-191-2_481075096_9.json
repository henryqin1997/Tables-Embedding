{
    "relation": [
        [
            "Date",
            "Feb 6, 1987",
            "Aug 31, 1995",
            "Nov 23, 1999",
            "Apr 30, 2000",
            "Jul 11, 2000"
        ],
        [
            "Code",
            "AS",
            "FPAY",
            "REMI",
            "LAPS",
            "FP"
        ],
        [
            "Event",
            "Assignment",
            "Fee payment",
            "Maintenance fee reminder mailed",
            "Lapse for failure to pay maintenance fees",
            "Expired due to failure to pay maintenance fee"
        ],
        [
            "Description",
            "Owner name: AMERICAN TELEPHONE AND TELEGRAPH COMPANY, 550 MADI Free format text: ASSIGNMENT OF ASSIGNORS INTEREST.;ASSIGNOR:STRELIOFF, BRIAN K.;REEL/FRAME:004679/0165 Effective date: 19870206 Owner name: AT&T INFORMATION SYSTEMS INC., 100 SOUTHGATE PARKW Free format text: ASSIGNMENT OF ASSIGNORS INTEREST.;ASSIGNOR:STRELIOFF, BRIAN K.;REEL/FRAME:004679/0165 Effective date: 19870206",
            "Year of fee payment: 4",
            "",
            "",
            "Effective date: 20000428"
        ]
    ],
    "pageTitle": "Patent US5109329 - Multiprocessing method and arrangement - Google Patents",
    "title": "",
    "url": "http://www.google.com/patents/US5109329?dq=patent:6144888",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 9,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042986423.95/warc/CC-MAIN-20150728002306-00223-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 481113547,
    "recordOffset": 481075096,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{90435=Although far less usual than normal exceptions, another exception condition is possible when executing user-mode processes: system error. This category includes things like alignment faults and hardware problems encountered as a result of actions performed by slave processor 25. In these situations, the slave system error handler process flowcharted in FIG. 13 is invoked, at step 1100. It behaves exactly the same as the slave stack exception handler process of FIG. 12: the user process PCB is setup, at step 1101, so that execution on master processor 12 will commence with the instruction restart routine, and the process is then transferred to master processor 12 through invocation of the slave delete routine, at step 1102., 53027=Processors 12 and 25 each illustratively comprise an AT&T WE\ufffd 32100 microprocessor acting as the processor's central processing unit (CPU), two WE 32101 demand-paged memory management units (MMUs) and a WE 32106 math acceleration unit (MAU). These units are together labeled as 100. Though processors 12 and 25 share use of memory 13, each has on-board dedicated, or private, memory, labeled 101. I/O units 26-27 include a disk in support of demand-paged memory 13., 53750=To make clear the purpose and effect of the modifications, a brief overview of the conventional operation of the uniprocessor and of the desired operation of the multiprocessor is in order. A full description of the WE 32100 microprocessor may be found in \"UNIX\u2122 Microsystem WE\ufffd 32100 Microprocessor Information Manual\" published by Document Development Organization-Microelectronics Projects Group, AT&T Technologies, Inc., Morristown, N.J. Hence, a brief description is presented below only of certain aspects of the operation that are deemed necessary for a full appreciation of the illustrative embodiment of the invention., 54411=Typically, the 3B15 system uses two modes, or levels, of operation of the WE 32100 ; microprocessor: a user mode for executing user program instructions, and a privileged mode for executing functions such as operating system instructions that have the potential for corrupting shared system resources such as hardware resources. There are two mechanisms for entering privileged mode from user mode: a process switch mechanism and a system call mechanism. The system call mechanism is also known by names such as a supervisory call and an operating system trap., 88441=FIG. 12 flowcharts the slave stack exception handler process. Given that minimal privileged-mode processing is implemented on slave processor 25 (no privileged mode processing is done on slave processor 25 on behalf of user processes), the action performed by the slave stack exception handler is to transfer the presently-executing user process to master processor 12. This is implemented by calling a slave delete routine (see FIG. 15), at step 1002. Illustratively in this example, because the address of the faulting instruction is already saved in the process control block as result of stack exception handling, the faulting instruction is reexecuted once the process restarts execution on master processor 12. This feature is fairly typical of systems with demand-paged memory management. This results in repeating whatever actions caused the original fault on slave processor 25, therefore avoiding the need for the slave stack exception handler to preserve potential fault indicators and the master exception handling routines to look for the saved potential fault indicators., 92901=Preserving the status for the present process is essentially completed by the time the slave delete routine is called: all paths leading to invocation of the slave delete routine result in the saving of the required CPU-related registers in the process control block for the presently-executing slave process. However, the process control block only defines the hardware context of a process, but does not define the software-maintained information for the process, such as MAU register contents. Hence, the software-defined state must be saved in the process' PCB, at step 1301. Also, the SONSLAVE flag is reset in the p-- flag field. This leaves only restoration of the actual value of stack upper bound 218 to be performed, at step 1302., 85094=If there are no asynchronous signals pending for the presently-executing process, as determined at step 807, a check is made for whether the just-completed incrementing of the time accumulators for the process resulted in a p-- slice counter value greater than the system time-slice threshold, at step 809. If so, the context information of the presently-executing process is stored in that process' process control block, at step 810, the stack bounds 217, 218 of the process are restored to their correct value (see step 1302 of FIG. 15), at step 811, the slave add routine of FIG. 8 is called to link the presently-executing process back to the slave processor 25 run queue, at step 812, and then a process switch is forced on slave processor 25 by calling the slave process switch routine of FIG. 11, at step 813., 91187=The instruction restart routine is flowcharted in FIG. 14. This routine is invoked, at step 1200, on master processor 12 whenever a process that was transferred from slave processor 25 due to occurrence of an exception or an interrupt begins to execute on master processor 12. The routine checks whether the faulting instruction is a non-restartable instruction, at step 1201, such as an MAU instruction with destructive operand overlap, and if so, it corrects the restart problems, at step 1202. The routine uses existing routines to handle restartability problems in the same manner as the standard, master, stack exception handler deals with MAU restart problems. The instruction restart routine then restores the address of the user process' faulted instruction to the process control block of the faulted process to cause execution of the faulted instruction, at step 1203, and returns at step 1204 to execution of that instruction., 72033=Memory management information for the slave is also prepared at step 403. Since the kernel mapping is common for all processors, the MMU register contents will be common for all operating system kernel sections. However, access to MMUs on slave processor 25 is not possible from master processor 12 (and vice versa), and therefore the actual initialization of the MMU mapping register contents must be performed by slave processor 25. One technique for accomplishing this is to make use of the block-move capability of the microprocessor. This involves initializing a series of block move areas in the initial slave process control block such that when a process switch to the slave's initial process control block is performed, the MMU mapping registers will be automatically initialized as part of the XSWITCH-THREE() macro-ROM sequence of the microprocessor (see the WE 32100 Microprocessor Information Manual)., 92144=FIG. 15 flowcharts the slave delete routine. This routine is invoked on slave processor 25 whenever it is deemed necessary to transfer a process presently executing on slave processor 25 to the master processor 12 run queue. As mentioned above, this situation can be the result of either an asynchronous signal having been posted for a presently-executing process (see step 808 of FIG. 9), or the presently-executing slave process having need of- privileged-mode processing (see step 1002 of FIG. 12 and step 1102 of FIG. 2). In either case, the actions performed are the same: preserve present status of the process, add the present process to master processor 12 run queue, and select a new process for execution on slave processor 25., 89546=However, not all instructions may be reexecuted safely in this illustrative embodiment: for example, certain multiword MAU instructions with destructive operand overlap may not be restartable if a partial destination operand update has been done before the exception, thereby corrupting a source operand. Therefore, when the process is restarted on master processor 12, an instruction restart routine (see FIG. 14) must be invoked to avoid restart problems. This is illustratively accomplished, at step 1001, by removing the address of the faulting instruction from the process control block and substituting therefor the starting address of the instruction restart routine, and storing the removed faulting instruction's address in a variable. When the instruction restart routine completes, it restores the faulting instruction's address in the process control block., 93672=Once this has been accomplished, the process is added to master processor 12 run queue through invocation of the standard setrq() routine, at step 1303, and a new process is chosen for execution on slave processor 25 through invocation of the slave process switch routine of FIG. 11, at step 1304., 95221=FIG. 17 flowcharts the slave idle routine, which is invoked, at step 1500, on slave processor 25 if no processes are available for execution on slave processor 25. This routine resets slave processor 25 interrupt stack pointer, at step 1501, lowers the interrupt priority level (set high by hardware operations preceding invocation of the slave stack exception handler) in the program status word to the lowest level to allow all interrupts, at step 1502, and executes a WAIT instruction, at step 1503. Upon occurrence of an interrupt, execution on slave processor 25 is resumed at the slave interrupt routine of FIGS. 9 and 10., 82510=If the interrupt was not due to expiration of a time interval, the first action performed is a check of a flag variable, at step 802, to see if master processor 12 is trying to reclaim memory. If so, the execution of processes on slave processor 25 is suspended until the reclamation has completed. This is necessary since there exists a potential corruption problem if the reclamation processing modifies a page descriptor that is resident in the slave processor 25 MMU descriptor caches: there is no technique for informing slave processor 25 of the change in the descriptor, and therefore slave processor 25 will be using obsolete mapping information. Once reclamation is completed, stack bounds 217, 218 of the process that is presently executing on slave processor 25 are restored to their correct value (see step 1302 of FIG. 15), at step 803, and a process switch is forced on slave processor 25 by calling a slave process switch routine (see FIG. 11), at step 804. The slave process switch routine ensures that MMU mapping registers are loaded with new information, which also has the beneficial effect of flushing the potentially-corrupt MMU cache descriptor entries., 93989=FIG. 16 flowcharts the slave process steal routine, which is invoked on master processor 12 at the start of the pswtch() routine. The pswtch() routine calls the slave process steal routine, at step 1400, to avoid situations where master processor 12 run queue is empty and master processor 12 sits idle, at step 1401, and there exists a backlog of user-mode processes on slave processor 25 run queue, at step 1402. This routine simply takes a process off of slave processor 25 run queue, following the same process selection algorithm as the slave process switch routine of FIG. 11, and moves the process to master processor 12 run queue, at step 1403. Following step 1403, or if master processor 12 run queue is not found to be empty at step 1401, the routine returns to the pswtch() routine, at step 1404, to select a process from master processor 12 run queue for execution on master processor 12. If the master processor 12 run queue is found to be empty, at step 1401, and the slave processor 25 run queue is also found to be empty, at step 1402, the routine idles master processor 12, at step 1405, by execution of a standard WAIT instruction. Master processor 12 then waits for occurrence of an interrupt.}",
    "textBeforeTable": "Patent Citations Of course, it should be understood that various changes and modifications to the illustrative embodiment described above will be apparent to those skilled in the art. For example, the AT&T 3B2 uniprocessor computer and other uniprocessor computers may be expanded to a multiprocessor configuration in like manner. Also, more than one slave processor may be added to and used in the system, in substantially the same manner as the one slave processor is added and used. Furthermore, slave processors need not be identical to each other or to the master processor, but each may be based on a different microprocessor, but each may be based on a different microprocessor architecture. Such changes and modifications can be made without departing from the spirit and the scope of the invention and without diminishing its attendant advantages. It is therefore intended that all such changes and modifications be covered by the following claims. FIG. 17 flowcharts the slave idle routine, which is invoked, at step 1500, on slave processor 25 if no processes are available for execution on slave processor 25. This routine resets slave processor 25 interrupt stack pointer, at step 1501, lowers the interrupt priority level (set high by hardware operations preceding invocation of the slave stack exception handler) in the program status word to the lowest level to allow all interrupts, at step 1502, and executes a WAIT instruction, at step 1503. Upon occurrence of an",
    "textAfterTable": "DE3105527A1 * Feb 16, 1981 Sep 9, 1982 Theodor Dr Tempelmeier Method for improving the response time characteristic of process computers * Cited by examiner Non-Patent Citations Reference 1 * G. H. Goble & M. H. Marsh, A Dual Processor VAX 11/780, (Purdue University, TR EE81 31, Sep. 1981). 2 G. H. Goble & M. H. Marsh, A Dual Processor VAX 11/780, (Purdue University, TR-EE81-31, Sep. 1981). 3 * M. J. Bach, The Design of the Unix Operating System, (Prentice Hall, Inc., 1986) pp. 391 411. 4 M. J. Bach, The Design of the Unix\u2122 Operating System, (Prentice-Hall, Inc., 1986) pp. 391-411. 5 P. A. Grasso et al., \"Operating System for a Dedicated Common Memory Multimicroprocessor System\", IEE Proceedings, vol. 129, Pt. E., No. 5 (Sep. 82), pp. 200-205. 6 * P. A. Grasso et al., Operating System for a",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}