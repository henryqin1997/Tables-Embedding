{
    "relation": [
        [
            "Citing Patent",
            "US7661090 *",
            "US7673284 *",
            "US8087012 *",
            "US8136107 *",
            "US8418155 *",
            "US8627304 *",
            "US8713549 *",
            "US8839219 *",
            "US8862827",
            "US8954943",
            "US20100205580 *",
            "US20110029962 *",
            "US20130117548 *",
            "US20130151822 *",
            "US20130167130 *"
        ],
        [
            "Filing date",
            "Jan 11, 2006",
            "Jan 17, 2006",
            "Aug 21, 2007",
            "Oct 24, 2007",
            "Feb 10, 2009",
            "Jul 28, 2009",
            "Sep 7, 2012",
            "Oct 24, 2012",
            "Dec 29, 2009",
            "Jan 26, 2006",
            "Feb 10, 2009",
            "Jul 28, 2009",
            "",
            "Dec 9, 2011",
            "Oct 24, 2012"
        ],
        [
            "Publication date",
            "Feb 9, 2010",
            "Mar 2, 2010",
            "Dec 27, 2011",
            "Mar 13, 2012",
            "Apr 9, 2013",
            "Jan 7, 2014",
            "Apr 29, 2014",
            "Sep 16, 2014",
            "Oct 14, 2014",
            "Feb 10, 2015",
            "Aug 12, 2010",
            "Feb 3, 2011",
            "May 9, 2013",
            "Jun 13, 2013",
            "Jun 27, 2013"
        ],
        [
            "Applicant",
            "Dell Products L.P.",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "Nvidia Corporation",
            "International Business Machines Corporation",
            "International Business Machines Corporation"
        ],
        [
            "Title",
            "Task generation runtime engine",
            "Method and system for versioning codes based on relative alignment for single instruction multiple data units",
            "Eliminating maximum/minimum operations in loop bounds",
            "Software pipelining using one or more vector registers",
            "Generating parallel SIMD code for an arbitrary target architecture",
            "Vectorization of program code",
            "Vectorization of program code",
            "Data prefetching and coalescing for partitioned global address space languages",
            "Efficient multi-level software cache using SIMD vector permute functionality",
            "Analyze and reduce number of data reordering operations in SIMD code",
            "Generating parallel simd code for an arbitrary target architecture",
            "Vectorization of program code",
            "Algorithm for vectorization and memory coalescing during compiling",
            "Efficient Enqueuing of Values in SIMD Engines with Permute Unit",
            "Data Prefetching and Coalescing for Partitioned Global Address Space Languages"
        ]
    ],
    "pageTitle": "Patent US7386842 - Efficient data reorganization to satisfy data alignment constraints - Google Patents",
    "title": "",
    "url": "http://www.google.com/patents/US7386842?dq=6,977,809&ei=-AObT5vAOoSgiQL_5qznDg",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 7,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438043058631.99/warc/CC-MAIN-20150728002418-00028-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 471660143,
    "recordOffset": 471620962,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{6548=FIG. 11 is a flowchart representation of a process of simdizing a loop in accordance with a preferred embodiment of the present invention. First, a na\ufffdve vectorized representation (e.g., FIG. 3A) of the loop is obtained without regard for the alignment or mis-alignment of the various memory streams involved (block 1100). Next, a realignment graph is generated from the na\ufffdve vectorization by inserting shiftstream operations into the graph (block 1102). Next, a determination is made as to whether a alignment policy may be applied to the graph to optimize the resulting code (block 1104). If so (block 1104: Yes), then the policy is applied (block 1106) and the process returns to block 1104, to determine if additional policies may be applied to further optimize the graph. If not (block 1104:No), simdized code is generated from the optimized graph using an approach such as is described in Section 5 of this Detailed Description.}",
    "TableContextTimeStampAfterTable": "{40562=In a preferred embodiment, simdization occurs after several loop transformations such as loop interchange and loop distribution that enhance simdization by removing loop-carried dependences along innermost loops. It is followed by other loop transformations that can significantly improve the quality of the simdized codes, notably loop unrolling that removes needless copy operations and a special form of common subexpression elimination, referred to as Predictive Commoning (PC) which exploits the reuse among consecutive loop iterations. See O'BRIEN, Kevin. Predictive Commoning: A Method of Optimizing Loops Containing References to Consecutive Array Elements. In IBM Interdivisional Technical Liaison, 1990. The back-end code generator (TOBEY) has been extended to target a PowerPC-based processor with SIMD vector units. It performs various target-specific optimizations including instruction scheduling and register allocation., 29740=Another work that is of note, but which is in the area of compiling for distributed memory systems as opposed to SIMD architectures, is CHATTERJEE, Siddhartha, et al. Modeling Data-Parallel Programs with the Alignment-Distribution Graph. J. of Programming Languages. 1994, vol. 2, no. 3, pp. 227-258., 22790=Although vectorization has been studied extensively for traditional vector processors decades ago, vectorization for SIMD architectures has raised new issues due to several fundamental differences between the two architectures. See, e.g. , Ren, Gang, et al. A Preliminary Study on the Vectorization of Multimedia Applications. In 16th International Workshop of Languages and Compilers for Parallel Computing. October. 2003. To distinguish between the two types of vectorization, we refer to the latter as simdization. One such fundamental difference comes from the memory unit. The memory unit of a typical SIMD processor bears more resemblance to that of a wide scalar processor than to that of a traditional vector processor. In the ALTIVEC instruction set found on certain POWERPC microprocessors (produced by International Business Machines Corporation and Motorola, Inc.), for example, a load instruction loads 16-byte contiguous memory from 16-byte aligned memory, ignoring the last 4 bits of the memory address in the instruction. The same applies to store instructions. Herein, architectures with alignment constraints refer to machines that support only loads and stores of register-length aligned memory., 80662=Since Equation (10) computes the lower bound using the alignment of the store, it is not applicable to loops with statements of distinct store alignments. The key observation to address this issue is that we do not need.to compute the \u201cprecise\u201d lower bound for each statement, as long as each memory operation loads and stores the right data. This is based on the assumption that the loop counter only appears in address computation. Recall that vector memory instructions implicitly truncate the address as they access only aligned data. For example, on AltiVec, loads from addresses 0x1000, 0x1001 or 0x100E each load the same 16 bytes of data starting at 0x1000., 28976=An interesting simdization scheme using indirect register accesses is discussed in the aforementioned NAISHLOS, et al. reference. However, their method is specific to the eLite processor, which supports more advanced vector operations (such as gather and scatter operations) than are available on typical MME processors. In SHIN, Jaewook, et al. Compiler-Controlled Caching in Superword Register Eiles for Multimedia Extension Architectures. In Proceedings of International Conference on Parallel Architectures and Compilation Techniques. September. 2002, register packing and shifting instructions were used to exploit temporal and spatial reuse in vector registers. However, their work does not address alignment handling., 95831=Peripheral devices and input/output (I/O) devices can be attached to various interfaces (e.g., parallel interface 1262, serial interface 1264, keyboard interface 1268, and mouse interface 1270 coupled to ISA bus 1240. Alternatively, many I/O devices can be accommodated by a super I/O controller (not shown) attached to ISA bus 1240., 96239=In order to attach computer system 1201 to another computer system to copy files over a network, LAN card 1230 is coupled to PCI bus 1210. Similarly, to connect computer system 1201 to an ISP to connect to the Internet using a telephone line connection, modem 1275 is connected to serial port 1264 and PCI-to-ISA Bridge 1235., 26806=A very extensive discussion of alignment considerations is provided by LARSON, Samuel, et al. Increasing and Detecting Memory Address Congruence. In Proceedings of 11th International Conference on Parallel Architectures and Compilation Techniques. September 2002. However, LARSON is concerned with the detection of memory alignments and with techniques to increase the number of aligned references in a loop, whereas the present application focuses on generating optimized SIMD codes in the presence of misaligned references. The two approaches are complementary. The use of loop peeling to align accesses was discussed in LARSON as well as in the aforementioned BIK reference. The loop peeling scheme is equivalent to the eager-shift policy with the restriction that all memory references in the loop must have the same misalignment. Even under this condition, the scheme presented herein has the advantage of generating simdized prologue and epilogue, which is the by-product of peeling from the simdized loop., 94614=PCI bus 1214 provides an interface for a variety of devices that are shared by host processor(s) 1200 and Service Processor 1216 including, for example, flash memory 1218. PCI-to-ISA bridge 1235 provides bus control to handle transfers between PCI bus 1214 and ISA bus 1240, universal serial bus (USB) functionality 1245, power management functionality 1255, and can include other functional elements not shown, such as a real-time clock (RTC), DMA control, interrupt support, and system management bus support. Nonvolatile RAM 1220 is attached to ISA Bus 1240. Service Processor 1216 includes JTAG and I2C busses 1222 for communication with processor(s) 1200 during initialization steps. JTAG/I2C busses 1222 are also coupled to L2 cache 1204, Host-to-PCI bridge 1206, and main memory 1208 providing a communications path between the processor, the Service Processor, the L2 cache, the Host-to-PCI bridge, and the main memory. Service Processor 1216 also has access to system power resources for powering down information handling device 1201., 27865=Direct code generation for misaligned references have been discussed by several prior works. The vectorization of misaligned loads and stores using the VIS instruction set is described in CHEONG, Gerald, et al. An Optimizer for Multimedia Instruction Sets. In Second SUIF Compiler Workshop. August. 1997. The aforementioned BIK, et al. reference described a specific code sequence of aligned loads and shuffle to load memory references that cross cache line boundaries, which is implemented in Intel's compiler for SSE2. However, their method is not discussed in the context of general misalignment handling., 24044=There has been a recent spike of interest in compiler techniques to automatically extract SIMD parallelism from programs. See, e.g., LARSEN, Samuel, et al. Exploiting Superword Level Parallelism with Multimedia Instruction Sets. In Proceedings of SIGPLAN Conference on Programming Language Design and Implementation. June. 2000, pp. 145-156; BIK, Aart, et al. Automatic Intra-Register Vectorization for the Intel Architecture. Int. J. of Parallel Programming. April. 2002, vol. 30, no. 2, pp. 65-98; KRALL, Andreas, et al. Compilation Techniques for Multimedia Processors. Int. J. of Parallel Programming. August. 2000, vol. 28, no. 4, pp. 347-361; SRERAMAN, N., et al. A Vectorizing Compiler for Multimedia Extensions. Int. J. of Parallel Programming, August. 2000, vol. 28, no. 4, pp. 363-400; LEE, Corinna G., et al. Simple Vector Microprocessors for Multimedia Applications. In Proceedings of International Symposium on Microarchitecture. 1998, pp. 25-36; and NAISHLOS, Dorit, et al. Vectorizing for a SIMD DSP Architecture. In Proceedings of International Conference on Compilers, Architectures, and Synthesis for Embedded Systems. October. 2003, pp. 2-11. This upsurge was driven by the increasing prevalence of SIMD architectures in multimedia processors. Two principal techniques have been used, the traditional loop-based vectorization pioneered for vector supercomputers (e.g., ALLEN, John Randal, et al. Automatic Translation of Fortran Programs to Vector Form. ACM Transactions on Programming Languages and Systems. October. 1987, vol. 4, pp. 491-542; and ZIMA, Hans, et al. Supercompilers for Parallel and Vector Computers. Reading, MA: Addison-Wesley/ACM Press, 1990. ISBN 0201175606.) and the unroll-and-pack approach first proposed by Larsen and Amarasinghe in LARSEN, Samuel, et al. Exploiting Superword Level Parallelism with Multimedia Instruction Sets. In Proceedings of SIGPLAN Conference on Programming Language Design and Implementation. June. 2000, pp. 145-156.}",
    "textBeforeTable": "Patent Citations While particular embodiments of the present invention have been shown and described, it will be obvious to those skilled in the art that, based upon the teachings herein, that changes and modifications may be made without departing from this invention and its broader aspects. Therefore, the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore, it is to be understood that the invention is solely defined by the appended claims. It will be understood by those with skill in the art that if a specific number of an introduced claim element is intended, such intent will be explicitly recited in the claim, and in the absence of such recitation no such limitation is present. For non-limiting example, as an aid to understanding, the following appended claims contain usage of the introductory phrases \u201cat least one\u201d and \u201cone or more\u201d to introduce claim elements. However, the use of such phrases should not be construed to imply that the introduction of a claim element by the indefinite articles \u201ca\u201d or \u201can\u201d limits any particular claim containing such introduced claim element to inventions containing only one such element, even when the same claim includes the introductory phrases \u201cone or more\u201d or \u201cat least one\u201d and indefinite articles such as \u201ca\u201d or \u201can\u201d; the same holds true for the use in the claims",
    "textAfterTable": "US7020873 Jun 21, 2002 Mar 28, 2006 Intel Corporation Apparatus and method for vectorization of detected saturation and clipping operations in serial code loops of a source program US7168069 Jul 12, 2000 Jan 23, 2007 Stmicroelectronics, Inc. Dynamic generation of multimedia code for image processing US7219212 Feb 25, 2005 May 15, 2007 Tensilica, Inc. Load/store operation of memory misaligned vector data using alignment register storing realigned data portion for combining with remaining portion US7275147 Mar 31, 2003 Sep 25, 2007 Hitachi, Ltd. Method and apparatus for data alignment and parsing in SIMD computer architecture US20030120889 Dec 21, 2001 Jun 26, 2003 Patrice Roussel Unaligned memory operands US20030167460 Feb 26, 2002 Sep 4, 2003 Desai Vipul Anil Processor instruction set simulation power estimation method US20030204840 Apr 30, 2002 Oct 30, 2003 Youfeng Wu Apparatus and method for one-pass profiling to concurrently generate a frequency profile and a stride profile to enable data prefetching in irregular programs US20040001066",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}