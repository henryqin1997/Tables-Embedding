{
    "relation": [
        [
            "Date",
            "Feb 3, 1998",
            "Jun 14, 2004",
            "Jun 12, 2008",
            "Jul 23, 2012",
            "Dec 12, 2012",
            "Jan 29, 2013"
        ],
        [
            "Code",
            "AS",
            "FPAY",
            "FPAY",
            "REMI",
            "LAPS",
            "FP"
        ],
        [
            "Event",
            "Assignment",
            "Fee payment",
            "Fee payment",
            "Maintenance fee reminder mailed",
            "Lapse for failure to pay maintenance fees",
            "Expired due to failure to pay maintenance fee"
        ],
        [
            "Description",
            "Owner name: UNIVERSITY OF IOWA RESEARCH FOUNDATION, THE, IOWA Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:RAMKUMAR, BALKRISHNA;STRUMPEN, VOLKER;REEL/FRAME:008980/0518;SIGNING DATES FROM 19980122 TO 19980128",
            "Year of fee payment: 4",
            "Year of fee payment: 8",
            "",
            "",
            "Effective date: 20121212"
        ]
    ],
    "pageTitle": "Patent US6161219 - System and method for providing checkpointing with precompile directives and ... - Google Patents",
    "title": "",
    "url": "http://www.google.com/patents/US6161219?dq=7350717",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 9,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042987628.47/warc/CC-MAIN-20150728002307-00106-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 462232115,
    "recordOffset": 462182801,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{134089=The method proceeds from step 2340 to step 2350 which involves executing the code on a particular processing platform. During execution step 2350, the method determines which of the portable checkpoints will actually be implemented, for example, based upon a MinTBC (Minimum Time Between Checkpoints)., 43698=This invention relates generally to a method and apparatus for portable checkpointing and specifically to a method and apparatus for pre-compiling user software, written in a general-purpose programming language, to enable portable checkpoints in a Universal Checkpoint Format (UCF). Some of the concepts related to this invention are disclosed in the following two reports by the inventors: Volker Strumpen, Balkrishna Ramkumar, Portable Checkpointing and Recovery in Heterogeneous Environments, Dept. of Electrical and Computer Engineering, University of Iowa, Technical Report No. 96-61-1, June 1996 and B. Ramkumar and V. Strumpen, Portable Checkpointing for Heterogeneous Architectures, Proceedings of the 27th Fault-Tolerant Computing Symposium, Jun. 25-27, 1997. Both of these reports are incorporated herein by reference., 47936=The problem of reliability in computing systems has been studied in many different forms. The evaluation of the performability of degradable computing systems was first addressed in a seminal paper by Myer, J. F. On evaluating the performability of degradable computing systems, IEEE Transactions on Computers, 29(8):720-731, August 1980., 133537=The method proceeds from step 2330 to step 2340 which involves compiling the output source code to produce object code. It is important to note that by performing the addition of support for portable checkpointing in pre-compile step 2330 rather than in compile step 2340, the method has achieved independence from the specific machine object code. In other words, by inserting the support for portable checkpoints during the source-to-source pre-compile step 2330, the method is interoperable with a variety of different compilers., 52434=The issue of portability across heterogeneous architectures has been addressed in the language community (Franz M. Kaashoek Code generation on the Fly: A Key to Portable Software. PhD thesis, Institute for Computer Systems, ETH Zurich, 1994 and Gosling J. The Java Language Environment. Technical Report, Sun Microsystems, Mountain View, Calif., 1995. white paper. Languages like Java provide an interpreter-based approach to portability where the program byte code is first \"migrated\" to the client platform for local interpretation. Unfortunately, such methods severely compromise performance since they run at least an order of magnitude slower than comparable C programs. Another possibility is \"compilation on the fly\" which provide portability by compiling the source code on the desired target machine immediately prior to execution. This technique requires the construction of a complex language environment. Moreover, to date neither interpreter-based systems nor compilation on the fly are explicitly designed to support fault tolerance., 138703=The method proceeds from step 2530 to step 2540 which involves resuming execution from the point in the code where the last portable checkpoint was taken., 133017=The method proceeds from step 2320 to step 2330 which involves pre-compiling the input source code, from step 2320, to produce output source code which includes support for portable checkpointing. The locations of the included support for portable checkpointing is related to the markers which were inserted in step 2320. Since marker insertion step 2320 could be implemented with a pre-compiler, in one embodiment of the invention, steps 2320 and 2330 can be combined into a single pre-compile step., 136171=FIG. 24 shows a method for selectively activating portable checkpoints at the next potential checkpoint marker, according to a preferred embodiment of the invention. As the code is executed, step 2410 selectively activates portable checkpointing at the next potential checkpoint marker. The method proceeds from step 2410 to step 2415 which involves saving the portable checkpoint to stable storage. The method proceeds from step 2415 to step 2420 which involves waiting MinTBC (Minimum Time Between Checkpoints) while program execution continues. This wait can be implemented, for example, by using a timer. If potential checkpoint markers are encountered during wait step 2420, they are ignored and not implemented., 55458=Zhou et al (Zhou S., Stumm M., Li K., Wortman D. Heterogeneous Distributed Shared Memory. IEEE Transactions on Parallel and Distributed Systems, 3 no. 5:540-554, September 1992) describe the Mermaid system for distributed shared memory on heterogeneous systems. This system is not fault tolerant, but generates data representation conversion routines automatically for all shared memory objects. This paper provides a detailed treatment on conversion. A major difference from the present invention is the conversion code generation for complex data types. Whereas Mermaid uses \"utility software\" to generate this code, the present invention utilizes the information provided by the abstract syntax tree to this end. Another design decision of Mermaid is the dedication of a page of memory to a particular data type. Although the authors defend this method in the context of dynamically allocated shared memory, such an organization is clearly impractical for the runtime stack, which has to be converted too when saving a checkpoint. Moreover, the poor data locality caused by this data organization is likely to result in a significant loss in performance., 49116=There has also been work in optimizing the checkpointing and recovery process. Beck M., Plank J. S., Kingsley G. Compiler-assisted checkpointing. Technical Report CS-94-269, University of Tennessee, December 1994. submitted to FTCS 95. Beck et al classify checkpointing optimizations into two categories: latency hiding optimizations and memory exclusion optimizations. Latency hiding optimizations make a copy of the checkpoint in main memory and overlap the task of writing the checkpoint to stable storage with useful computation. Compression algorithms have been used to reduce the amount of data to be checkpointed, although it has been shown that compression is only beneficial in systems exhibiting contention for secondary storage., 91279=The basic approach for saving the variables on the stack is to visit each stack frame, and save its local variables identified at pre-compile time. A preferred embodiment would only save the live variables determined by data-flow analysis. The stack is checkpointed by returning the active function call sequence, thereby visiting each individual stack frame starting from the top of the stack down to the bottom. For each stack frame visited, the state of the local variables is pushed onto the shadow stack. The stack must then be restored by executing the original function call sequence again. c2ftc generates code to access each local variable by name rather than block-copying the stack. This eliminates problems caused by non-portable implementations based on setjmp/longjmp pairs, as for example used in libckpt, as disclosed in Plank, J. S., Beck M., Kingsley G., Li K. Libckpt: Transparent Checkpointing under Unix. In Proceedings of the Unix Winter Technical Conference, San Francisco, Calif., January 1995 which is incorporated herein by reference., 132349=FIG. 23A shows a method of pre-compiling input source code and outputting an output source code which includes support for portable checkpointing, according to a preferred embodiment of the invention. The input for the method is original source code 2310 which can be written in any general purpose language (e.g., C, C++, Fortran, Java, etc.). Original source code 2310 is input to step 2320 which involves inserting markers for potential portable checkpointing. Step 2320 can be implemented by a programmer who manually inserts portable checkpointing markers, or alternatively, it can be implemented automatically, for example, by a pre-compiler., 137344=FIG. 24 also includes a further embodiment of the invention (shown with the dashed line) in which step 2410 proceeds to steps 2415 and 2420 approximately at the same time. This method is a non-blocking method in which wait step 2420 does not have to wait for completion of save step 2415., 138517=The method proceeds for step 2520 to step 2530 which involves restoring the data/bss, heap segment, and stack from the shadow stack in to their appropriate locations., 48294=Reliable computing has also received attention in the context of parallel and distributed systems, ranging from hardware and/or interconnection network-specific solutions, language specific solutions, algorithm-specific solutions to application-specific solutions. A good survey of checkpointing and rollback techniques can be found in: (1) Deconinck, G. Vounckx J., Cuyvers R., Lauwereins R., Survey of Checkpointing and Rollback Techniques. Technical Report 03.1.8 and 03.1.12, ESAT-ACAA Laboratory, Katholieke Universiteit, Leuven, Belgium, June 1993 and (2) Elnozahy E. N., Johnson D. B., Wang Y. M. A Survey of Rollback-Recovery Protocols in Message-Passing Systems. Computing Surveys, 1996. (submitted), Also Technical Report CMU-CS-96-181, School of Computer Science, Carnegie Mellon University., 134777=Original source code is input to the marker inserter which inserts markers for potential portable checkpointing. The output of marker inserter 2360 is input source code which is input to pre-compiler 2370. Pre-compiler 2370 which pre-compiles the input source code to produce output source code which includes support for portable checkpointing., 134410=FIG. 23B shows an apparatus 2355 for pre-compiling input source code and outputting an output source code which includes support for portable checkpointing, according to a preferred embodiment of the invention. Apparatus 2355 includes a marker inserter 2360 and a pre-compiler 2370. In addition, apparatus 2355 can further include a compiler 2380., 135142=In a further embodiment, apparatus 2355 can include compiler 2380 which receives the output source code from pre-compiler 2370 and compiles the output source code to produce object code., 56645=Seligman and Beguelin (Seligman E., Beguelin A. High-Level Fault Tolerance in Distributed Programs. Technical Report CMU-CS-904-223, Carnegie Mellon University, December 1994) have developed checkpointing and restart methods in the context of the Dome C++ environment. Dome provides checkpointing at multiple levels, ranging from high level user-directed checkpointing that sacrifices transparency for portability and low overhead, to low level checkpointing that is transparent but results in non-portable code and requires larger checkpoints. Dome's checkpointing is designed for portability, but requires that the program be written in the form of a main loop that computes and checkpoints alternately. This obviates the need to store the runtime stack. Our approach, on the other hand, provides a general mechanism to save the runtime stack., 86164=The shadow stack essentially doubles the memory requirement of an application. One of several options to service memory, if the DRAM cannot hold the shadow stack, is to memory-map the shadow stack to local disk, trading checkpointing overhead for memory requirement. This will still be substantially faster than transferring a large checkpoint via a network which is the most time-consuming portion of checkpointing to date. Once the checkpoint is available on the shadow stack, copy-on-write methods or communication latency hiding, as disclosed in Strumpen V. Software-Based Communication Latency Hiding for Commodity Networks. In International Conference on Parallel Processing, August 1996, which is incorporated herein by reference, may be used to efficiently transfer the checkpoint and continue the computation at the same time., 138289=The method proceeds from step 2510 to step 2520 which involves loading the last checkpoint into the shadow stack. The organization and use of the shadow stack has been extensively discussed in prior sections., 50615=The use of compilers to assist in the checkpointing process was first proposed by Li and Fuchs (Li C-C. J., Fuchs W. K. CATCH--Compiler-assisted Techniques for Checkpointing. In International Symposium on Fault Tolerant Computing, pages 74-81, 1990 and Li C-C J., Stewart E. M., Fuchs W. K. Compiler Assisted Full Checkpointing. Software-Practice and Experience, 24 no. 10:871-8861, October 1994), where the compiler identifies points in the program where checkpoints may potentially be taken, the heuristics are used to determine which of these checkpoints will be activated. Beck et al propose extensions to the transparent libckpt library for automatic uniprocessor checkpointing. They support compiler directives that may be provided by the programmer (or a static analyzer) to optimize the frequency of checkpointing and the amount of information that needs to be checkpointed, by identifying memory that can be excluded from being checkpointed. This work does not address portability., 51625=Elnozahy et al (Elnozahy E. N., Johnson D. B., Zwaenepoel W. The performance of consistent checkpointing. In IEEE Symposium on Reliable and Distributed Systems, pages 39-47, October 1992) and Plank et al (Plank J. S., Beck M., Kingsley G., Li K. Libckpt: Transparent Checkpointing under Unix. In Proceedings of the Usenix Winter Technical Conference, San Francisco, Calif., January 1995) have proposed efficient implementation techniques to minimize the overhead of checkpointing to few percent of the execution time, The techniques developed in these references rely on efficient page-based bulk copying and hardware support to identify memory pages modified since the last checkpoint, Unfortunately, these optimizations are restricted to binary compatible hardware and operating systems., 124804=All experiments are performed with sequential checkpointing, where the program is halted to copy its state onto the shadow stack, then writes the checkpoint to disk, and, after completion, continues to program execution. Optimizations, such as proposed in Elnozahy E. M., Johnson D. B., Zwaenepoel W. The performance of consistent checkpointing. In IEEE Symposium on Reliable and Distributed Systems, pages 39-47, October 1992 and Plank J. S., Beck M., Kingsley G., Li K. Libckpt: Transparent Checkpointing under Unix. In Proceedings of the Usenix Winter Technical Conference, San Francisco, Calif. January 1995 which are incorporated herein by reference, can be applied., 136908=After the timer expires, the method proceeds from step 2420 back to step 2410 which selectively activates portable checkpointing at the next potential checkpoint marker. This method of implementation greatly reduces the checkpoint overhead by not performing too many checkpoints, while simultaneously allowing reasonable recovery through the use of MinTBC so the checkpoints will not be spaced too far apart in time., 53521=The idea of stack mobility has been explored by researchers in a limited context. Theimer and Hayes (Theimer M. M., Hayes B. Heterogeneous Process Migration by Recompilation. In Proceedings of the 11th International Conference on Distributed Computing Systems, pages 18-25, July 1991) present a recompilation-based approach to heterogeneous process migration. Their compilation technique is to, upon migration, translate the state of a program into a machine independent state. Then, a migration program is generated that represents the state, and can be compiled on a target machine. When run, the machine independent migration program recreates the process. Rather than compiling a migration program each time that a checkpoint is to be taken, the present method instruments the original program with code that barely affects the runtime during normal execution. This avoids the overhead of compiling a migration program and is conceptually much simpler. However, several assumptions are made, including one that \"the state of a program at any migration point is sufficiently well-specified to allow its complete translation between machine-dependent and machine-independent forms.\" What constitutes a migration point, and how this program state is identified and translated are not discussed., 49875=Memory exclusion optimizations include incremental checkpointing, compiler-assistance to reduce the frequency and volume of checkpoints, and user-directed checkpointing. The use of hardware support to identify memory pages that have changed since the last checkpoint has been proposed (Elnozahy E. N., Johnson D. B., Zwacnepoel W. The performance of consistent checkpointing. IEEE Symposium on Reliable and Distributed Systems, pages 39-47, October 1992). These pages are then copied to secondary storage using copy-on-write while program execution continues. While yielding very low checkpointing overhead, a primary disadvantage of this method is that is restricted to binary compatible hardware and operating systems., 128555=The dense matrix-matrix multiplication, implemented by Plank J. S., Beck M., Kingsley G., Li K. Libckpt: Transparent Checkpointing under Unix. In Proceedings of the Usenix Winter Technical Conference, San Francisco, Calif., January 1995 which is incorporated herein by reference, is instrumented for this benchmark. FIG. 21 summarizes the runtimes and overheads for the checkpointed dense matrix-matrix multiplications of two dense 615\ufffd615 matrices without failures., 54846=Richards and Ramkumar (Richards, R. J., Ramkumar B. Blocking Entry Points in Message-Driven Parallel Systems. In International Conference on Parallel Processing, August 1995) report the transformations needed to support runtime stack mobility for small tasks in a portable parallel language called ELMO. The technique relied on explicit programmer support for marshaling and unmarshalling complex data structures. The transformations were developed for task migration in portable parallel programming environments for homogeneous networks and did not discuss fault tolerance or checkpointing., 135348=Marker inserter 2360, pre-compiler 2370, and compiler 2380 can be implemented in a variety of ways. For example, marker inserter 2360 and pre-compiler 2370 can be combined into a single pre-compiler as previously discussed. Alternatively, each of the elements could be implemented on totally independent platforms. In addition, each of these elements can be implemented using any combination of software, firmware, and hardware depending on the requirements of the specific application. For example, a hardware implementation could include use of a single platform with a single processor or multiple processors for implementation of all of the elements. Alternately, each element in apparatus 2355 could be implemented on a single or multiprocessor. Firmware for each element could also be implemented., 137652=FIG. 25 shows a method for recovering from portable checkpoints, according to a preferred embodiment of the invention. The method begins at step 2510 which involves restarting the executable code. Restarting step 2510 can be part of a fault tolerant system in which recovery is started after a fault is detected or can be part of a multi-processor system in which the state of a process is being migrated from one processing platform to another processing platform. The processing platform includes not only computers, such as PCs or workstations, but any device which is processor-based such as embedded controllers.}",
    "textBeforeTable": "Patent Citations The foregoing embodiments are merely exemplary and are not to be construed as limiting the present invention. The present teaching can be readily applied to other types of apparatuses. The description of the present invention is intended to be illustrative, and not to limit the scope of the claims. Many alternatives, modifications, and variations will be apparent to those skilled in the art. The method according to one embodiment of the invention only requires that (1) a user program be submitted to a front-end source-to-source C pre-compiler before compilation on the desired target machine, and (2) the run time library be linked to produce the final executable. It does not limit the choice of compiler or impose any system-specific demands. This makes it easy to render any C program robust in the presence of faults and recoverable on any UNIX-based system. The instrumented versions of the benchmark programs were hand-translated to obtain the data reported in this paper. The cost of recovery from failures in the method was found to be very low on UCF-compatible machines, and a little higher on UCF-incompatible machines. Our experiments show that the total volume of data that needs to be recovered is the determining factor in recovery cost; the system overhead is very small. A universal checkpoint format (UCF) that permits checkpoints to be ported across UCF-compatible and UCF-incompatible systems has been developed. The overhead of converting checkpoints into a",
    "textAfterTable": "Reference 1 Beck et al., \"Compiler-Assisted Checkpointing,\" Technical Report CS-94-269, University of TN, Dec. 1994. 2 * Beck et al., Compiler Assisted Checkpointing, Technical Report CS 94 269, University of TN, Dec. 1994. 3 * Computer Dictionary pp. 88, 373, Sep. 1997. 4 Deconinck et al., \"Survey of Checkpointing and Rollback Techniques,\" Technical Report 03.1.8 and 03.1.12, ESAT-ACAA Laboratory, Katholieke Universiteit, Leuven, Belgium, Jun. 1993. 5 * Deconinck et al., Survey of Checkpointing and Rollback Techniques, Technical Report 03.1.8 and 03.1.12, ESAT ACAA Laboratory, Katholieke Universiteit, Leuven, Belgium, Jun. 1993. 6 Elnozahy et al., \"The Performance of Consistent Checkpointing,\" IEEE Symposium on Reliable and Distributed Systems, pp. 39-47, Oct. 1992. 7 * Elnozahy et al., The Performance of Consistent Checkpointing, IEEE Symposium on Reliable and Distributed Systems, pp. 39 47, Oct. 1992. 8 Elnozahy, et al., \"A Survey of Rollback-Recovery Protocols in Message-Passing Systems,\" Technical Report CMU-CS-96-181, School of Computer Science, Carnegie Mellon University.",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}