{
    "relation": [
        [
            "version",
            "unpatched 1.6.0",
            "0005 patch",
            "original patch",
            "-alternative patch"
        ],
        [
            "xor (ns)",
            "148.128748",
            "272.039667",
            "268.670316",
            "271.747043"
        ],
        [
            "j.u.HM (\u00b5s)",
            "1.701640",
            "21.201178",
            "21.169436",
            "20.755397"
        ]
    ],
    "pageTitle": "Clojure JIRA",
    "title": "",
    "url": "http://dev.clojure.org/jira/sr/jira.issueviews:searchrequest-fullcontent/temp/SearchRequest.html?jqlQuery=project+IN+(CLJ%2C+ASYNC)+AND+status+in+(Open%2C+%22In+Progress%22%2C+Reopened)+AND+Approval+%3D+Triaged+order+by+type+ASC%2C+priority+DESC%2C+key+DESC&tempMax=1000",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 225,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988598.68/warc/CC-MAIN-20150728002308-00137-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 66623147,
    "recordOffset": 66488929,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{774945=The change in behavior you are seeing is most likely due to a fix for ticket CLJ-1330., 772745=FYI, it's been a year. The correct file is CLJ-1278-2.patch., 382383=Patch clj-1254-2.diff is identical to clj-1254-v1.txt except it applies cleanly to latest master. The only changes were in the context of the lines that were changed, due to a recent commit made., 455061=I don't think 1716 covers it at all as clojure.test/clojure.stacktrace don't use the new throwable printing. But they could! And that might be a better solution than the patch here., 43228=Patch clj-1074-read-infinity-and-nan-patch-v2.txt dated May 24 2013 is identical to 0001-Read-Infinity-and-NaN.patch dated Sep 21 2012, except it applies cleanly to latest master. The older patch conflicts with a recent commit made for CLJ-873., 431935=I posted a separate ticket for zipmap, with patch, on 30/May/12: CLJ-1005., 589710=user=> (dotimes [_ 6] (time (dotimes [_ 50000000] (unchecked-divide 4 (System/currentTimeMillis))))) \"Elapsed time: 1806.942 msecs\" \"Elapsed time: 1808.747 msecs\" \"Elapsed time: 1865.074 msecs\" \"Elapsed time: 1802.777 msecs\" \"Elapsed time: 1839.468 msecs\" \"Elapsed time: 1830.61 msecs\" nil user=> (dotimes [_ 6] (time (dotimes [_ 50000000] (/ 4 (System/currentTimeMillis))))) \"Elapsed time: 5003.598 msecs\" \"Elapsed time: 4998.182 msecs\" \"Elapsed time: 4941.237 msecs\" \"Elapsed time: 5036.517 msecs\" \"Elapsed time: 4965.867 msecs\" \"Elapsed time: 4982.693 msecs\", 807513=Patch 0001-CLJ-1239-protocol-dispatch-for-clojure.walk.patch no longer applies cleanly to latest Clojure master since the patch for CLJ-1105 was committed on Nov 22, 2013. From the description, it appears the intent was either that patch or this one, not both, so I am not sure what should happen with this patch, or even this ticket., 543945=The patch CLJ-1656-v5.patch doesn't seem to do anything with the old version of assoc (in core.clj around line 179)?, 686821=(2) In a 2011 discussion thread, \"Clojure sort: is it specified to be stable for all targets?\" https://groups.google.com/forum/#!topic/clojure/j3aNAmEJW9A , Stuart Sierra replied that \"if it's not specified in the doc string, then it's not a promise. That said, [...] I would generally expect a language built-in `sort` routine to be stable, so take that for what it's worth.\", 44984=We're running into this bug now, applying the patch clj-1074-read-infinity-and-nan-patch-v2-plus-edn-reader.patch seems to resolve it on 1.7 master, but it would be an improvement to not depend on a patched version., 191318=Back in 2009 I submitted a patch to the set functions with explicit `set?` checks and Rich's response was \"the fact that these functions happen to work when the second argument is not a set is an implementation artifact and not a promise of the interface, so I'm not in favor of the set? testing or any other accommodation of that.\" Not sure if that is still accurate though., 44025=clj-1074-read-infinity-and-nan-patch-v2-plus-edn-reader.patch is the same as clj-1074-read-infinity-and-nan-patch-v2.txt except it patches EdnReader too, but it must be applied after # CLJ-873 0001-Fix- CLJ-873-for-EdnReader-too.patch get merged, 232689=New patch: clj-1647.patch, 175744=Patch: clj-1705-3.patch, 454494=http://dev.clojure.org/jira/browse/CLJ-1716 may cover this well enough that this issue can be closed., 733932=I dunno, seems like CLJ-1517 phase 1 is just vectors not maps, so this is still easy low-hanging fruit., 568599=Adding drupp-clj-1611-2.patch to address previous comments., 439877=clj-1458-4.patch refreshed to apply to master, no changes., 551155=This is an attempt to write a minimal-foreknowledge failing test for CLJ-1633. By minimal-foreknowledge, I mean a test that fails in the presence of the bug, but which one could imagine writing without intimate knowledge of the details of the bug. I suspect that looking for tests like this is a good way to find gaps in test coverage, and produce tests that will uncover novel regressions later on., 758664=Patch CLJ-1282-p1.patch no longer applies cleanly after commits made to Clojure master on Jan 31 2014, probably due to the patch committed for CLJ-1318, and probably only because some lines of context changed in the test file. That would be trivial to update, but Stu's comments above suggest that more significant changes need to be made., 157072=In this situation, the only native library available on the classpath is the ARM dependency, and obviously won't load on the compiling x86 machine. Java libraries tend to load the native dependencies in the static initialiser of the class, which will fail in this situation as the architecture is x86 and the dependencies are ARM, for which reason CLJ-1315 made the change to not run static initialisers at compile time., 157622=This covers a case which didn't come up as part of CLJ-1315, that the same problem occurs if rather than constructing the class, you simply use it as a type hint (which IMO is doubly surprising as something to have a side-effect)., 658755=Patch: CLJ-1452.patch, 732031=1.6.0-alpha2 with patch clj-1295-1.diff: \"Elapsed time: 2874.748 msecs\" \"Elapsed time: 2862.878 msecs\" \"Elapsed time: 2887.778 msecs\" \"Elapsed time: 2874.196 msecs\" \"Elapsed time: 2861.807 msecs\", 601874=Related to CLJ-1530, 387380=Similar issue to CLJ-1222, with the same root cause as described for CLJ-1225., 19560=Adding atom-reset-atomic-watch-2015-06-30.patch. Includes test and implementation., 297185=I have uploaded an alternative implementation of the locking macro (0001-CLJ-1472-Locking-macro-without-explicit-monitor-ente.patch) which cheats a little - the synchronized block is actually implemented in Java and so guarantees compatibility. This is at the cost of a little extra indirection and the naming/location could probably be better., 218819=patch file to fix clj-1647, 318061=Would a doc patch be considered? Say one that modified the doc of clojure.core/hash to include a phrase indicating that it is only promised to be consistent with clojure.core/= for immutable values? It could even perhaps mention that Floats are out, too: see CLJ-1036, 577017=So CLJ-1454 is swap! and return old and CLJ-1599 is reset! and return old?, 567677=clojure.java.io/reader is idempotent, while the patch of 10-Jan-2015 re-wraps an existing PushbackReader twice: first with a new BufferedReader, then with a new PushbackReader., 638756=It was easy to fix the patch. Uploaded the new patch v3_0001-CLJ-1456-counting-forms-to-catch-malformed-throw-for.patch, which applies cleanly to the current master., 584657=1) When I apply the patch (git apply CLJ-1545.diff), I get a bunch of whitespace errors which will need to be cleaned up but also the patch seems to fail to apply at all on the changes in test/clojure/test_clojure/numbers.clj. It looks like perhaps the diff is just not the right diff format. You might want to check out the instructions at http://dev.clojure.org/display/community/Developing+Patches about using git format-patch., 117359=IBM JDK 1.6 in test matrix is throwing errors from the new test for CLJ-1250 in 1.8.0-alpha2., 35270=Nicola, the patch 0001-CLJ-1403-ns-resolve-returns-nil-if-class-is-not-foun.patch dated 31 Aug 2014 applies cleanly to latest Clojure master as of Oct 1 2014, but fails to compile with JDK8. I haven't checked whether it compiles cleanly with other JDK versions yet., 346933=Here's a new patch (0005-CLJ-1372-consistent-hasheq-for-java.util.-List-Map-M.patch) that introduces a new isAlien static method that checks for instanceof Map/Map.Entry/Iterable and uses this method to test for \"alien collection\"., 341291=Here's a new patch (0001-CLJ-1372-consistent-hasheq-for-java.util.-List-Map-M-substring.patch) that takes the outrageous approach of replacing the Iterable/Map/Entry test with a .startsWith(\"java.util.\") on the class name. (I experimented with .getClass().getPackage(), but the performance of that was terrible.) The branch is here:, 123579=I've strengthened the CLJ-1250 test case by relying on neither reducer impl nor range impl, and I reverified that the bug is in fact present on <1.7 and gone on -master using Oracle JDK and 128m heap., 313601=Add patch clj-1372-2.diff that is identical to Jozef Wagner's clj-1372.diff, except it also adds some new tests that fail without his changes, and pass with them., 565403=(2009, \"Reading... from a reader\") https://groups.google.com/forum/#!topic/clojure/_tuypjr2M_A, 745148=Attached CLJ-1289-p1.patch which simply inlines variadic calls to aget. It assumes that if it sees a :tag on the array arg that is a string beginning with [, it can assume that the return value from one call to aget can be tagged with the same string with the leading [ stripped off., 324551=Both patches clj-1372.diff and clj-1372-2.diff fail to apply cleanly as of latest Clojure master on Mar 20 2014. They did apply cleanly before the Mar 19 2014 commit, I believe, and the only issue appears to be a changed line of diff context. Given the discussion about whether such a change is desired, it sounds like more thought is needed before deciding what change should be made, if any., 365679=This hit me when upgrading Factual/skuld from 1.5.1 to 1.6. clojure.data.fressian serialises c.l.PersistentHashSet sets into java.util.HashSet. This breaks equality checking in https://github.com/Factual/skuld/blob/b720feb142e6d274e85be208dc1d6d8634801719/test/skuld/net_test.clj#L8-L29 as we are comparing a set of maps where the original set contains a PersistentSet and the serialised and deserialised one contains a HashSet., 732771=A nice boost, but probably obsoleted by CLJ-1517, 382987=quot should throw an an exception on overflow quot' (I assume not divide' ?) should be added to autopromote on overflow unchecked-divide should be added to do what quot does now - see CLJ-1545, 751778=Patch: CLJ-1282-p2.patch, 676897=Both patches CLJ-1451-drop-until.patch and CLJ-1451-take-until.patch dated Jun 20 2014 no longer apply cleanly to latest Clojure master due to some changes committed earlier today. I haven't checked whether they are straightforward to update, but would guess that they merely require updating a few lines of diff context., 573041=This is close to a 1:1 translation of the Java code in sun.misc.Unsafe's getAndSetObject, used by AtomicReference (as of current JDK9 source code)., 26687=It\u2019s a particular case of CLJ-1461. Vector comes from reading output of print-dup:, 825612=Note that this is similar to the equally unhelpful message shown in http://dev.clojure.org/jira/browse/CLJ-1140 although that is a different root cause., 805293=Patch: 0002-CLJ-1239-protocol-dispatch-for-clojure.walk.patch, 122137=The CLJ-1250 test should be modified to intentionally hold the head of a seq in order to exercise the locals clearing. A good hypothesis from Alex is that GC is a bit slower on the archaic IBM JDK., 599755=http://dev.clojure.org/pages/viewpage.action?pageId=11862058, 804674=The conditional dispatch in clojure.walk is slow and not open to extension. Prior to CLJ-1105 it did not support records., 363769=They're listed in the table in the comment introducing the benchmark \u2013 148.128748 ns for xor, 1.701640 \u00b5s for juhm., 463361=New patch 0003-CLJ-1107-Throw-exception-for-get-on-unsupported-type.patch created from master at 5cc167a., 2552=Clojure 1.7.0-RC1, latest core.async head (May 2015), 254081=Tom, I've opened a ticket with a patch fixing the AOT issue: http://dev.clojure.org/jira/browse/CLJ-1604, 731155=1.6.0-alpha2 with patch clj-1295-1.diff: \"Elapsed time: 6362.006 msecs\" \"Elapsed time: 6121.006 msecs\" \"Elapsed time: 6163.377 msecs\" \"Elapsed time: 6155.299 msecs\" \"Elapsed time: 6395.224 msecs\", 786618=Patch clj-1277-1.txt adds 4 type hints that eliminate all reflection occurrences in source file instant.clj. Benchmarks show that it speeds up printing of java.util.Date and java.sql.Timestamp objects by a factor of about 3 to 4.5., 786857=Latest Clojure master as of Oct 9 2013:, 380267=Rich Hickey stated in a comment on CLJ-1225 that this case should throw an exception., 787340=That version of Clojure plus the patch clj-1277-1.txt:, 760492=Attached CLJ-1282-p2.patch which is off of the current master and addresses Stu's points., 565589=[2] CLJ-82 and the 2009 message thread, 245821=The reason (def inc inc) behaves this way is, if not absolutely necessary, at least commonly used in Clojure programs to define recursive functions, e.g. (defn fib [n] (if (<= n 1) 1 (+ (fib (dec n)) (fib (- n 2))))), so that the occurrences of fib in the body are resolved to the fib being defined., 202177=Francis, your patch clj-1680_no_div0.patch dated 2015-Mar-24 uses the method isFinite(), which appears to have been added in Java 1.8, and does not exist in earlier versions. I would guess that while the next release of Clojure may drop support for Java 1.6, it is less likely it would also drop support for Java 1.7 at the same time. It might be nice if your patch could use something like !(isInfinite() || isNaN()) instead, which I believe is equivalent, and both of those methods exist in earlier Java versions., 585277=2) If you could put a more useful git commit message, that would be helpful. Something like \"CLJ-1545 Adds missing unchecked-divide and unchecked-remainder for primitive longs.\", 777282=Things that you could do to help: 1) Simplify the description. Someone coming to this ticket (screeners and ultimately Rich) want to look at the description and get the maximal understanding with the minimal effort. We have some guidelines on this at http://dev.clojure.org/display/community/Creating+Tickets if you haven't seen it. For an enhancement, a short (1-2 sentence) description of the problem and an example I can run in the repl is best. Then a proposal (again, as short as possible). Examples: CLJ-1529, CLJ-1325, CLJ-1378. For an enhancement like this, seeing (succinct) before/after versions where a user will see this is often the quickest way for a screener to understand the benefit., 730409=The patch clj-1295-1.diff changes PersistentArrayMap's without() to use System.arraycopy to copy only the necessary parts from the current array to newArray, similar to PersistentHashMap's method removePair()., 388560=Patch clj-1253-1.txt corrects LongOps method divide for the case of args Long/MIN_VALUE and -1. It returns a BigInt in this case, not a Long, but most other pairs of values passed to this function return a Ratio exact answer, so it seems reasonable in this one case to return a BigInt exact answer when it will not fit in a Long., 464004=Patch clj-1107-throw-on-unsupported-get-v4.patch dated Mar 26 2014 is identical to Stuart Sierra's patch 0003-CLJ-1107-Throw-exception-for-get-on-unsupported-type.patch, and retains his authorship. The only difference is in one line of diff context required in order to make it apply cleanly to latest master., 688656=Patch clj-1414-v1.patch dated Aug 30 2014 adds the sentence \"Guaranteed to be stable: equal elements will not be reordered.\" to the doc strings of both sort and sort-by., 831487=Patch: clj-1117.patch, 251230=This comment is really most relevant for ticket CLJ-1604, where it has been copied:, 484445=Patch: clj-1765.patch Screened by: Alex Miller, 699129=Patch 0003-Add-transient-predicate.patch dated Aug 6 2013 no longer applied cleanly to latest master after some commits were made to Clojure on Aug 29, 2014. It did apply cleanly before that day., 539801=(Retrieving com/yellerapp/clojure-unrolled-assoc/1.7.0-unrollassoc-SNAPSHOT/clojure-unrolled-assoc-1.7.0-unrollassoc-20150213.092242-1.pom from clojars) (Retrieving com/yellerapp/clojure-unrolled-assoc/1.7.0-unrollassoc-SNAPSHOT/clojure-unrolled-assoc-1.7.0-unrollassoc-20150213.092242-1.jar from clojars) (Retrieving org/clojure/clojure/1.3.0/clojure-1.3.0.jar from central) Exception in thread \"main\" java.lang.RuntimeException: Unable to resolve symbol: bench in this context, compiling:(bench_assoc_unrolling.clj:5) at clojure.lang.Compiler.analyze(Compiler.java:6235) at clojure.lang.Compiler.analyze(Compiler.java:6177) at clojure.lang.Compiler$InvokeExpr.parse(Compiler.java:3452) at clojure.lang.Compiler.analyzeSeq(Compiler.java:6411) at clojure.lang.Compiler.analyze(Compiler.java:6216) at clojure.lang.Compiler.analyze(Compiler.java:6177) at clojure.lang.Compiler$BodyExpr$Parser.parse(Compiler.java:5572) at clojure.lang.Compiler$FnMethod.parse(Compiler.java:5008), 769189=Patch: CLJ-1278-2.patch, 659763=Attached CLJ-1452.patch, with the same code used in the benchmarks., 283512=Patch clj-1475.diff handles destructuring, preconditions and rest arguments, 637669=All patches dated Jun 30 2014 and earlier no longer applied cleanly to latest master after some commits were made to Clojure on Aug 29, 2014. They did apply cleanly before that day., 381557=Patch clj-1254-v1.txt causes (quot Long/MIN_VALUE -1) to throw an exception due to overflow of the result, if the arguments are both long., 812259=Alex, for what it matters clojure-1.6.0 after CLJ-1105 exibits the same behaviour as described by Chouser for this patch, 326582=This patch (0001-CLJ-1372-consistent-hasheq-for-java.util.-List-Map-M.patch) makes hasheq consistent with = for java.util.{List,Map,Map.Entry,Set}. Additionally it extends the special treatment of String (return hasheq of hashCode) to all types not otherwise handled (see below for a comment on this)., 655933=The code used is at https://github.com/gfredericks/clj-1452-tests; the raw output is in a comment., 785710=Patch: clj-1277-1.txt Screened by: Alex Miller, 495848=CLJ-1315 addressed a similar issue by modifying \"import\" to load classes without running static initialization code. I've written my own patch which extends this behavior to work in \":gen-class\" and \"proxy\" as well. The unit tests pass, and we're using this code successfully in our iOS app., 125658=Seems like SR16 FP7 == 6.0.16.7, and the one on the CI build is SR9 FP2 == 6.0.9.2, a four or five year difference between point releases., 460462=Patch: 0003-CLJ-1107-Throw-exception-for-get-on-unsupported-type.patch, 379558=Similar issue to CLJ-1222 and CLJ-1253, with the same root cause as described for CLJ-1225. Ticket filed separately from CLJ-1253 for long division / because the desired fix may be quite different in this case., 169101=this must be the same issue as CLJ-1422 and CLJ-701, it has nothing to do with returning `this`, but with the try being in a tail position or not. if the try is not in a tail position the compiler hoists it out in to a thunk. effectively the code is, 284027=The clj-1475.diff patch looks good to me., 356958=The substring patch is broken (see below), so I skipped it. The patch I'm describing as the \"original\" one is attached as 0001-CLJ-1372-consistent-hasheq-for-java.util.-List-Map-M.patch., 181289=I think that last one is pretty close, but we're paying a hit just to invoke the new function, so my final stab was turning that into a macro - 28.411626 ns, which seems tolerable to me. Because I used a macro, I also had to move the type hints in vector-of to avoid reflection., 635180=Patch: clj-1456-4.patch, 298868=given the structured locking verbiage in https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.11.10, `(locking nil)` may generate bytecode whose runtime behavior violates structured locking. the first patch on this issue can cause the compiler to emit monitorenter/exit instructions in different methods, which definitely violates structured locking, 552002=With CLJ-1633 unfixed, we get this output:, 526116=Patch: CLJ-1656-v5.patch, 695975=Patch 0001-Add-transient-predicate.patch dated Mar 17, 2014 applies cleanly to latest Clojure master, but fails a test because the new function transient? has no :added metadata. See most other Clojure functions in clojure.core for examples., 606405=Mac OS X 10.9.4 / 2.6 GHz Intel Core i5 / 8 GB 1600 MHz DDR3 java version \"1.7.0_17\" Java(TM) SE Runtime Environment (build 1.7.0_17-b02) Java HotSpot(TM) 64-Bit Server VM (build 23.7-b01, mixed mode), 729123=In latest Clojure master as of Nov 15 2013, the method without() in PersistentArrayMap.java first searches for a matching key using indexOf(key) and saves the result in i., 793826=Patch: clj-1259-1.txt Screened by: Alex Miller, 565148=(2014, \"clojure.edn won't accept clojure.java.io/reader?\") https://groups.google.com/forum/#!topic/clojure/3HSoA12v5nc, 496299=Patch: clj-1743-2.patch, 462662=Patch clj-1107-throw-on-get-for-unsupported-types-patch-v2.txt applied cleanly to latest Clojure master as of Jan 23 2014, but no longer does with commits made to Clojure between then and Jan 30 2014. I have not checked to see how difficult or easy it may be to update this patch., 334362=First, for completeness, here's a new patch (0001-CLJ-1372-consistent-hasheq-for-java.util.-List-Map-M-alternative.patch) which doesn't do the extra murmuring for types not otherwise handled. It's slower for the single PHM case; see below for details. Also, here's the branch on GitHub:, 438047=CLJ-1458-transient-merge3.patch removes silly inlining macro, uses singleton fns instead., 588039=Alex, did you do the testing in your previous comment with *unchecked-math* true or false? If false, then I would think that if CLJ-1254 is judged a bug, then the behavior you saw is a bug, too, that misses the same corner case., 588893=Refreshing my memory of the (/ Long/MIN_VALUE -1) case, I think you're right. The (new) unchecked-divide / remainder should do what the current (checked) forms do and the regular division and remainder cases should be making the overflow check. I think CLJ-1254 should cover the quot changes., 451455=Patch: 0002-CLJ-1209-show-ex-data-in-clojure-test.patch, 794734=Patch clj-1259-1.txt eliminates all occurrences of reflection in pprint, and all files loaded from pprint.clj. It also sets warn-on-reflection to true for those files, in hopes of making it more obvious if a new use of reflection is added there., 461626=Patch clj-1107-throw-on-get-for-unsupported-types-patch-v2.txt dated May 24 2013 is identical to 0001-CLJ-1107-Throw-exception-for-get-called-on-unsupport.patch dated Nov 13 2012, except it applies cleanly to latest master. A recent commit for CLJ-1099 changed many IllegalArgumentException occurrences to Throwable in the tests, which is the only thing changed in this updated patch., 804916=Approach: Reimplement clojure.walk using protocols. The public API does not change. Users can extend the walk protocol to other types (for example, Java collections) if desired. As in CLJ-1105, this version of clojure.walk supports records., 263895=Patch: clj-1509.diff, 472977=This is double-better with the changes in Clojure 1.6 to improve jio/copy performance by using the NIO impl. Rough timing difference on a 25M file: old= 2316.021 msecs, new= 93.319 msecs., 575126=Note: This request is similar to CLJ-1454 (http://dev.clojure.org/jira/browse/CLJ-1454), but differs in that this is not a swap! operation that accepts an IFn argument. Also, I looked to add a test in test/clojure/test_clojure/atoms.clj, but saw that the other operations weren't tested. (I assume this is due to the other operations delegating to AtomicReference and hence not deemed test-worthy.), 697981=Patch 0002-Add-transient-predicate.patch dated Mar 22 2014 no longer applies cleanly to latest Clojure master due to some changes committed earlier today. I haven't checked whether this patch is straightforward to update., 252388=Next commit with description \"Add clojure.core/update, like update-in but takes a single key\" that adds clojure.core/update: 'lein do clean, test' is fine, but 'lein do clean, uberjar' throws exception during compilation, probably due to CLJ-1241., 566630=Attached patch drupp-clj-1611.patch implements clojure.java.io/pushback-reader as requested., 808963=Added new patch that applies on latest master after CLJ-1105., 27268=I already have a patch for PersistentTreeSet (attached here). Can look into CLJ-1461 later.}",
    "textBeforeTable": "Mean execution time as reported by Criterium: (c/bench (hash juhm)))) (c/bench (f)) (bit-xor (clojure.lang.Util/hasheq phm))))] (bit-xor (clojure.lang.Util/hasheq c)) (bit-xor (clojure.lang.Util/hasheq k)) (bit-xor (clojure.lang.Util/hasheq s)) (bit-xor (clojure.lang.Util/hasheq d)) (-> (clojure.lang.Util/hasheq l) f (fn f [] juhm (java.util.HashMap. phm) phm (apply hash-map (interleave (range 128) (range 128))) c \\S k BigInteger s \"asdf;lkjh\" d 123.456 (let [l 41235125123 (require '[criterium.core :as c]) (do  Ok, I have what I think is an improved microbenchmark for this: xor of hasheqs for a long, a double, a string, a class, a character and a PHM (single instance, so it'll be a hash lookup). The results are not very encouraging. Single form including the require to make it convenient to run; also bundled is a j.u.HashMap (128 entries) hasheq benchmark: Comment by Micha\u0142 Marczyk [ 14/May/14 3:15 AM ] \"Hashing many different types changes the results noticeably \u2013 presumably HotSpot backs off from some optimizations after seeing several different types passed in to hasheq?\" Right - if your benchmarks do not treat this site as megamorphic you will get all sorts of distorted results. Comment by Rich Hickey [ 13/May/14 9:47 AM ] Could I get a summary of approaches, and a timing",
    "textAfterTable": "The substring patch is broken (see below), so I skipped it. The patch I'm describing as the \"original\" one is attached as 0001-CLJ-1372-consistent-hasheq-for-java.util.-List-Map-M.patch. Decisions common to all the patches: 1. One extra if statement in hasheq just above the default return with a three-way instanceof check. 2. The types tested for are j.u.Iterable, j.u.Map.Entry and j.u.Map. 3. Murmur3.hashOrdered takes Iterable, so that's why it's on the list. Map does not extend Iterable, so it's listed separately. Map.Entry is on the list, because ultimately the way to hash maps is to iterate over and hash their entries. 4. The actual hashing of the \"alien\" / host types is done by a separate static method \u2013 clojure.lang.Util.doalienhasheq \u2013 on the theory that this will permit hasheq to be inlined more aggressively and limit the worst of the perf hit to alien collections. 5. doalienhasheq checks for Map, Map.Entry, Set and List; entries are converted to lists for hashing, maps are hashed through entry sets and lists and sets are passed directly to Murmur3. 6. There is also a default case for other Iterable types \u2013 we must return hashCode or the result of composing some other function with hashCode for these, since we use equals to test them for equivalence. The 0005 patch has hasheq call a separate private static method to perform the three-way type check, whereas the others put the check directly in the actual if test. The -alternative patch and the 0005",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}