{
    "relation": [
        [
            "HTTP Method",
            "GET",
            "GET",
            "POST",
            "GET",
            "GET",
            "PUT",
            "DELETE"
        ],
        [
            "URI",
            "/books",
            "/books/create",
            "/books",
            "/books/${id}",
            "/books/${id}/edit",
            "/books/${id}",
            "/books/${id}"
        ],
        [
            "Grails Action",
            "index",
            "create",
            "save",
            "show",
            "edit",
            "update",
            "delete"
        ]
    ],
    "pageTitle": "The Grails Framework 2.3.4",
    "title": "",
    "url": "http://grails.github.io/grails-doc/2.3.4/guide/single.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042986022.41/warc/CC-MAIN-20150728002306-00220-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 112794223,
    "recordOffset": 112570810,
    "tableOrientation": "HORIZONTAL",
    "lastModified": "Thu, 09 Jul 2015 10:11:54 GMT",
    "textBeforeTable": "Config.groovy you can access several implicit variables from configuration values: BuildConfig.groovy and Within both } good = \"bye\" hello = \"world\" foo.bar { // Won't work!   won't work: However, you can't nest after using the dot notation. In other words, this  } bar.good = \"bye\" bar.hello = \"world\" foo {   or by only partially nesting them:  } } good = \"bye\" hello = \"world\" bar { foo {   foo.bar. The above syntax works but it's quite repetitive and verbose. You can remove some of that verbosity by nesting properties at the dots: both of which have the same base:  foo.bar.good = \"bye\" foo.bar.hello = \"world\"   Things become more interesting when you have multiple settings with the same base. For example, you could have the two settings Note that the value is a Groovy string literal! Those quotes around 'world' are important. In fact, this highlights one of the advantages of the ConfigSlurper syntax over properties files: the property values can be any valid Groovy type, such as strings, integers, or arbitrary objects!  foo.bar.hello = \"world\"   The most basic syntax is similar to that of Java properties files with dot notation on the left-hand side: BuildConfig.groovy is not. Don't worry if you're not clear on the distinction:",
    "textAfterTable": "grailsSettings An object containing various build related settings, such as baseDir. It's of type BuildSettings. and Config.groovy has Variable Description grailsApplication The GrailsApplication instance. Those are the basics of adding settings to the configuration file, but how do you access those settings from your own application? That depends on which config you want to read. The settings in BuildConfig.groovy are only available from command scripts and can be accessed via the grailsSettings.config property like so: target(default: \"Example command\") { def maxIterations = grailsSettings.config.myapp.iterations.max \u2026 } If you want to read runtime configuration settings, i.e. those defined in Config.groovy, use the grailsApplication object, which is available as a variable in controllers and tag libraries: class MyController { def hello() { def recipient = grailsApplication.config.foo.bar.hello  render \"Hello ${recipient}\" } } and can be easily injected into services and other Grails artifacts: class MyService { def grailsApplication  String greeting() { def recipient = grailsApplication.config.foo.bar.hello return \"Hello ${recipient}\" } } As you can see, when accessing configuration settings you use the same dot notation as when you define them. 4.1.1 Built in options Grails has a set",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}