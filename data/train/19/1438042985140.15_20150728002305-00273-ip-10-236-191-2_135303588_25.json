{
    "relation": [
        [
            "Robot Arm",
            "InterbotiX PhantomX Pincher Arm",
            "InterbotiX PhantomX Reactor Arm",
            "InterbotiX WidowX Arm",
            "RobotGeek Snapper Arm"
        ],
        [
            "Arm ID",
            "1",
            "2",
            "3",
            "5"
        ]
    ],
    "pageTitle": "Arm Link Reference",
    "title": "Arm IDs",
    "url": "http://learn.trossenrobotics.com/arbotix/arbotix-communication-controllers/31-arm-control",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042985140.15/warc/CC-MAIN-20150728002305-00273-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 135320527,
    "recordOffset": 135303588,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{3540=To control the base servo, you will send a raw servo value. This will be 0-1023 for the all the joints in the Reactor/Pincher Arm. For the Base, Shoulder, Elbow and Wrist Angle joints on the WidowX arm this will be 0-4095 and 0-1023 for the wrist rotate and gripper joints., 4581=The base servo can now be controlled absolutely. This increases the overall workspace of the arm. To control the base servo, you will send a raw servo value (0-1023 for the Reactor/Pincher Arm and 0-4095 for WidowX arm)}",
    "TableContextTimeStampAfterTable": "{7321=For example, a delta of 125 means that the move will take 2000 milliseconds, or 2 seconds.}",
    "lastModified": "Wed, 29 Jul 2015 00:34:31 GMT",
    "textBeforeTable": "Examples Arduino serial communications sends data as discrete byte-sized packets. An 8-bit byte can only hold values from 0-255. This is too small for the X/Y/Z coordinate values and the absolute servo positions values. To compensate for this, each parameter is split into two bytes - a low byte and a high byte. Once received by the Robot Arm, these bytes will be combined into the original value. Low Byte/High Byte Calculations Checksum 17 Extended Instruction Byte 16 Button Byte 15 Delta Byte 16 Gripper Low Byte 13 Griper High Byte 12 Wrist Rotate Low Byte 11 Wrist Rotate High Byte 10 Wrist Angle Low Byte 9 Wrist Angle High Byte 8 Elbow Servo Rotation Low Byte Z-Axis Coordinate Low Byte 7 Elbow Servo Rotation High Byte Z-Axis Coordinate High Byte 6 Shoulder Servo Rotation Low Byte Y-Axis Coordinate Low Byte 5 Shoulder Servo Rotation High Byte Y-Axis Coordinate High Byte 4 Base Servo Rotation Low Byte X-Axis Coordinate Low Byte 3 Base Servo Rotation High Byte X-Axis Coordinate High Byte 2 Header (0xFF/255) 1 Backhoe Mode Cylindrical Mode Cartesian Mode Packet #",
    "textAfterTable": "3 13 0000001100001101 00000011 00001101 030D 03 0D 1023 3 255 0000001111111111 00000011 11111111 03FF 03 FF 1435 05 155 0000010110011011 00000101 10011011 059B 05 9B The low byte corresponds to the first 8 bits of the value. To obtain this value we simply remove anything past the first 8 bits of the value. This can be done many ways, but the easiest way is to use the modulus operator (%). Low Byte Pseudo Code //coordinate is a previously defined integer value byte lowByte = coordinate % 256 ; The low byte corresponds to the second 8 bits of the value. First we will shift the second byte down 8 values. To do this we can divide the value by 28 or 256. As these operations are being done on integers/bytes, the lower byte is discarded. Once we have shifted the second byte, we will use the modulus operator to ensure that only a single byte is isolated. High Byte Pseudo Code //coordinate is a previously defined integer value byte highByte = (coordinate / 256)%256; Here's an alternative way to come up with the high/low byte using bitwise operators",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}