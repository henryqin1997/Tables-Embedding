{
    "relation": [
        [
            "Column Name",
            "VDBName",
            "Name",
            "IsPhysical",
            "UID",
            "OID",
            "Description",
            "PrimaryMetamodelURI"
        ],
        [
            "Type",
            "string",
            "string",
            "boolean",
            "string",
            "integer",
            "string",
            "string"
        ],
        [
            "Description",
            "VDB name",
            "Schema name",
            "True if this represents a source",
            "Unique ID",
            "Unique ID (see note below)",
            "Description",
            "URI for the primary metamodel describing the model used for this schema"
        ]
    ],
    "pageTitle": "Teiid - Scalable Information Integration",
    "title": "",
    "url": "http://docs.jboss.org/teiid/7.6.0.Final/reference/en-US/html_single/",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438044160065.87/warc/CC-MAIN-20150728004240-00257-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 72855683,
    "recordOffset": 72743120,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{428601=For example, consider the following query that retrieves all engineering employees born since 1970., 377555=ingres - for use with Ingres 2006 or later., 375879=access - for use with Microsoft Access 2003 or later., 43780=Teiid supports ANSI SQL 2003 window functions. A window function allows an aggregrate function to be applied to a subset of the result set, without the need for a GROUP BY clause. A window function is similar to an aggregate function, but requires the use of an OVER clause or window specification., 56164=(balance > 2500.0), 156321=2534.1, 172578=Returns a timestamp based upon the incoming timestamp adjusted for the differential between the start and end time zones.\u00a0 i.e. if the server is in GMT-6, then modifytimezone({ts '2006-01-10 04:00:00.0'},'GMT-7', 'GMT-8') will return the timestamp {ts '2006-01-10 05:00:00.0'} as read in GMT-6.\u00a0 The value has been adjusted 1 hour ahead to compensate for the difference between GMT-7 and GMT-8., 156505=1234, 179682=For example: GMT-05:00, 95282=The LIMIT clause specifies a limit on the number of records returned from the SELECT command. An optional offset (the number of rows to skip) can be specified. The LIMIT clause can also be specfied using the SQL 2008 OFFSET/FETCH FIRST clauses. If an ORDER BY is also specified, it will be applied before the OFFSET/LIMIT are applied. If an ORDER BY is not specified there is generally no guarantee what subset of rows will be returned., 533=Copyright \u00a9 2011 Red Hat, Inc., 178853='03.24.2003 at 06:14:32', 31063=Teiid provides nearly all of the functionality of SQL-92 DML. SQL-99 and later features are constantly being added based upon community need. The following does not attempt to cover SQL exhaustively, but rather highlights SQL's usage within Teiid. See the grammar for the exact form of SQL accepted by Teiid., 34980=Teiid's reserved words include the standard SQL 2003 Foundation, SQL/MED, and SQL/XML reserved words, as well as Teiid specific words such as BIGINTEGER, BIGDECIMAL, or MAKEDEP. See the Appendix\u00a0A, BNF for SQL Grammar TOKENS section for all reserved words. They will appear as 'SMALLINT: \"smallint\"' where the quoted string is the actual lexical form., 178724='22:08:56 CST', 380961=sqlserver - for use with SQL Server 2000 or later. A SQL Server JDBC driver version 2.0 or later (or compatible e.g. JTDS 1.2 or later) should be used., 201963=XMLQUERY is part of the SQL/XML 2006 specification., 85616=The XMLTABLE funciton uses XQuery to produce tabular ouptut. The XMLTABLE function is implicitly a nested table and may be correlated to preceeding FROM clause entries. XMLTABLE is part of the SQL/XML 2006 specification.}",
    "lastModified": "Tue, 29 Nov 2011 18:07:25 GMT",
    "textBeforeTable": "row_number() over (order by salary) as row_num FROM employees rank() over (order by salary) as rank, dense_rank() over (order by salary) as dense_rank, SELECT name, salary, max(salary) over (partition by name) as max_sal,  Example\u00a01.1.\u00a0Example Windowed Results  Teiid will process all window functions with the same window specification together. In general a full pass over the row values coming into the SELECT clause will be required for each unique window specification. For each window specification the values will be grouped according to the PARTITION BY clause. If no PARTITION BY clause is specified, then the entire input is treated as a single partition. The output value is determined based upon the current row value, it's peers (that is rows that are the same with respect to their ordering), and all prior row values based upon ordering in the partition. The ROW_NUMBER function will assign a unique value to every row regardless of the number of peers. Window functions are logically processed just before creating the output from the SELECT clause. Window functions can use nested aggregates if a GROUP BY clause is present. The is no guarenteed affect on the output ordering from the presense of window functions. The SELECT statement must have an ORDER BY clause to have a predictable ordering.   1.2.4.2.\u00a0Processing DENSE_RANK() \u2013 Assigns a number to each unique ordering value",
    "textAfterTable": "4 Suzie 150000 150000 1 1 1 1.2.5.\u00a0Case and searched case Teiid supports two forms of the CASE expression which allows conditional logic in a scalar expression. Supported forms: CASE <expr> ( WHEN <expr> THEN <expr>)+ [ELSE expr] END CASE ( WHEN <criteria> THEN <expr>)+ [ELSE expr] END Each form allows for an output based on conditional logic. The first form starts with an initial expression and evaluates WHEN expressions until the values match, and outputs the THEN expression. If no WHEN is matched, the ELSE expression is output. If no WHEN is matched and no ELSE is specified, a null literal value is output. The second form (the searched case expression) searches the WHEN clauses, which specify an arbitrary criteria to evaluate. If any criteria evaluates to true, the THEN expression is evaluated and output. If no WHEN is true, the ELSE is evaluated or NULL is output if none exists. 1.2.6.\u00a0Scalar subqueries Subqueries can be used to produce a single scalar value in the SELECT, WHERE, or HAVING clauses only. A scalar subquery must have a single column in the SELECT clause and should return either 0 or 1 row. If no rows are returned, null will be",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}