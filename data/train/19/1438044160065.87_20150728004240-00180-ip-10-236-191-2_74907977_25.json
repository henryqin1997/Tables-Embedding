{
    "relation": [
        [
            "Parameter",
            "group_name",
            "group_type",
            "member",
            "comments"
        ],
        [
            "Description",
            "The name to assign to the group. It can optionally be prefixed with a schema name. It cannot be NULL. It is converted to uppercase unless enclosed in double-quotes.",
            "The type of members in the group. All members must be of the same type. Possible types are: 'DB_DEST' Database destination: Members are database destinations, for running remote database jobs. 'EXTERNAL_DEST External destination: Members are external destinations, for running remote external jobs. 'WINDOW' Members are Scheduler windows. You must have the MANAGE SCHEDULER privilege to create a group of this type. Members in database destination and external destination groups have the following format: [[schema.]credential@][schema.]destination where: credential is the name of an existing credential. destination is the name of an existing database destination or external destination. The credential portion of a destination member is optional. If omitted, the job using this destination member uses its default credential. Members in window groups are window names. Because all Scheduler windows reside in the SYS schema, you do not specify a schema name for windows.",
            "Optional comma-separated list of group members. The default is NULL. If NULL, use the ADD_GROUP_MEMBER procedure to add members. You can also use ADD_GROUP_MEMBER to add additional members at a later time. The keyword LOCAL can be used as a member in database destination groups and external destination groups. In database destination groups, LOCAL represents the source database on which the job is created. It cannot be preceded with a credential. In external destination groups, LOCAL represents the host on which the source database resides. It can be optionally preceded with a credential name. If no credential is provided, jobs that use this group as their destination must have a default credential.",
            "A text string that describes the group. Scheduler does not use this argument."
        ]
    ],
    "pageTitle": "DBMS_SCHEDULER",
    "title": "",
    "url": "http://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_sched.htm",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438044160065.87/warc/CC-MAIN-20150728004240-00180-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 74996855,
    "recordOffset": 74907977,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{61759=This specifies the week of the year as a number. It follows ISO-8601, which defines the week as starting with Monday and ending with Sunday; and the first week of a year as the first week, which is mostly within the Gregorian year. The first week is equivalent to the following two variants: the week that contains the first Thursday of the Gregorian year; and the week containing January 4th., 90432=Many companies in the retail industry share the same fiscal year. The fiscal year starts on the Sunday closest to February 1st, and subsequent quarters start exactly 13 weeks later. The fiscal year schedule for the retail industry can be defined as the following:, 62417=As an example, in the year 1998, the ISO week 1 began on Monday December 29th, 1997; and the last ISO week (week 53) ended on Sunday January 3rd, 1999. So December 29th, 1997, is in the ISO week 1998-01, and January 1st, 1999, is in the ISO week 1998-53., 54440=The Scheduler uses a rich calendaring syntax to enable you to define repeating schedules, such as \"every Tuesday and Friday at 4:00 p.m.\" or \"the second Wednesday of every month.\" This calendaring syntax is used in calendaring expressions in the repeat_interval argument of a number of package subprograms. Evaluating a calendaring expression results in a set of discrete timestamps., 61292=This specifies which month or months you want the job to execute in. You can use numbers such as 1 for January and 3 for March, as well as three-letter abbreviations such as FEB for February and JUL for July., 81608=Note that when the byweekno clause is used, it is possible that the dates returned are from a year other than the current year. For example, if returning dates for the year 2004 and the calendar string is \"FREQ=YEARLY;BYWEEKNO=1,53\" for the specified week numbers in 2004, it will return the dates:, 80463=When not enough BY clauses are present to determine what the next date is, this information is retrieved from the start date. For example, \"FREQ=YEARLY\" with a start date of 02/15/2003 becomes \"FREQ=YEARLY;BYMONTH=FEB; BYMONTHDAY=15\", which means every year on the 15th of February., 71038=For example, assume that the named schedule last_sat indicates the last Saturday in every month, and that for the year 2005, the only months where the last day of the month is also a Saturday are April and December. Assume also that the named schedule end_qtr indicates the last day of each quarter in 2005:, 79368=Because an INCLUDE clause is present, date-related information is not retrieved from the start date. However, time-specific information is, so the preceding schedule executes on 07/01/05 9:00:00, 07/01/06 9:00:00, 07/01/08 9:00:00, and so on., 474571=For example, if the job was set to run at 02:00 in the previous time zone, it will run at 02:00 in the new time zone., 404993=Time in seconds before an event generated by the Scheduler and enqueued onto the Scheduler event queue expires. May be NULL., 474877=If FALSE, the next start date and time for the job is not recomputed when the default_timezone scheduler attribute is changed. In this case, if the old time zone is three hours earlier than the new time zone, then a job scheduled to run at 02:00 in the old time zone runs at 05:00 in the new time zone., 78886=The preceding schedule executes on 04/15/05 9:00:00, 04/15/06 9:00:00, 04/15/07 9:00:00, and so on., 87829=on 01/01/2004 or 01/15/2004, in both cases the expression evaluates to Friday 01/02/2004, and Tuesday 01/06/2004. The only difference is that when the expression is evaluated on 01/15/2004, the Scheduler determines that there are no matches in January because the timestamps found are in the past, and it moves on to the matches in the next month, February., 489978=In heavily loaded systems, jobs are not always started at their scheduled time. This attribute enables you to have the Scheduler not start a job at all if the delay in starting the job is larger than the interval specified. It can be a value of 1 minute to 99 days. For example, if a job was supposed to start at noon and the schedule limit is set to 60 minutes, the job will not be run if it has not started to run by 1:00 p.m., 369304=If zero, then the job run is logged as succeeded. If -1013, then the job run is logged as stopped. If non-zero, then the job run is logged as failed with this error number., 75279=In this example, the dates 1/30, 2/20, and 7/25 are added to the main schedule. However, the Scheduler does not include dates that fall in months that are skipped by the INTERVAL clause. If the start date of the main schedule is 1/1/2005, then 2/20 is not added. On the dates that are added, the embedded schedule follows the execution pattern of the main schedule: jobs are executed at 9:00 a.m. and 5:00 p.m. on 1/30 and 7/25. If the embedded schedule does not itself have a start date, it inherits the start date from the main schedule., 83652=Repeating jobs with frequencies smaller than daily follow their frequencies exactly across daylight savings adjustments. For example, suppose that a job is scheduled to repeat every 3 hours, the clock is moved forward from 1:00 a.m. to 2:00 a.m., and the last time the job ran was midnight. Its next scheduled time will be 4:00 a.m. Thus, the 3 hour period between subsequent job runs is retained. The same applies when the clock is moved back. This behavior is not the case for repeating jobs that have frequencies of daily or larger. For example, if a repeating job is supposed to be executed on a daily basis at midnight, it will continue to run at midnight if the clock is moved forward or backward. When the execution time of such a daily (or larger frequency) job happens to fall inside a window where the clock is moved forward, the job executes at the end of the window., 172727=An Oracle Net connect identifier that is resolved to the Oracle database instance being connected to. The exact syntax depends on the Oracle Net configuration.The connect identifier can be a complete Oracle Net connect descriptor (network address and database service name) or a net service name, which is an alias for a connect descriptor. The alias must be resolved in the tnsnames.ora file on the local computer. The maximum size for tns_name is 2000 characters., 80812=\"FREQ=YEARLY;BYMONTH=JAN,JUL\" with start date 01/21/2003 becomes \"FREQ=YEARLY;BYMONTH=JAN,JUL;BYMONTHDAY=21\", which means every year on January 21 and July 21., 81046=The byweekno clause is only allowed if the frequency is YEARLY. It cannot be used with other frequencies. When it is present, it will return all days in that week number. If you want to limit it to specific days within the week, you have to add a BYDAY clause. For example, \"FREQ=YEARLY;BYWEEKNO=2\" with a start date of 01/01/2003 will return:, 68727=The BYSETPOS clause is applied to the list of timestamps once per frequency period. For example, when the frequency is defined as MONTHLY, the Scheduler determines all valid timestamps for the month, orders that list, and then applies the BYSETPOS clause. The Scheduler then moves on to the next month and repeats the procedure. Assuming a start date of Jun 10, 2004, the example evaluates to: Jun 30, Jul 30, Aug 31, Sep 30, Oct 29, and so on., 64037=BYDATE=0115,0315,0615,0915,1215,20060115, 63157=This specifies the day of the year as a number. Valid values are 1 to 366. An example is 69, which is March 10 (31 for January, 28 for February, and 10 for March). 69 evaluates to March 10 for non-leap years and March 9 in leap years. -2 will always evaluate to December 30th independent of whether it is a leap year., 88818=then the execution times on 05/02 and 09/22 are 8:00 a.m., 1:00 p.m., and 6:00 p.m.}",
    "lastModified": "Fri, 31 Jul 2015 12:07:26 GMT",
    "textBeforeTable": "Table 129-26 CREATE_GROUP Procedure Parameters Parameters comments IN VARCHAR2 DEFAULT NULL); member IN VARCHAR2 DEFAULT NULL, group_type IN VARCHAR2, group_name IN VARCHAR2, DBMS_SCHEDULER.CREATE_GROUP (  Syntax  You can use a group name in other DBMS_SCHEDULER package procedures to specify a list of objects. For example, to specify multiple destinations for a remote database job, you provide a group name for the DESTINATION_NAME parameter of the job. This procedure creates a group. Groups contain members, which you can specify when you create the group or at a later time. There are three types of groups: window groups, database destination groups, and external destination groups. CREATE_GROUP Procedure      You must have the CREATE JOB system privilege to create a file watcher in your own schema. You require the CREATE ANY JOB system privilege to create a file watcher in a schema different from your own (except the SYS schema, which is disallowed). Usage Notes     If TRUE (the default), the file watcher is enabled. enabled Optional comment. comments Minimum time interval that",
    "textAfterTable": "Usage Notes Groups reside in a particular schema and can be created by any user with the CREATE JOB system privilege. To create a group in a schema other than your own, you must have the CREATE ANY JOB privilege. The group name must be unique among all Scheduler objects. You can grant the SELECT privilege on a group so that other users can reference the group when creating jobs or schedules. To enable other users to modify a group, you can grant the ALTER privilege on the group. Each group member must be unique within the group. For destination groups, the credential/destination name pairs must be unique within the group. An error is generated if any of the group members do not exist. For destination groups, both the credential and destination portions of a member must exist. Another group of the same type can be a group member. The Scheduler immediately expands the included group name into its list of members. Groups are created enabled, but you can disable them. This procedure supersedes the procedure CREATE_WINDOW_GROUP, which is deprecated in Oracle Database 11g Release 2 (11.2). Example The following PL/SQL block creates a group named production_dest1, whose members are database destinations for a collection of production databases.  BEGIN DBMS_SCHEDULER.CREATE_GROUP( GROUP_NAME => 'production_dest1', GROUP_TYPE => 'DB_DEST', MEMBER => 'LOCAL, oracle_cred@prodhost1, prodhost2', COMMENTS => 'All sector1",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}