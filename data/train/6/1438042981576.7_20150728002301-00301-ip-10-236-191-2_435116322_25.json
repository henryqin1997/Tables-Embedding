{
    "relation": [
        [
            "Field Name",
            "gameId",
            "shooter",
            "goalie",
            "blocker",
            "releaseType",
            "flight",
            "shotResult",
            "possession",
            "location",
            "context"
        ],
        [
            "Required/Optional",
            "Required",
            "Required",
            "Required",
            "Optional",
            "Optional",
            "Optional",
            "Required",
            "Required",
            "Required",
            "Required"
        ],
        [
            "Field Description",
            "A unique identifier for the game the user is currently scoring.",
            "The playerId, representing the player taking the shot.",
            "The playerId of the opposing team goalie who was guarding the net at the time of the shot.",
            "The playerId of the opposing team player who blocked the shot, if applicable.",
            "A text string representing the type of shot taken. Must be one of: \"low-to-high\", \"high-to-low\", or \"lateral\".",
            "A text string representing the flight of the ball once released from the crosse. Valid values are \"bounce\" or \"air\".",
            "A text string representing the result of the shot taken. Valid values are \"blocked\", \"saved\", \"high\", \"post\", \"wideR\", or \"wideL\". (Note shots resulting in goals should send a 'goal' document.)",
            "A true/false indicator to represent whether the shooting team retains possession after the shot.",
            "The field location where the shot was taken.",
            "A valid context document."
        ]
    ],
    "pageTitle": "ESPNALPS",
    "title": "",
    "url": "http://www.espnalps.com/doc",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042981576.7/warc/CC-MAIN-20150728002301-00301-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 435150387,
    "recordOffset": 435116322,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{222823=\u00a9 2012 ESPN Technology Services, Inc. All rights reserved. Terms and Conditions: API, Contest Rules, SDK. looking for other ESPN APIs? Check out: http://developer.espn.com., 21723=example 2011-09-10T12:47:21.231-0500, 39980=For example: If the local time zone is eastern standard time (GMT-5) and the time locally is 08/03/2011 12:58:32 then the properly formatted time stamp is: 08/03/2011 17:58:32 '-0500'}",
    "textBeforeTable": "The user is authenticated via the login method, which returns a token to your application. Every other API method you call will require the combination of these three things, passed as a query string: The access key serves to identify your application to the API. The shared secret used to generate a signature (see below) and should never be made publicly available. Ideally, the shared secret should not be human readable in your source code. Once you've used the shared secret to generate a signature you'll have two values: access key and signature. These values are used in every API call to authenticate your application, but not the user. Shared Secret Access Key The ALPS API is protected on two fronts: both the application and user need to be authenticated. In order for applications and users to authenticate they will need to be registered. To register as a developer follow this link. Once you have registered as a developer, you'll be able to use the portal to register your application with this link. After your application has been registered, you'll get two values: Overview GettingStarted V0/CBB/DeleteEvent V0/CBB/Foul V0/CBB/Timeout V0/CBB/Turnover V0/CBB/Substitution V0/CBB/Rebound",
    "textAfterTable": "from hashlib import md5 accessKey=\"f786504c72057d52360cd9c776b46693adbd3a90\" sharedSecret=\"0HrepxVO4TqNYkZb4CeK7XntWtlUJPXwiMIW70gj\" # Get the current time in seconds since epoch currentTime = int(time()) # Concatenate them stringToHash = \"{0}{1}{2}\".format(accessKey, sharedSecret,currentTime) m = md5() m.update(stringToHash) signature = m.hexdigest() Generating a Signature With Ruby  require 'digest/md5' def getSignature(key,sharedSecret) concatString = [key,sharedSecret,Time.now.to_i].join(\"\") #Concatenate in this order Digest::MD5.hexdigest(concatString) #return the MD5 Digest end Generating a Signature With Objective-C  # Get the function time from module time -(NSString *) generateSignature:(NSString *)accessKey sharedSecret:(NSString *) theSharedSecret { // concatenate the accessKey and signature and generate MD5 hash for the concatenated string NSString *signature = [[NSString stringWithFormat:@\"%@%@%@\", accessKey,theSharedSecret, getUnixTime] MD5]; return signature; } \u00a0 //generate MD5 hash from string - (NSString*)MD5 { // Create pointer to the string as UTF8 const char* ptr = [self UTF8String]; // Create byte array of unsigned chars unsigned char md5Buffer[CC_MD5_DIGEST_LENGTH]; // Create 16 byte MD5 hash value, store in buffer CC_MD5(ptr, strlen(ptr), md5Buffer); // Convert MD5 value in the buffer to NSString of hex values NSMutableString* output = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (int i = 0; i < CC_MD5_DIGEST_LENGTH; i++) { [output appendFormat:@\"%02x\",md5Buffer[i]]; } return output; } Putting it All Together With A Simple Python Script Here we put it all together with a simple Python script to show an example workflow:  # We like these libraries, feel free to use ones that you like. from requests import post from time",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}