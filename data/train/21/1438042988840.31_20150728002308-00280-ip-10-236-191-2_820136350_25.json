{
    "relation": [
        [
            "name",
            "\"Alice\"",
            "\"Bob\""
        ],
        [
            "mbox",
            "",
            ""
        ],
        [
            "hpage",
            "",
            ""
        ]
    ],
    "pageTitle": "SPARQL 1.1 Query Language",
    "title": "",
    "url": "http://www.w3.org/TR/2010/WD-sparql11-query-20100601/",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988840.31/warc/CC-MAIN-20150728002308-00280-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 820220527,
    "recordOffset": 820136350,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{20992=This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy., 2090=Appendix A contains the normative definition of the SPARQL query language's syntax, as given by a grammar expressed in EBNF notation., 20123=1 Introduction \u00a0\u00a0\u00a0\u00a01.1 Document Outline \u00a0\u00a0\u00a0\u00a01.2 Document Conventions \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.2.1 Namespaces \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.2.2 Data Descriptions \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.2.3 Result Descriptions \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.2.4 Terminology 2 Making Simple Queries (Informative) \u00a0\u00a0\u00a0\u00a02.1 Writing a Simple Query \u00a0\u00a0\u00a0\u00a02.2 Multiple Matches \u00a0\u00a0\u00a0\u00a02.3 Matching RDF Literals \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.3.1 Matching Literals with Numeric Types \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.3.2 Matching Literals with Arbitrary Datatypes \u00a0\u00a0\u00a0\u00a02.4 Blank Node Labels in Query Results \u00a0\u00a0\u00a0\u00a02.5 Creating Values with Expressions \u00a0\u00a0\u00a0\u00a02.6 Building RDF Graphs 3 RDF Term Constraints (Informative) \u00a0\u00a0\u00a0\u00a03.1 Restricting the Value of Strings \u00a0\u00a0\u00a0\u00a03.2 Restricting Numeric Values \u00a0\u00a0\u00a0\u00a03.3 Other Term Constraints 4 SPARQL Syntax \u00a0\u00a0\u00a0\u00a04.1 RDF Term Syntax \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.1.1 Syntax for IRIs \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.1.1.1 Prefixed names \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.1.1.2 Relative IRIs \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.1.2 Syntax for Literals \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.1.3 Syntax for Query Variables \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.1.4 Syntax for Blank Nodes \u00a0\u00a0\u00a0\u00a04.2 Syntax for Triple Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.2.1 Predicate-Object Lists \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.2.2 Object Lists \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.2.3 RDF Collections \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.2.4 rdf:type 5 Graph Patterns \u00a0\u00a0\u00a0\u00a05.1 Basic Graph Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.1.1 Blank Node Labels \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.1.2 Extending Basic Graph Pattern Matching \u00a0\u00a0\u00a0\u00a05.2 Group Graph Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.2.1 Empty Group Pattern \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.2.2 Scope of Filters \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.2.3 Group Graph Pattern Examples 6 Including Optional Values \u00a0\u00a0\u00a0\u00a06.1 Optional Pattern Matching \u00a0\u00a0\u00a0\u00a06.2 Constraints in Optional Pattern Matching \u00a0\u00a0\u00a0\u00a06.3 Multiple Optional Graph Patterns 7 Matching Alternatives 8 Negation \u00a0\u00a0\u00a0\u00a08.1 Filtering Using Graph Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.1.1 Testing For the Absence of a Pattern \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.1.2 Testing For the Presence of a Pattern \u00a0\u00a0\u00a0\u00a08.2 Removing bindings \u00a0\u00a0\u00a0\u00a08.3 Relationship and difference between NOT EXISTS and MINUS \u00a0\u00a0\u00a0\u00a08.4 Algebra Operators \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.4.1 Algebra: EXISTS \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.4.2 Algebra: MINUS 9 Property Paths 10 Aggregates \u00a0\u00a0\u00a0\u00a010.1 Aggregate Example \u00a0\u00a0\u00a0\u00a010.2 Algebra Operators \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.2.1 Set Functions \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.2.2 Mapping from Abstract Syntax to Algebra 11 Subqueries 12 RDF Dataset \u00a0\u00a0\u00a0\u00a012.1 Examples of RDF Datasets \u00a0\u00a0\u00a0\u00a012.2 Specifying RDF Datasets \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.2.1 Specifying the Default Graph \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.2.2 Specifying Named Graphs \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.2.3 Combining FROM and FROM NAMED \u00a0\u00a0\u00a0\u00a012.3 Querying the Dataset \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a012.3.1 Named and Default Graphs 13 Solution Sequences and Modifiers \u00a0\u00a0\u00a0\u00a013.1 ORDER BY \u00a0\u00a0\u00a0\u00a013.2 Projection \u00a0\u00a0\u00a0\u00a013.3 Duplicate Solutions \u00a0\u00a0\u00a0\u00a013.4 OFFSET \u00a0\u00a0\u00a0\u00a013.5 LIMIT 14 Query Forms \u00a0\u00a0\u00a0\u00a014.1 SELECT \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.1.1 Projection \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.1.2 SELECT expressions \u00a0\u00a0\u00a0\u00a014.2 CONSTRUCT \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.2.1 Templates with Blank Nodes \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.2.2 Accessing Graphs in the RDF Dataset \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.2.3 Solution Modifiers and CONSTRUCT \u00a0\u00a0\u00a0\u00a014.3 ASK \u00a0\u00a0\u00a0\u00a014.4 DESCRIBE (Informative) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.4.1 Explicit IRIs \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.4.2 Identifying Resources \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014.4.3 Descriptions of Resources 15 Testing Values \u00a0\u00a0\u00a0\u00a015.1 Operand Data Types \u00a0\u00a0\u00a0\u00a015.2 Filter Evaluation \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.2.1 Invocation \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.2.2 Effective Boolean Value (EBV) \u00a0\u00a0\u00a0\u00a015.3 Operator Mapping \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.3.1 Operator Extensibility \u00a0\u00a0\u00a0\u00a015.4 Operators Definitions \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.1 bound \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.2 isIRI \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.3 isBlank \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.4 isLiteral \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.5 str \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.6 lang \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.7 datatype \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.8 logical-or \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.9 logical-and \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.10 RDFterm-equal \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.11 sameTerm \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.12 langMatches \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.13 regex \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.14 COALESCE \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.15 IF \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.16 IN \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.17 NOT IN \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.18 IRI \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.19 BNODE \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.20 STRDT \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a015.4.21 STRLANG \u00a0\u00a0\u00a0\u00a015.5 Constructor Functions \u00a0\u00a0\u00a0\u00a015.6 Extensible Value Testing 16 Definition of SPARQL \u00a0\u00a0\u00a0\u00a016.1 Initial Definitions \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.1.1 RDF Terms \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.1.2 RDF Dataset \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.1.3 Query Variables \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.1.4 Triple Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.1.5 Basic Graph Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.1.6 Solution Mapping \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.1.7 Solution Sequence Modifiers \u00a0\u00a0\u00a0\u00a016.2 SPARQL Query \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.2.1 Converting Graph Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.2.2 Examples of Mapped Graph Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.2.3 Converting Solution Modifiers \u00a0\u00a0\u00a0\u00a016.3 Basic Graph Patterns \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.3.1 SPARQL Basic Graph Pattern Matching \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.3.2 Treatment of Blank Nodes \u00a0\u00a0\u00a0\u00a016.4 SPARQL Algebra \u00a0\u00a0\u00a0\u00a016.5 Evaluation Semantics \u00a0\u00a0\u00a0\u00a016.6 Extending SPARQL Basic Graph Matching \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016.6.1 Notes 17 SPARQL Grammar 18 Conformance 19 Security Considerations (Informative) 20 Internet Media Type, File Extension and Macintosh File Type, 3908=Section 4 presents details of the SPARQL query language's syntax. It is a companion to the full grammar of the language and defines how grammatical constructs represent IRIs, blank nodes, literals, and variables. Section 4 also defines the meaning of several grammatical constructs that serve as syntactic sugar for more verbose expressions.}",
    "TableContextTimeStampAfterTable": "{162999=The SPARQL operators are listed in section 11.3 and are associated with their productions in the grammar., 88539=The set functions which underlie SPARQL aggregates all have a common signature: SetFunc(M, err), or SetFunc(M, err, scalar, ...) where M is a multiset of lists, err is a value indicating whether the evaluation of any of the expressesions evaluated with respect to \u03a9 returned an error, and scalar is one or more scalar values that are passed to the set function indirectly via the ( ... ; key=value ) syntax for aggregates in the SPARQL grammar., 50682=The keyword \"a\" can be used as a predicate in a triple pattern and is an alternative for the IRI\u00a0 http://www.w3.org/1999/02/22-rdf-syntax-ns#type. This keyword is case-sensitive., 302985=A SPARQL Query String is processed for codepoint escape sequences before parsing by the grammar defined in EBNF below. The codepoint escape sequences for a SPARQL query string are:, 302048=A SPARQL query string is a Unicode character string (c.f. section 6.1 String concepts of [CHARMOD]) in the language defined by the following grammar, starting with the Query production. For compatibility with future versions of Unicode, the characters in this string may include Unicode codepoints that are unassigned as of the date of this publication (see Identifier and Pattern Syntax [UNIID] section 4 Pattern Syntax). For productions with excluded character classes (for example [^<>'{}|^`]), the characters are excluded from the range #x0 - #x10FFFF., 373915=See appendix A SPARQL Grammar regarding conformance of SPARQL Query strings, and section 10 Query Forms for conformance of query results. See appendix E. Internet Media Type for conformance to the application/sparql-query media type., 175592=The SPARQL grammar identifies a set of operators (for instance, &&, *, isIRI) used to construct constraints. The following table associates each of these grammatical productions with the appropriate operands and an operator function defined by either XQuery 1.0 and XPath 2.0 Functions and Operators [FUNCOP] or the SPARQL operators specified in section 11.4. When selecting the operator definition for a given set of parameters, the definition with the most specific parameters applies. For instance, when evaluating xsd:integer = xsd:signedInt, the definition for = with two numeric parameters applies, rather than the one with two RDF terms. The table is arranged so that the upper-most viable candiate is the most specific. Operators invoked without appropriate operands result in a type error., 310031=Keywords are matched in a case-insensitive manner with the exception of the keyword 'a' which, in line with Turtle and N3, is used in place of the IRI rdf:type (in full, http://www.w3.org/1999/02/22-rdf-syntax-ns#type)., 22017=This section covers the syntax used by SPARQL for RDF terms and triple patterns. The full grammar is given in appendix A., 249813=A PrimaryExpression grammar rule can be a call to an extension function named by an IRI. An extension function takes some number of RDF terms as arguments and returns an RDF term. The semantics of these functions are identified by the IRI that identifies the function., 304651=Codepoint escape sequences can appear anywhere in the query string. They are processed before parsing based on the grammar rules and so may be replaced by codepoints with significance in the grammar, such as \":\" marking a prefixed name., 304923=These escape sequences are not included in the grammar below. Only escape sequences for characters that would be legal at that point in the grammar may be given. For example, the variable \"?x\\u0020y\" is not legal (\\u0020 is a space and is not permitted in a variable name)., 373678=Some grammar files for some commonly used tools are available here., 7728=Note that, in Turtle, \"cat\"@en is an RDF literal with a lexical form \"cat\" and a language tag en; \"42\"^^xsd:integer is a typed literal with the datatype http://www.w3.org/2001/XMLSchema#integer; and \"abc\"^^dt:specialDatatype is a typed literal with the datatype http://example.org/datatype#specialDatatype., 224631=In this query for documents that were annotated on New Year's Day (2004 or 2005), the RDF terms are not the same, but have equivalent values:, 37751=Query variables in SPARQL queries have global scope; use of a given variable name anywhere in a query identifies the same variable. Variables are prefixed by either \"?\" or \"$\"; the \"?\" or \"$\" is not part of the variable name. In a query, $abc and ?abc identify the same variable. The possible names for variables are given in the SPARQL grammar., 238934=bool = xsd:boolean dbl = xsd:double flt = xsd:float dec = xsd:decimal int = xsd:integer dT = xsd:dateTime str = xsd:string IRI = IRI ltrl = simple literal, 138916=@@Grammar refers to SPARQL 1.0 only, 162266=SPARQL expressions are constructed according to the grammar and provide access to functions (named by IRI) and operator functions (invoked by keywords and symbols in the SPARQL grammar). SPARQL operators can be used to compare the values of typed literals:, 9780=Integers in a SPARQL query indicate an RDF typed literal with the datatype xsd:integer. For example: 42 is a shortened form of\u00a0 \"42\"^^<http://www.w3.org/2001/XMLSchema#integer>., 48062=RDF collections can be written in triple patterns using the syntax \"(element1 element2 ...)\". The form \"()\" is an alternative for the IRI http://www.w3.org/1999/02/22-rdf-syntax-ns#nil. When used with collection elements, such as (1 ?x 3 4), triple patterns with blank nodes are allocated for the collection. The blank node at the head of the collection can be used as a subject or object in other triple patterns. The blank nodes allocated by the collection syntax do not occur elsewhere in the query., 309796=The EBNF notation used in the grammar is defined in Extensible Markup Language (XML) 1.1 [XML11] section 6 Notation., 177757=The collation for fn:compare is defined by XPath and identified by http://www.w3.org/2005/xpath-functions/collation/codepoint. This collation allows for string comparison based on code point values. Codepoint string equivalence can be tested with RDF term equivalence.}",
    "lastModified": "Tue, 01 Jun 2010 17:48:29 GMT",
    "textBeforeTable": "Result sets are illustrated in tabular form. 1.2.3 Result Descriptions :book1 dc:title \"SPARQL Tutorial\" . @prefix : <http://example.org/book/> . @prefix dc: <http://purl.org/dc/elements/1.1/> . This document uses the Turtle [TURTLE] data format to show each triple explicitly. Turtle allows IRIs to be abbreviated with prefixes: 1.2.2 Data Descriptions   http://www.w3.org/2005/xpath-functions# fn: http://www.w3.org/2001/XMLSchema# xsd: http://www.w3.org/2000/01/rdf-schema# rdfs: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdf: IRI Prefix In this document, examples assume the following namespace prefix bindings unless otherwise stated: 1.2.1 Namespaces 1.2 Document Conventions Appendix A contains the normative definition of the SPARQL query language's syntax, as given by a grammar expressed in EBNF notation. Section 12 is a formal definition of the evaluation of SPARQL graph patterns and solution modifiers. Section 11 defines SPARQL's extensible value testing framework. It also presents the functions and operators that can be used to constrain the values that appear in a query's results. Section 10 defines the four types of SPARQL queries that produce results in different forms. Section 9 defines the constructs that affect the solutions of a query by ordering, slicing, projecting, limiting, and removing duplicates from a sequence of solutions. Section 5 introduces basic graph patterns and group graph patterns,",
    "textAfterTable": "1.2.4 Terminology The SPARQL language includes IRIs, a subset of RDF URI References that omits spaces. Note that all IRIs in SPARQL queries are absolute; they may or may not include a fragment identifier [RFC3987, section 3.1]. IRIs include URIs [RFC3986] and URLs. The abbreviated forms (relative IRIs and prefixed names) in the SPARQL syntax are resolved to produce absolute IRIs. The following terms are defined in RDF Concepts and Abstract Syntax [CONCEPTS] and used in SPARQL: IRI (corresponds to the Concepts and Abstract Syntax term \"RDF URI reference\") literal lexical form plain literal language tag typed literal datatype IRI (corresponds to the Concepts and Abstract Syntax term \"datatype URI\") blank node 2 Making Simple Queries (Informative) Most forms of SPARQL query contain a set of triple patterns called a basic graph pattern. Triple patterns are like RDF triples except that each of the subject, predicate and object may be a variable. A basic graph pattern matches a subgraph of the RDF data when RDF terms from that subgraph may be substituted for the variables and the result is RDF graph equivalent to the subgraph. 2.1 Writing a Simple Query The example below shows a SPARQL query to find the title of a book",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}