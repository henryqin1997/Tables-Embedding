{
    "relation": [
        [
            "Date",
            "31 Oct 2008",
            "17 Dec 2009"
        ],
        [
            "Code",
            "AS",
            "AS"
        ],
        [
            "Event",
            "Assignment",
            "Assignment"
        ],
        [
            "Description",
            "Owner name: ECD SYSTEMS, INC., MASSACHUSETTS Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:MERKLE, JAMES A., JR.;BOUZA, JOSE L.;REEL/FRAME:021766/0824;SIGNING DATES FROM 20010408 TO 20010410 Owner name: ECD SYSTEMS, INC., MASSACHUSETTS Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:LEVINE, RICHARD B.;LEE, ANDREW R.;HOWARD, DANIEL G.;AND OTHERS;REEL/FRAME:021767/0019;SIGNING DATES FROM 20020918 TO 20021015 Owner name: ECD SYSTEMS, INC., MASSACHUSETTS Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:LEVINE, RICHARD B.;LEE, ANDREW R.;HOWARD, DANIEL G.;AND OTHERS;SIGNING DATES FROM 20020918 TO 20021015;REEL/FRAME:021767/0019 Owner name: ECD SYSTEMS, INC., MASSACHUSETTS Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:MERKLE, JAMES A., JR.;BOUZA, JOSE L.;SIGNING DATES FROM 20010408 TO 20010410;REEL/FRAME:021766/0824",
            "Owner name: SCA IPLA HOLDINGS INC.,NEW YORK Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:ECD SYSTEMS INC. (F.K.A. ECD SYSTEMS.COM, INC.);REEL/FRAME:023668/0925 Effective date: 20091217"
        ]
    ],
    "pageTitle": "Patent US8117667 - Systems and methods for the prevention of unauthorized use and manipulation ... - Google Patents",
    "title": "",
    "url": "http://www.google.co.uk/patents/US8117667",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438043062635.98/warc/CC-MAIN-20150728002422-00112-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 476487875,
    "recordOffset": 476412440,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{6277=FIG. 12 is a flow diagram of a system and process for providing a system service that can produce desired volumes of desired classes of logging and journaling saturation traffic, as disclosed in U.S. patent application Ser. No. 09/960,610, filed Sep. 21, 2001, and U.S. patent application Ser. No. 09/989,910, filed Nov. 20, 2001, the contents of each being incorporated herein by reference. A system event or timer is used as an event trigger 119, and upon awakening or being triggered by any appropriate event, the saturation process selects the desired type of saturation traffic (the type may be provided as a parameter and consumed upon the event of awakening, for example) and the desired extent, or amount, of such saturation. In a preferred embodiment, the generated traffic consists of many different kinds of legitimate-appearing, but pointless, activity, and the saturation effect is produced by the effect that this activity has on various classes of debugging and system monitoring tools, which, in turn, attempt to generate reports and provide insights into system activity. In the embodiment of FIG. 12, the saturation is throttled or gated by a sleep/wake mechanism which allows for a desired amount of activity per waking cycle 120, and then generates the desired amount and type of such traffic. Upon completion, the inventive process optionally sets a timer to be awakened upon in the absence of triggering events 121, and then an event-driven wait upon that timer and any other desired system event is performed 122 until the next such event triggers another saturation cycle 119. In one embodiment, the parametric values for each waking cycle may be queued and consumed in order with each such cycle, or may be determined by other means, including, but not limited to, pure or pseudo randomization, configuration file information, or an external input, for example.}",
    "TableContextTimeStampAfterTable": "{57173=In another aspect of the present invention, it is ensured that encrypted content, once decrypted, cannot be \u201clifted\u201d or \u201cdumped\u201d in a trivial manner from system memory with successful results. Content is modified by a process, to make certain data elements, usually on the boundary of the system page size and location in multiples of page size, \u201cincorrect\u201d (corrupted) or \u201ccorrect\u201d (usable as intended) depending on their prior state. Memory on such a system may be thought of as being organized into pages or groups of memory bytes, where for example a byte is 8 bits, bytes may be grouped into groups of 1024 bytes (k-bytes) and these k-bytes may be grouped into pages of 512 k-bytes. The operating system may choose to move data into and out of memory (from the hard disc or other media to memory, then back to the hard disc at times) in units of one or more pages at a time for efficiency. This aspect includes, but is not limited to, two complementary approaches; one in which pages (for example a grouping of memory bytes, 512 units of 1024 bytes each, otherwise referred to as 512K) are made correct just-in-time for licensed usage, or another where pages are made incorrect just-in-time when being lifted or dumped, to deter unlicensed usage. In all cases, the original content stored on the original media, or on hard disc, when not in use, may be wholly or partly correct in nature, and may be wholly or partly encrypted. In an example, given a program foo.exe, the program may be preprocessed such that it is divided up into N segments of 512K each, and the 3rd and 34th of these pages may be copied to another location, and the original pages overwritten with junk data. The foo.exe program is then packaged and sold to a consumer on CD, with the now-modified foo.exe and the 3rd and 34th pages hidden in an archive on the same CD. When foo.exe is run, the process and system of the present invention note access to the 3rd page and, before it is needed, replaces the page in memory with the correct 3rd page taken from the archive where it was previously stored. When the page is no longer needed, it is then modified back to the original state it was in on the distribution CD. When the 34th page is needed, it too is corrected just in time, and it is then copied back to the damaged state it was in on the distribution CD. In this manner, there is no time at which the program foo.exe is ever in a state where all pages in memory are entirely correct, such that if the program were memory lifted or dumped at least one or more pages are in an incorrect state., 38344=Despite such developments, no current mechanism of this type has proven to be entirely effective. The reasons for this are apparent; while encryption is an important part of any protective system, it should not represent the sole, or primary, method of protection, since encrypted content must at some time be decrypted for use, and may, for example, be subject to piracy following decryption. Such methods, when used as the sole protective means, are vulnerable to approaches that analyze and then modify the mechanism, and over time, with some persistence, can be broken. Any changes to the algorithm (cracking the decryptor for example) or attacks directly on the encrypted payload (using a computer system to crack the encryption), although theoretically effective, are not the attack of choice when a payload is of interest to an intruder; these approaches are much more challenging and take much more time than simply stealing the data after it has been decrypted by the protective system during normal use. The common denominator of successful attacks against such protective mechanisms come in the form of tools that attack this weakest link in the chain, as in the \u201cProcDump\u201d memory-lifting tool, or other memory lifters or memory dumpers. This class of web-distributed enhanced dumping tools have a great many features which include the ability to steal-after-decryption any 32 bit executable on any Windows-based operating system, to restore the Import table and PE header, reoptimize lifted executable, and even establish a client-server relationship with a second dumping tool which is awaiting the (specifically timed) opportunity to lift a target executable. These functions require some degree of sophistication to understand and use but enable a somewhat experienced intruder to steal almost any such protected payload at the moment of authorized usage of the payload. Tools such as memory lifters or memory dumpers are an example of the kinds of attack mechanisms that have rendered most content protection schemes for digital content, especially executable content, much less effective. This is true especially since 1998, when these tools and associated reverse-engineering techniques became widely disseminated on the World Wide Web., 33678=This application is a divisional application of U.S. patent application Ser. No. 10/142,366, filed May 9, 2002, which application claims the benefit of U.S. Provisional Application No. 60/289,773, filed May 9, 2001, U.S. Provisional Application No. 60/290,813, filed May 14, 2001, U.S. Provisional Application No. 60/294,112 filed May 29, 2001, and U.S. Provisional Application No. 60/309,650, filed Aug. 2, 2001. The contents of the applications referenced above are incorporated herein by reference in their entirety.}",
    "textBeforeTable": "Patent Citations While this invention has been particularly shown and described with references to preferred embodiments thereof, it will be understood by those skilled in the art that various changes in form and details may be made herein without departing from the spirit and scope of the invention as defined by the appended claims. ) to the system to hide or misdirect actual protective system functions. FIG. 12 Other instances include: c) overt process killing of intruding process; d) overt immediate or deferred kill or reboot of the system; e) subtle destabilization of the system by memory corruption; f) provision of false information to the intruding process or tool; and g) introduction of spoof and saturation data (as in } \u2003} \u2003\u2003break; \u2003\u2003// have found the HOT_KEY call \u2003\u2003// Break out of the search through the whole segment once we \u2003\u2003} \u2003\u2003\u2002} \u2003\u2003\u2003break; \u2003\u2003\u2003// found what we were looking for \u2003\u2003\u2003// Break out of the backwards search now that we have \u2003\u2003\u2003*((BYTE *)s_dwHotKeyAddr) = 0; \u2003\u2003\u2003s_byHotKeyVal = *((BYTE *)s_dwHotKeyAddr); \u2003\u2003\u2003//",
    "textAfterTable": "US4799594 26 Oct 1987 24 Jan 1989 Federal Paper Board Co., Inc. Vending and reclosure device for powder and granular products US4827508 14 Oct 1986 2 May 1989 Personal Library Software, Inc. Database usage metering and protection system and method US4864494 21 Mar 1986 5 Sep 1989 Computerized Data Ssytems For Mfg., Inc. Software usage authorization system with key for decrypting/re-encrypting/re-transmitting moving target security codes from protected software US4864616 15 Oct 1987 5 Sep 1989 Micronyx, Inc. Cryptographic labeling of electronically stored data US4888800 1 Mar 1988 19 Dec 1989 Hewlett-Packard Company Secure messaging systems US4916637 18 Nov 1987 10 Apr 1990 International Business Machines Corporation Customized instruction generator US4969189 19 Jun 1989 6 Nov 1990 Nippon Telegraph & Telephone Corporation Authentication system and apparatus therefor US4999806 4 Sep 1987 12 Mar 1991 Fred Chernow Software distribution system US5014234 25",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}