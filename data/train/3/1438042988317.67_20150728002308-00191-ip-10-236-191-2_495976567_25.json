{
    "relation": [
        [
            "Citing Patent",
            "US6430611 *",
            "US6473898 *",
            "US6519679 *",
            "US6714513",
            "US6728219",
            "US6754705",
            "US6789117",
            "US6810017",
            "US6845395 *",
            "US6892227",
            "US6941358",
            "US6996741",
            "US7047293 *",
            "US7062783",
            "US7154857",
            "US7260628 *",
            "US7272654",
            "US7373399 *",
            "US7392307 *",
            "US7409480 *",
            "US7447692",
            "US7480860",
            "US7483861",
            "US7506145",
            "US7587422",
            "US7590986 *",
            "US7596616",
            "US7640549 *",
            "US7689600 *",
            "US7694117",
            "US7698251 *",
            "US7720796",
            "US7779389",
            "US7793087",
            "US7797522",
            "US7802067",
            "US7805564 *",
            "US7809739",
            "US7831641",
            "US7840902 *",
            "US7870538",
            "US7890719",
            "US7933983 *",
            "US7937527",
            "US7954087",
            "US7979536",
            "US8051244",
            "US8087026",
            "US8103670",
            "US8103829",
            "US8131689",
            "US8176248",
            "US8180843",
            "US8190741",
            "US8195627",
            "US8201189",
            "US8219576",
            "US8271769",
            "US8301809 *",
            "US8301810 *",
            "US8332863",
            "US8375168",
            "US8447762",
            "US8495202 *",
            "US8539081",
            "US8635329",
            "US8725731",
            "US8751711",
            "US8832697",
            "US8838750",
            "US8843918",
            "US8849894",
            "US8938534",
            "US8972612",
            "US9038023",
            "US9058323",
            "US9069639 *",
            "US20020152302 *",
            "US20040117476 *",
            "US20040167942 *",
            "US20040186881 *",
            "US20040221049 *",
            "US20040249937 *",
            "US20040267752 *",
            "US20040267831 *",
            "US20050005044 *",
            "US20050005063 *",
            "US20050033914 *",
            "US20060136688 *",
            "US20110209141 *",
            "CN101263494B",
            "EP1573568A1 *",
            "WO2004061697A1 *",
            "WO2005045566A2 *",
            "WO2007041456A2 *"
        ],
        [
            "Filing date",
            "Aug 25, 1998",
            "Jul 6, 1999",
            "Jun 11, 1999",
            "Dec 21, 2001",
            "Aug 19, 2002",
            "Dec 21, 2001",
            "Dec 21, 2001",
            "Aug 19, 2002",
            "Jun 30, 1999",
            "Dec 21, 2001",
            "Dec 21, 2001",
            "Jun 28, 2002",
            "Feb 14, 2001",
            "Dec 21, 2001",
            "Dec 21, 2001",
            "Sep 6, 2002",
            "Mar 4, 2004",
            "May 9, 2002",
            "Feb 14, 2001",
            "Nov 25, 2002",
            "Nov 24, 2003",
            "Apr 23, 2001",
            "Dec 21, 2001",
            "Dec 30, 2005",
            "Apr 23, 2004",
            "Jun 30, 2004",
            "Jul 27, 2007",
            "Jul 22, 2002",
            "Dec 30, 2005",
            "Dec 30, 2005",
            "Apr 27, 2006",
            "Jan 3, 2006",
            "Dec 30, 2005",
            "Dec 30, 2005",
            "Dec 30, 2005",
            "Jul 13, 2007",
            "Jul 26, 2004",
            "Aug 5, 2005",
            "Apr 26, 2004",
            "Oct 26, 2005",
            "Dec 30, 2005",
            "Jul 2, 2009",
            "Dec 17, 2002",
            "Sep 17, 2009",
            "Dec 30, 2005",
            "Mar 26, 2008",
            "Jan 28, 2011",
            "Apr 27, 2006",
            "Oct 30, 2008",
            "Jun 22, 2010",
            "Oct 2, 2006",
            "Sep 23, 2011",
            "Jan 24, 2008",
            "Mar 31, 2006",
            "Sep 30, 2005",
            "Dec 30, 2005",
            "Jul 9, 2010",
            "Dec 30, 2005",
            "Jan 20, 2004",
            "Oct 11, 2005",
            "Sep 1, 2011",
            "Apr 16, 2012",
            "Aug 14, 2007",
            "Jul 28, 2004",
            "Sep 15, 2004",
            "Jan 30, 2006",
            "Jan 23, 2012",
            "Dec 17, 2010",
            "Jun 29, 2006",
            "Dec 30, 2005",
            "Dec 30, 2005",
            "Dec 30, 2005",
            "Dec 22, 2011",
            "Apr 5, 2012",
            "Dec 30, 2005",
            "Jan 20, 2012",
            "Feb 25, 2010",
            "Feb 14, 2001",
            "Dec 17, 2002",
            "Nov 24, 2003",
            "Dec 16, 2003",
            "May 19, 2004",
            "Mar 24, 2004",
            "Apr 23, 2004",
            "Apr 26, 2004",
            "Jan 20, 2004",
            "May 24, 2004",
            "Jul 26, 2004",
            "Oct 11, 2005",
            "Feb 25, 2010",
            "Oct 2, 2006",
            "Dec 16, 2003",
            "Dec 16, 2003",
            "Jul 22, 2004",
            "Oct 2, 2006"
        ],
        [
            "Publication date",
            "Aug 6, 2002",
            "Oct 29, 2002",
            "Feb 11, 2003",
            "Mar 30, 2004",
            "Apr 27, 2004",
            "Jun 22, 2004",
            "Sep 7, 2004",
            "Oct 26, 2004",
            "Jan 18, 2005",
            "May 10, 2005",
            "Sep 6, 2005",
            "Feb 7, 2006",
            "May 16, 2006",
            "Jun 13, 2006",
            "Dec 26, 2006",
            "Aug 21, 2007",
            "Sep 18, 2007",
            "May 13, 2008",
            "Jun 24, 2008",
            "Aug 5, 2008",
            "Nov 4, 2008",
            "Jan 20, 2009",
            "Jan 27, 2009",
            "Mar 17, 2009",
            "Sep 8, 2009",
            "Sep 15, 2009",
            "Sep 29, 2009",
            "Dec 29, 2009",
            "Mar 30, 2010",
            "Apr 6, 2010",
            "Apr 13, 2010",
            "May 18, 2010",
            "Aug 17, 2010",
            "Sep 7, 2010",
            "Sep 14, 2010",
            "Sep 21, 2010",
            "Sep 28, 2010",
            "Oct 5, 2010",
            "Nov 9, 2010",
            "Nov 23, 2010",
            "Jan 11, 2011",
            "Feb 15, 2011",
            "Apr 26, 2011",
            "May 3, 2011",
            "May 31, 2011",
            "Jul 12, 2011",
            "Nov 1, 2011",
            "Dec 27, 2011",
            "Jan 24, 2012",
            "Jan 24, 2012",
            "Mar 6, 2012",
            "May 8, 2012",
            "May 15, 2012",
            "May 29, 2012",
            "Jun 5, 2012",
            "Jun 12, 2012",
            "Jul 10, 2012",
            "Sep 18, 2012",
            "Oct 30, 2012",
            "Oct 30, 2012",
            "Dec 11, 2012",
            "Feb 12, 2013",
            "May 21, 2013",
            "Jul 23, 2013",
            "Sep 17, 2013",
            "Jan 21, 2014",
            "May 13, 2014",
            "Jun 10, 2014",
            "Sep 9, 2014",
            "Sep 16, 2014",
            "Sep 23, 2014",
            "Sep 30, 2014",
            "Jan 20, 2015",
            "Mar 3, 2015",
            "May 19, 2015",
            "Jun 16, 2015",
            "Jun 30, 2015",
            "Oct 17, 2002",
            "Jun 17, 2004",
            "Aug 26, 2004",
            "Sep 23, 2004",
            "Nov 4, 2004",
            "Dec 9, 2004",
            "Dec 30, 2004",
            "Dec 30, 2004",
            "Jan 6, 2005",
            "Jan 6, 2005",
            "Feb 10, 2005",
            "Jun 22, 2006",
            "Aug 25, 2011",
            "Dec 22, 2010",
            "Sep 14, 2005",
            "Jul 22, 2004",
            "May 19, 2005",
            "Apr 12, 2007"
        ],
        [
            "Applicant",
            "Highground Systems, Inc.",
            "Pcorder.Com, Inc.",
            "Dell Usa, L.P.",
            "Networks Associates Technology, Inc.",
            "Networks Associates Technology, Inc.",
            "Networks Associates Technology, Inc.",
            "Networks Associates Technology, Inc.",
            "Networks Associates Technology Inc.",
            "Emc Corporation",
            "Networks Associates Technology, Inc.",
            "Networks Associates Technology, Inc.",
            "Xiotech Corporation",
            "Ricoh Co., Ltd.",
            "Mcafee, Inc.",
            "Mcafee, Inc.",
            "Hitachi, Ltd.",
            "Sandbox Networks, Inc.",
            "Hewlett-Packard Development Company, L.P.",
            "Ricoh Co., Ltd.",
            "Sony Corporation",
            "Commvault Systems, Inc.",
            "Versata Computer Industry Solutions, Inc.",
            "Mcafee, Inc.",
            "Sap Ag",
            "Neopath Networks, Inc.",
            "Sun Microsystems, Inc.",
            "Hitachi, Ltd.",
            "Agilent Technologies, Inc.",
            "Sap Ag",
            "Sap Ag",
            "International Business Machines Corporation",
            "Neopath Networks, Inc.",
            "Sap Ag",
            "Sap Ag",
            "Sap Ag",
            "Commvault Systems, Inc.",
            "Hitachi, Ltd.",
            "International Business Machines Corporation",
            "Neopath Networks, Inc.",
            "Hewlett-Packard Development Company, L.P.",
            "Sap Ag",
            "Commvault Systems, Inc.",
            "Hewlett-Packard Development Company, L.P.",
            "Hitachi, Ltd.",
            "Sap Ag",
            "Ricoh Co., Ltd.",
            "Hitachi, Ltd.",
            "International Business Machines Corporation",
            "Commvault Systems, Inc.",
            "Commvault Systems, Inc.",
            "Panagiotis Tsirigotis",
            "Hitachi, Ltd.",
            "Neopath Networks, Inc.",
            "Neopath Networks, Inc.",
            "Neopath Networks, Inc.",
            "Sap Ag",
            "Sanwork Data Mgmt L.L.C.",
            "Sap Ag",
            "Infortrend Technology, Inc.",
            "Infortrend Technology, Inc.",
            "International Business Machines Corporation",
            "Hitachi, Ltd.",
            "Sanwork Data Mgmt. L.L.C.",
            "Brother Kogyo Kabushiki Kaisha",
            "Neopath Networks, Inc.",
            "Ricoh Co., Ltd.",
            "Commvault Systems, Inc.",
            "Microsoft Corporation",
            "Cisco Technology, Inc.",
            "Sap Ag",
            "Sap Ag",
            "Sap Ag",
            "Ss8 Networks, Inc.",
            "SSB Networks, Inc.",
            "Sap Se",
            "Ss8 Networks, Inc.",
            "Red Hat, Inc.",
            "Ricoh Co. Ltd.",
            "Doug Steele",
            "Oshinsky David Alan",
            "Emc Corp.",
            "Emc Corporation",
            "Hidekazu Tachihara",
            "Wong Thomas K.",
            "Wong Thomas K.",
            "Ling-Yi Liu",
            "Ling-Yi Liu",
            "Hitachi, Ltd.",
            "Ching-Te Pang",
            "Red Hat, Inc.",
            "\u65b0\u9014\u5f84\u7f51\u7edc\u516c\u53f8",
            "Emc Corporation",
            "Emc Corp",
            "Microsoft Corp",
            "Neopath Networks Inc"
        ],
        [
            "Title",
            "Method and apparatus for providing data storage management",
            "Method for compiling and selecting data attributes",
            "Policy based storage configuration",
            "Enterprise network analyzer agent system and method",
            "Graphical user interface system and method for visually gauging network performance",
            "Enterprise network analyzer architecture framework",
            "Enterprise network analyzer host controller/agent interface system and method",
            "Graphical user interface system and method for organized network analysis",
            "Method and apparatus for identifying network devices on a storage network",
            "Enterprise network analyzer host controller/zone controller interface system and method",
            "Enterprise interface for network analysis reporting",
            "System and method for redundant communication between redundant controllers",
            "Method and system of remote diagnostic, control and information collection using multiple formats and multiple protocols with delegating protocol processor",
            "Comprehensive enterprise network analyzer, scanner and intrusion detection framework",
            "Enterprise network analyzer zone controller system and method",
            "Event notification in storage networks",
            "Virtualizing network-attached-storage (NAS) with a compact table that stores lossy hashes of file names and parent handles rather than full names",
            "System and method for an enterprise-to-enterprise compare within a utility data center (UDC)",
            "Method and system of remote diagnostic, control and information collection using a shared resource",
            "Electronic equipment, method of receiving data, method of transmitting data, method of setting channel and method of grouping electronic equipment into channels",
            "Logical view and access to data managed by a modular data and storage management system",
            "Data document generator to generate multiple documents from a common document using multiple transforms",
            "System, method and computer program product for a network analyzer business model",
            "Calculated values in system configuration",
            "Transparent file replication using namespace replication",
            "Methods and apparatus supporting access to multiple devices via a pseudo device driver",
            "Event notification method in storage networks",
            "System and method for efficiently exchanging data among processes",
            "System and method for cluster file system synchronization",
            "Virtualized and adaptive configuration of a system",
            "Fault tolerant facility for the aggregation of data from multiple processing units",
            "Directory and file mirroring for migration, snapshot, and replication",
            "System and method for dynamic VM settings",
            "Configuration templates for different use cases for a system",
            "Meta attributes of system configuration elements",
            "Interface systems and methods for accessing stored data",
            "Display apparatus and its method for displaying connections among a host, a logical unit and a storage system in a virtual storage system",
            "Application configuration in distributed storage systems",
            "Large file support for a network file server",
            "Method and an apparatus for automatic creation of secure connections between segmented resource farms in a utility computing environment",
            "Configuration inheritance in system configuration",
            "System and method for performing time-flexible calendric storage operations",
            "Method and system for performing load balancing across control planes in a data center",
            "Storage system for sending an access request from a host to a storage subsystem",
            "Template integration",
            "Method and system of remote diagnostic, control and information collection using a dynamic linked library for multiple formats and multiple protocols with sharing the resource",
            "Storage system for sending an access request from a host to a storage subsystem",
            "Fair share scheduling based on an individual user's resource usage and the tracking of that usage",
            "Systems and methods for retrieving data in a computer network",
            "Hierarchical systems and methods for performing storage operations in a computer network",
            "Accumulating access frequency and file attributes for supporting policy based storage management",
            "Method and system of collection performance data for storage network",
            "Transparent file migration using namespace replication",
            "Customizing a namespace in a decentralized storage environment",
            "Storage policy monitoring for a storage network",
            "System and method for filtering components",
            "Storing lossy hashes of file names and parent handles rather than full names using a compact table for network-attached-storage (NAS)",
            "Dynamic adaptation of a configuration to a system environment",
            "Storage virtualization computer system and external controller thereof",
            "SAS storage virtualization controller, subsystem and system using the same, and method therefor",
            "Fair share scheduling based on an individual user's resource usage and the tracking of that usage",
            "Method and system of collection performance data for storage network",
            "Storing lossy hashes of file names and parent handles rather than full names using a compact table for network-attached-storage (NAS)",
            "Imaging device information management system",
            "Enabling proxy services using referral mechanisms",
            "Method and system of remote diagnostic, control and information collection using multiple formats and multiple protocols with delegating protocol processor",
            "Systems and methods for retrieving data in a computer network",
            "Storage topology manager",
            "Parallel filesystem traversal for transparent mirroring of directories and files",
            "System and method for system information centralization",
            "System and method for deployable templates",
            "Method and system using parameterized configurations",
            "Automatic provisioning of new users of interest for capture on a communication network",
            "Collecting asymmetric data and proxy data on a communication network",
            "Template-based configuration architecture",
            "System for accessing a set of communication and transaction data associated with a user of interest sourced from multiple different network carriers and for enabling multiple analysts to independently and confidentially access the set of communication and transaction data",
            "Managing a user proxy configuration in a daemon that frequently loads and unloads",
            "Method and system of remote diagnostic, control and information collection using multiple formats and multiple protocols with delegating protocol processor",
            "Method and system for performing load balancing across control planes in a data center",
            "Logical view and access to data managed by a modular data and storage management system",
            "Automated media library configuration",
            "Method and apparatus for identifying network devices on a storage network",
            "Performance management method, system and program",
            "Transparent file replication using namespace replication",
            "Large file support for a network file server",
            "Storage virtualization computer system and external controller therefor",
            "Jbod subsystem and external emulation controller thereof",
            "Disk storage system",
            "Redundant SAS storage virtualization subsystem and system using the same, and method therefor",
            "Managing a user proxy configuration in a daemon that frequently loads and unloads and is used by multiple users simultaneously",
            "Method and device for monitoring affair related with object of storage network",
            "Automated media library configuration",
            "Automated media library configuration",
            "Mechanism for analyzing partially unresolved input",
            "Accumulating access frequency and file attributes for supporting policy based storage management"
        ]
    ],
    "pageTitle": "Patent US6314460 - Method and apparatus for analyzing a storage network based on incomplete ... - Google Patents",
    "title": "",
    "url": "http://www.google.com/patents/US6314460?dq=7,446,777",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988317.67/warc/CC-MAIN-20150728002308-00191-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 496061559,
    "recordOffset": 495976567,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{161174=NeworkImages 501, as explained previously, is the base object which contains information about the contents of the management set. It contains MonitorList 1501, which is a list of Network objects 502, and HostList 1502, which is a list of Host objects 515, in the management set., 139774=Referring to the example storage network of FIG. 1, this process will be described as performed by the network daemon within host 111. At step 1301, the daemon initially selects controller 130 (C130) as its base, and builds the following network map as seen by C130:, 149797=In the planning mode, a user can plan the configuration of one or more storage networks using the interactive virtual canvas. The user selects icons to create devices to be configured in the network, then selects connections to specify the topology of connections. At each step of the hypothetical configuration, the manager automatically determines possible connections for the next step and highlights these for the benefit of the user. The user may edit the configuration by adding, deleting or moving devices and connections, and may save the configuration. The user may begin a planning mode of operation with a blank canvas, with an existing saved configuration, or with an actual network configuration determined by a discover operation. The planning mode of operation is described in greater detail in related commonly assigned co-pending application Ser. No. 08/962,201, filed Oct. 31, 1997, by Gary T. Axberg et al., entitled \u201cStorage Network Management Mechanism\u201d., 177020=The manager then pops the first element of UDL 2002 for parsing, i.e., B111 (step 1604). Again, the \u201cNo\u201d branches are taken from steps 1605 and 1701, and the LL_ListPrimaryConn call is made to the local agent in Host 111 (step 1702). This call specifies connections of the type returned earlier when the LL_TypeConnections call was made (step 1709) after H111 was found. The local agent will return a list containing three elements: Host 111, Controller 130 (C130), and Controller 131 (C131). These are processed in turn by the manager. Host 111 has already been placed on the lists, so steps 1706, 1712 and 1710 are executed with no action taken Upon analyzing Controller 130, steps 1706-1710 are executed, creating a Controller object in DiscoverResults for Controller 130, adding it to the lists, and calling the local agent to obtain type connections and attribute information. The manager does the same for Controller 131. Bi111 is then set to parsed. FIG. 20D shows the condition of the DiscoverResults lists after Bi111 has been parsed., 166785=If the current object supports the RDE_HostLabel attribute (step 1605), then the attribute must be checked. Typically, this attribute is found in certain adapter devices. The reason for this check is to discover hosts which were not on the original host list (not part of the originally specified management set), but which are nevertheless interconnected with the storage network. Some (but not all) types of adapters will respond with identifying information when polled by a different adapter in another host. These adapters will contain the RDE_HostLabel attribute, identifying the host within which the adapter resides. By checking this attribute, it is possible to determine whether the host is on host list 2010. This check is performed by issuing a LL_GetAttr command to obtain the RDE_HostLabel attribute at step 1606; comparing the attribute (host name) with the entries on host list 2010 to determine if the host exists at step 1607; and, if not, creating a host object, and adding a reference to this object to DL 2001, UDL 2002, and host list 2010 in the DiscoverResults object, at step 1608., 162659=IThread 1520 is the Open Class Library implementation of a thread. Networkimages creates an IThread object for performing the discover operation, and the object is destroyed at the conclusion of the discover. IThreadFn 1521 is an abstract thread functions class, representing secondary threads of execution, created as part of the discover operation. DiscoverThread 1522 is the concrete implementation of ITkreadFn which performs the discover. NetworkImages' discover( ) method creates a DiscoverThread object, which is destroyed after the discover operation concludes., 168487=The current object is parsed by first issuing a LL_ListPrimaryConn call to the local agent of the appropriate host at step 1702. As explained earlier, the local agent returns a list of devices which form a primary connection with the current object. The manager then parses this list of primary connections. While another primary connection exists (step 1703), the manager processes each connected-to object in turn (steps 1704-1714). The manager checks whether the connected-to object is on the block list 2004 at step 1704. If the object is on the block list, it is not to be included in the current management set, nor is it to be further parsed for objects to include in the management set. Typically, the block list is a list of adapters. Thus, the user may specify a host to be part of the management set, but may selectively exclude certain adapters within that host from the management set. By excluding the adapter, any disks or other devices which attach to the adapter are inherently excluded (unless, of course, they also attach to another adapter which is part of the management set)., 197511=In the case of a new management set, it is only necessary to create the appropriate network objects and link all components of a network to their respective network objects. A network object is defined by controllers. I.e., starting with a controller, the network includes all device buses to which the controller is attached, and all devices on those buses. If those devices include other controllers, it is necessary to iteratively repeat the process and include in the network all buses to which the other controllers are attached, and devices attached to those buses, until a closed set of devices and buses is determined. This set then constitutes a network. It is possible for multiple networks to exist within a single management set, so once one network has been determined, the above process repeats for all controllers not yet associated with a network, until all controllers in the management set have been associated with some network. At that point, the manager may clean up any unneeded data structures, such as the DiscoverResults object 1511., 121347=The bulk of topology information is contained in collections 1202 and 1203. Adapter collection 1202 contains one adapter record 1220 for each adapter located in the host system containing the local agent. SSA node collection 1203 contains one SSA node record 1250 for each SSA node on a SSA bus attached to an adapter in the same host system. The adapter itself is represented by two SSA node records, since an adapter has two pairs of ports (may be attached to two separate SSA buses)., 170381=If at step 1706, the connected-to object is on the device list, it is not necessary to execute steps 1707-1709. However, there is a special case, where the current object is a special type of device bus controller (designated \u201cM\u201d adapter) and the connected-to object is a device bus, as shown by the branch at step 1712. A controller of this type can not determine the identity of other controllers on the device bus; at best, it can only determine that there is a device of unknown type at a particular location on the bus. In order to determine the identity of all controllers, it is necessary to request each host to report the devices it can see on the device bus from its controller(s), and to subsequently resolve the results in the manager. The local agent will resolve the identity of multiple controllers on the same SSA bus within the same host, as described more fully above. The device bus will only be added once to the UDL. In order to force the manager to get information from all hosts connected to the device bus, the manager will immediately issue a LL_ListPrimaryConn command for the connected-to object (i.e., the device bus) at step 1713, if the conditions above are met. The manager then creates an object in DiscoverResults for any new devices, adds them to the DL, UDL and appropriate individual list, and creates a Connection object in DiscoverResults to represent the connection to such devices (step 1714). While represented in FIG. 17 as a single step, step 1714 is essentially the same as steps 1703-1710, performed for each device returned by the LL_ListPrimaryConn command in step 1713., 120408=FIGS. 12A through 12C illustrate the major data structures held in shared memory 1003. FIG. 12A shows the overall structure of topology information in shared memory. This includes header block 1201, a collection of adapter records 1202, a collection of SSA node records 1203, hash table for device universal identifiers 1204, and table of string number universal identifiers 1205. Header block 1201 defines the memory allocation for shared memory 1003 and includes certain additional information such as the process ID of the network daemon. Hash table 1204 is used for rapid (semi-random) access to a particular SSA node record in collection 1203, as explained below. String table 1205 is used to store the universal identifier of strings of devices (as used here, \u201cstring\u201d means an SSA bus, and includes a closed string, or loop, topology)., 178258=The manager then repeats this process in turn for the next two elements on UDL, B112 and B113. As in the earlier case of discovering buses, it is not necessary to execute step 1709 since the controller information (device type) has already been obtained. FIG. 20E shows the condition of the DiscoverResults lists after B113 has been parsed., 38267=The present application is related to commonly assigned application Ser. No. 08/962,201, filed Oct. 31, 1997, by Gary T. Axberg et al., entitled \u201cStorage Network Management Mechanism\u201d, now U.S. Pat. No. 6,009,466 which is herein incorporated by reference., 193509=The manager continues to compare the remaining substrings. Substring 2112 matches string 2108. As a result, unknown U1 b can be resolved to controller C133, and unknowns U3 b and U3 c can be resolved to controllers C130 and C131, respectively. The remaining substrings produced from host 111 can be matched to other strings, but they do not produce any additional resolved devices., 490710=name=Scorpion1100, 106205=Shared memory 1003 is not a physically distinct memory, but simply a set of data structures in system memory 402 which are used by two independently running threads, local library 1001 and daemon 1002. Local library 1001 has read-only access to shared memory 1003, while daemon 1002 has read/write access. Semaphores are used for locking so that library 1001 will not read the contents of memory 1003 while daemon 1002 is updating it., 152118=Menu bar 1402 contains the following choices: File, Edit, View, Management Set, Tools, and Help., 38850=Ser. No. 09/183,716, filed Oct. 30, 1998, by Greg Knight et al., entitled \u201cMethod and Apparatatus for Invoking Network Agent Function Using a Hash-Table\u201d, which is herein incorporated by reference., 105596=Local library 1001 is an independently running thread which forms the central control portion of local agent 431. It communicates with the manager by making remote procedure calls, invokes operating system functions, obtains data from shared memory, and directly communicates with storage adapters when necessary. Network daemon 1002 is an independently running thread executing concurrently on CPU 401. Daemon 1002 continually monitors the state of the storage adapters in its host system, and writes this state information in shared memory 1003., 192733=The manager then selects substring 2111 and compares it with all strings from hosts other than host 111, i.e., strings 2105-2108. Upon making the comparison, the manager will find that substring 2111 matches string 2106. As a result, it is possible to resolve unknown devices U1 a, U2 a and U2 b. Substring 111 generated from host 111 placed unknown U1 a in the position matching controller C132 in string 2106, and therefore unknown device U1 a is resolved to controller C132. Unknowns U2 a and U2 b are similarly resolved to controllers C130 and C131, respectively., 189580=After all devices have been resolved (or all hosts examined in an attempt to resolve them), the manager deletes the resolved unknown device objects, removing them from device list 2001 (step 1820). The manager then creates any additional required Connection objects (step 1821). Additional Connection objects may be required where unknown objects have been resolved, as e.g., two controllers of \u201cM\u201d type in different hosts which are directly connected by a single link. In this instance, no Connection object could have been created during the parsing operation because neither host had a complete picture of the link. Alternatively, additional Connection objects may be required where it is impossible to resolve unknown devices. In this case, the Connection object was not created earlier because it was not known whether it would be possible to resolve the device. If the resolution procedure has been completed and the devices remain of unknown type, a Connection object should be created linking the unknown device with another device on the bus, in order to generate as complete a representation of the configuration topology as possible. If there are additional buses to analyze (step 1822), the manager returns to step 1801. When all buses have been analyzed, the resolution process is complete., 184486=FIG. 18 is a flow diagram of the resolution process. The manager first examines the list of unknown device objects 2015 to determine which hosts reported unknown devices (and for which buses) during the parsing phase (step 1801). It then selects a bus for analysis. If there is only one host in the host list connected to the selected bus (step 1803), it will be impossible to further resolve the unknowns, and the resolution process goes to step 1820., 140283=This network is actually a loop, gap3 connecting back to C130. At step 1302, the daemon selects C131 and identifies two cross reference devices, one on either side of C131. The nearest devices are D125 and D120, which are selected. The following cross reference object data structures are created:, 105278=FIG. 10 is a high-level view of the agent and its interactions. Local agent 431 is programming code and associated data residing in a host system, executing on its CPU 401. Agent 431 includes local library 1001, network daemon 1002, and shared memory 1003., 511520=Connections=P1-S1:1 S1:2-S2:1 S2:2-S3:1 S3:2-S4:1 S4:2-P2 P3-S5:1 S5:2-S 6:1 S6:2-S7:1 S7:2-S8:1 S8:2-P4 P5-S9:2 S9:1-S10:2 S10:1-S11:2 S11:1-S12:2 S12:1-P6 P7-S13:2 S13:1-S14:2 S14:1-S15:2 S15:1-S16:2 S16:1-P8, 490994=attrib=RDE_SizeInMB[1100 MB], 129360=Like the local library, network daemon 1002 operates on a timed life cycle. Specifically, shared memory 1003 is available to local library 1001 only when network daemon 1002 is active. If local library 1001 needs to access the data in shared memory 1003 and network daemon 1002 is inactive, local library 1001 starts the network daemon via a UNIX fork( ) & exec( ) operation. It then waits a predetermined time, and retries the access to shared memory. Upon starting the network daemon, a UNIX alarm( ) function time is started. The timeout period is preferably 15 minutes. However, local library 1001 also sends the network daemon a signal via the UNIX signal( ) function whenever local library accesses data in shared memory 1003. Upon receipt of this signal, the network daemon resets the alarm timer to the full original timeout period. The expiration of the timeout period causes a timer signal to shut down the network daemon. Upon receipt of this signal, the network daemon self-terminates, removing its data from shared memory 1003. Thus, the network daemon will remain active so long as the data in shared memory 1003 is accessed at intervals of less than 15 minutes., 126595=Device UID field 1253 contains the universal identifier of the device at this SSA node. Device type field 1254 contains the type of device. UID is valid 1255 is a flag indicating whether the value in field 1253 is valid; in the case of unknown devices, the network daemon will create a fictitious identifier to distinguish the unknown device record from other records. This adapter number field 1258 contains an index to an adapter record for an adapter connected to the same SSA bus. Where multiple adapters are connected to the same SSA bus, the daemon arbitrarily chooses one. Field 1258 is used to access the device through an adapter, so if there are multiple adapters, it doesn't matter which one is used. This network index field 1259 specifies which pair of ports (SSA bus) on the adapter is connected to the device. Reserved field 1262 is not used. Total ports number field 1263 contains the number of ports on this device; this allows for future accommodation of storage devices having more than two ports. Error event time field 1264 indicates when this SSA node last reported an error event., 128148=Port1 next device index field 1270 and port2 next device index field 1271 contain pointers to the SSA node record of devices attached to port1 and port 2 respectively of the current device. Port1 next device port field 1272 and port2 next device port field 1273 indicate which port number on the next device is attached to port 1 and port 2 respectively of the current device. In some cases (specifically, where type \u201cM\u201d adapters are used), the daemon is unable to determine which port numbers are used. In this case, port numbers are arbitrarily assumed for purposes of entering data in fields 1271-1274, and port uncertain flag 1261 is set to indicate that the daemon really doesn't know which ports are being used., 174404=The manager then sees that the UDL is not empty, and pops the first element on the UDL to become the current object. This element is Host 111 (H111). Host 111 does not support RDE_HostLabel, so the \u201cNo\u201d branch is taken from step 1605. Since Host 111 is parsable, the \u201cNo\u201d branch is taken from step 1701, and the parse routine of FIG. 17 is performed. The manager calls LL_ListPrimaryConn, specifying Host 111 as the source and all devices of the type returned by the LL_TypeConnections call (made in step 1602) as the desired target. The only primary connection for Host 111 will be its internal bus not shown in FIG. 1, designated B111. The local agent residing in Host 111 returns a list of primary connections containing this single element. The manager then verifies that its internal bus (B111) is not on block list 2004 (step 1704). Since B111 is not on DL 2001 (step 1706), the manager creates an object of type HostBus to represent B111, adding it to DL, UDL and the host bus list 2014 (step 1707). B111 is a new device type because it is the first host bus encountered in parsing the network. Therefore, the manager issued LL_TypeConnections and LL_SupportedAttr calls to the local agent in Host 111 (step 1709), in order to determine the types of devices which may connect to B111. At this point, no further elements remain on the list of elements returned by the local agent in response to the LL_ListPrimaryConn call, so the manager takes the \u201cNo\u201d branch from step 1703, and sets H111 to \u201cparsed\u201d. The condition of the DiscoverResults lists at this point is shown in FIG. 20B. On the DL, H111 is shown in bold to indicate that it has already been parsed., 181594=The manager repeats this process for the remaining two controllers. Again, the \u201cYes\u201d branch is taken from step 1712, resulting in LL_ListPrimaryConn calls to hosts 112 and 113, requesting all connections to device bus L 120. The disks are known, but these calls will find additional unknown devices, which are actually the controllers in the other hosts. Additionally, when calling host 112, it will be possible to identify the link between controller 132 and disk 124 as a known connection (and similarly for the link between controller 133 and disk 129 when calling host 113). These connection objects therefore are created and added to list 2016. FIG. 20H shows the condition of DiscoverResults after parsing the last controller, C133. Note that Connection objects for all device bus connections now appear on list 2016, except the link between controllers C132 and C133., 512255=Resiliency=S1:1-S16:1 S4:2-S5:1 S8:2-S9:1 S12:1-S13:2, 40267=One example of alternative configurations is the rapidly increasing popularity of so-called \u201cRAIDs\u201d, i.e., redundant arrays of independent disks. A RAID stores data on multiple storage devices in a redundant fashion, such that data can be recovered in the event of failure of any one of the storage devices in the redundant array. RAIDs are usually constructed with rotating magnetic hard disk drive storage devices, but may be constructed with other types of storage devices, such as optical disk drives, magnetic tape drives, floppy disk drives, etc. Various types of RAIDs providing different forms of redundancy are described in a paper entitled \u201cA Case for Redundant Arrays of Inexpensive Disks (RAID))\u201d, by Patterson, Gibson and Katz, presented at the ACM SIGMOD Conference, June, 1988. Patterson, et al., classify five types of RAIDs designated levels 1 through 5. The Patterson nomenclature has become standard in the industry., 167973=The steps required to paste current object ae represented genericaUy as block 1610 in FIG. 16, and are broken down into greater detail in FIG. 17. At step 1701, the manager first determines whether the current object requires parsing. I.e., disk storage devices are at the end of the parsing hierarchy, and need not be parsed. If the device is of this type, further processing is by-passed by going directly to step 1720, where the current object is set to \u201cparsed\u201d., 51735=FIGS. 12A through 12C illustrate the major data structures held in shared memory 1003 of a local agent, in accordance with the preferred embodiment., 107355=Object Database Management facility 1010 (ODM) is a portion of operating system 421 which maintains a database concerning \u201cobjects\u201d, and provides an application programming interface (API) to the database, whereby an application may make queries of the database. The \u201cobjects\u201d which are the subject of this database are various components of host system 111, and are not to be confused with programming \u201cobjects\u201d in an object-oriented programming environment. For example, ODM maintains information about buses, adapters, disk storage devices, and other components of system 111. Local library 1001 and daemon 1002 access this information through the odm_get_list, odm_change_obj, and getattr APIs to operating system 421., 151146=FIG. 14 illustrates the appearance of the display screen during the monitoring mode of operation for an example storage network configuration. In reality, the management program appears in a window which may occupy less than the full area of a display screen, but it is shown in FIG. 14 as the full screen for clarity. The management program main window includes a canvas area 1401 for displaying one or more storage networks, a menu bar 1402 for activating various pull-down menus, toolbar 1403 for certain frequently used functions, and a parts palette 1404 for components that can be used to embellish the view of a storage network on the canvas. The window further includes information area 1405 for displaying status information or help text for specific functions, and event status indicator 1406 which indicates whether events have occurred which may have changed the status or configuration of devices., 190938=The operation of this procedure on the example network of FIG. 1 will now be described. FIGS. 21A through 21C illustrates the strings and substrings created during resolution of the example network of FIG. 1. As shown in FIG. 20J, several unknown devices remain after parsing this example. The manager determines at step 1801 that a single bus contains multiple unknown devices, and at step 1803 that more than one host exist on this bus. At step 1804, the manager issues the LL_ListPrimaryConn command to all hosts, i.e., hosts 111, 112 and 113. At step 1805, the manager builds strings for each controller found in each host. These strings are shown in FIG. 21A. Strings 2101-2104 are constructed for host 111, strings 2105-2106 are for host 112, and stings 2107-2108 are for host 113., 109627=Both the ODM facility 1010 and ssaraid facility 1012 are particular facilities available in the operating system of the preferred embodiment, i.e., IBM's AIX operating system. Other operating systems may offer different facilities from which this information could be obtained. Alternatively, if necessary information is not available from an operating system utility, some part of the local agent could maintain the information. E.g., the daemon could maintain the information in shared storage., 183488=The remaining devices are then popped from the UDL in turn. These devices are either disks or unknown devices, and are unparsable in either case. Therefore, \u201cYes\u201d branch from step 1701 is taken in each case, and the device is marked as parsed. When the last device (U3 c) is popped from the UDL and marked \u201cparsed\u201d, the \u201cYes\u201d branch is taken from step 1603, and the parsing operation terminates. The condition of DiscoverResults lists at the end of the parsing operation is shown in FIG. 20J., 198807=The compare process involves a \u201cshallow\u201d compare, shown as blocks 1901-1905, and a \u201cdeep\u201d compare, shown as blocks 1910-1916. The shallow compare selects in turn each old device in the management set for comparison (step 1901). If the selected device matches one of the found devices (step 1902), i.e., a device on device list 2001 in the DiscoverResults object 1511, then the newly found device object in device list 2001 is added to the collection of device objects in the ProcessResults object 1512 (step 1903). If no device in device list 2001 matches the selected device, the selected device is added to a list of \u201cmissing\u201d devices (step 1904), each network object having an associated list of missing devices. Additionally, the connections and ports associated with the missing device are added to respective lists of missing connections and missing ports. A message is also generated to indicate that the device was not found. If there are more devices to compare (step 1905), the process repeats until all old devices have been examined., 106729=Local library 1001 communicates with the central manager through the operating system's remote procedure call facility 1014. In the preferred embodiment, facility 1014 handles all the interface details. The local library merely utilizes the appropriate operating system supplied programming interfaces to its remote procedure call facility. Library 1001 does not concern itself with the details of the interface protocol, this being an operating system function. It would, however, alternatively be possible to incorporate the remote communication function into the local agent., 173327=When all connected-to objects returned by the LL_ListPrimaryConn call have been processed as described, the current object is set to \u201cparsed\u201d at step 1720, meaning that an appropriate flag in the object is set. The manager would then return to step 1603 to consider whether the UDL is now empty. When the UDL is empty, the entire management set has been parsed., 172490=After performing steps 1707-1709 as required, or the branch represented as steps 1712-1714 as required, the manager creates any required Connection object(s) at step 1710. I.e., if the connected-to device is something on an SSA bus such as a storage device, there must be one or two Connection objects representing the binary links to the ports of the connected-to device. If a Connection object has not yet been created, and objects now exist to represent both devices at each end of a binary link, the Connection object is created in step 1710, with links being established to the two objects Such a Connection object is created only if the devices at both ends of the binary link are known. The manager then returns to step 1703 to get the next connected-to object., 121895=FIG. 12B shows the structure of an adapter record 1220. Adapter record 1220 contains the following fields. Adapter name field 1221 identifies the adapter's name as known to ODM 1010. Adapter UID field 1222 contains the universal identifier of the adapter. Adapter serial number field 1223 contains the hardware serial number of the adapter. Smart adapter flag 1224 indicates whether the adapter is type \u201cF\u201d (smart adapter) or type \u201cM\u201d. Adapter node number field 1225 contains an identifier used by the SSA device driver in accessing the adapter. Bus number field 1226 contains the host bus number on which the adapter is located. Slot number field 1227 contains the physical slot number within the host bus where the adapter is located. Daughter number field 1228 contains an identifier of a daughter board in which the adapter is located, if mounted on a daughter board. Partner number field 1229 is used to identify another adapter (\u201cpartner\u201d) on the same string. SIC A SSA Nodes pointer field 1230 contains a pointer to the SSA node record 1250 for the first pair of ports on this adapter (known as SIC A). Port1 length field 1231 and port2 length field 1232 contain respectively the lengths of the string of devices attached to port 1 of SIC A and port 2 of SIC A; where this string is a closed string (loop), the value in port2 field 1232 is set to \u22121, and port1 field 1230 reflects the actual number of devices on this string. Additionally, loop flag field 1238 is set in this case. Topology version field 1234, logical version field 1235, and error version field 1236 are version counter fields for topology events, logical events, and error events, respectively. Change count field 1233 changes whenever any of fields 1234-1236 changes, indicating that an event has occurred. Need rescan field 1237 is used to indicate that the string should be re-analyzed as a result of some event. Using List_SSANode field 1239 is a flag to indicate whether the List_SSANode function may be called for this SSA bus; this function is only available on type \u201cF\u201d adapters in which the configuration is legal. PosUncertain field 1240 is a flag to indicate that the position of the adapter within the string of devices is uncertain; this is true only in rare cases. A separate copy of fields 1230-1240 exists for the SIC B pair of ports., 166374=The parsing algorithm operates on UDL 2002, parsing each device in turn until no devices are left on the UDL. At step 1603, the manager checks for another device on the UDL, the process terminating if the UDL is empty. If the UDL is not empty, the first object on the UDL is \u201cpopped\u201d (removed) from the UDL, this removed device becoming the current object, at step 1604., 161508=RemoteServices 1505 is an object for performing all remote procedure calls to the local agents. RemoteService \u201cobjectizes\u201d data received from the local agents over information processing network 115, i.e. it creates objects contained the returned data for manipulation by the object-based client library., 108146=In general, the information maintained by ODM 1010 is information of a static nature, which only changes when a \u201ccfgmgr\u201d AIX command is ran following devices being added or removed, or the system is otherwise reconfigured. For example, ODM maintains information about which physical devices (buses, adapters, storage devices, etc.) are components of the system, the addresses of those devices, physical locations such as bus slots, etc. Most of the non-RAID related attribute information which can be requested by the manager through the LL_GetAttr command is stored in the ODM, the most notable exceptions being RAID-related attributes (which are maintained by ssaraid operating system facility 1012) and volatile information such as event counters, certain state indicators, diagnostic attributes, etc., 38542=The present application is also related to the following commonly assigned co-pending applications: Ser. No. 09/183,647, filed Oct. 30, 1998, by Gary T. Axberg, et al., entitled \u201cStorage Network Management Mechanism\u201d, now U.S. Pat. No. 6,253,240 which is herein incorporated by reference., 169646=If the connected-to object is not on the device list (step 1706), then the manager creates an object of the appropriate type in DiscoverResults to represent the connected-to device and adds it to DL 2001, UDL 2002, and the appropriate individual device type list, at step 1707. In that event, if the connected-to object is of a new device type (step 1708), the manager issues LL_TypeConnections and LL_SupportedAttr calls to the local agent in order to determine the type of primary connections which are possible and the attributes which are supported in the connected-to object, at step 1709. This information will be needed when the connected-to object is itself parsed., 125879=String number field 1256 contains an index to a value in string table 1205. The value in table 1205 is the universal identifier of the device in the same SSA bus (string) having the lowest universal identifier. This value is used to uniquely identify an SSA bus. Because this value is subject to change if devices should be added to or removed from the SSA bus, the SSA node record contains an index to table 1205, where the universal identifier for the string resides. Thus, if a device is added or removed causing the lowest number UID to change, it is only necessary to change the value in string table 1205, without changing each individual SSA node record., 174142=As shown in FIG. 20A, after initialization (steps 1601 and 1602), DiscoverResults lists DL 2001, UDL 2002 and host devices 2010, contain references to the three host objects which make up the management set., 158469=Parts palette 1404 also contains icons selectable with a pointing device. In live mode, these icons represent Select, Text Annotation and Box Annotation. Selecting either the \u201cText Annotation\u201d or \u201cBox Annotation\u201d icon puts the user in the corresponding mode of operation, allowing the user to add the appropriate annotation to the canvas at a user selectable location. Selecting the \u201cSelect\u201d icon puts the user in \u201cSelect\u201d mode, wherein any device on the canvas may be selected. Selecting a device then causes a corresponding pop-up menu to appear, allowing the user to perform certain operations with respect to the device. These operations vary depending on the object selected, but generally the user may view or alter device properties (attributes), or delete a device. Selecting the Enclosure Icon will put the use in a mode allowing enclosures to be manually added to the canvas. The user can then manually add previously discovered devices to the enclosure by dragging the device to the enclosure. Additional parts palette icons are presented in plan mode, permitting the user to add devices., 116412=The hash key indexes an entry in the appropriate hash table. Because a hash key is not necessarily unique, this entry will not always be the desired entry. The input parameters of the entry are compared to the input parameters of the request 1112. If they do not match, each subsequent entry in the hash table is compared until a match is found. Due to the granularity of the hash key, typically no more than a few compares are necessary to find the correct entry. The function pointer in this entry contains a pointer to the function which services the request 1130. It will be observed that it is possible for multiple hash table entries to point to the same function. This function is invoked, passing the parameters in request 1112., 134677=Where a network is attached to a type \u201cM\u201d adapter, the process is substantially different. Network daemon 1002 issues a call to the adapter to list all devices visible to it. This list will not necessarily be complete, since disks that are not ready or other adapters will not be visible. For each device found, the daemon issues another call to the adapter, to determine the device's hop count from each port of the adapter. A device with a hop count from each port of a pair is in a loop, whereas a device with only one hop count is in a string topology. After collecting all this information, it may be deduced that where there are missing hop counts, there are devices of unknown type. The network daemon then builds an internal map of reported devices. Devices represented as unknown type are included in the table where there are hop count gaps. Note that in some cases a hop count gap will not be apparent to the \u201cM\u201d adapter or its local agent. I.e., where an adapter in another host is at the end of a string, no gap will appear. Only the central manager is capable of resolving this topology, if it knows about all hosts., 183111=The manager then pops D120 from the UDL. A disk storage device can be thought of as something at the end of the parsing chain; having parsed to this level, there can be nothing else below it. Accordingly, disks are regarded as unparsable objects. At step 1701, the \u201cYes\u201d branch is taken, and D120 is set to \u201cparsed\u201d at step 1720., 165783=The parsing operation is initialized by creating a DiscoverResults object, and initializing certain lists therein with the host objects in the management set at step 1601. I.e., DL 2001 and UDL 2002 are initially set to include these host objects. At the same time, host list 2010 of the set of individual device lists is also initialized with these hosts. The manager then issues a LL_TypeConnections call to the local agent in each host at step 1602, to determine the types of devices which may form primary connections with the host., 118164=Network daemon 1002 is free to update its local copy of configuration information at any time. This enables it to run at full speed, which is essential, since it handles live synchronous events (interrupts) from hardware. Only when it has a complete and consistent set of information does it attempt to update shared memory 1003 to the latest version, having first obtained a write-lock semaphore. If the write-lock semaphore is unavailable, the network daemon continues to run unhindered, preparing the next version of the configuration information. Since the network daemon is not suspended when the write-lock is unavailable, it can keep records of events/interrupts, so that information is not lost when the daemon is unable to write the information to shared memory owing to a failure to obtain a write-lock semaphore. (The usual reason for being unable to obtain a write-lock semaphore is that the network daemon has tried to obtain it at the very instant that the local library is already reading shared memory, having engaged a read-lock semaphore.) Since both daemons have their own local copies of the configuration information, the only time the use the semaphores is during the brief instants that it take to read or write shared memory. For the majority of the time, each works on its own copy of the information., 179837=The manager repeats this process for Controller 131. In this case, the LL_ListPrimaryConn call to the local agent (step 1702) reports the same device bus L120. As a result, the \u201cYes\u201d branch is taken from step 1706. In our example, we assume the controllers are \u201cM\u201d type adapters. Therefore, when the connected-to object being examined is L120, the \u201cYes\u201d branch is taken from step 1712. The manager issues another LL_ListPrimaryConn call to the local agent in host 111, requesting all primary connections to device bus L120 (step 1713). Controller 131 is unable to determine the identity of other controllers on device bus L120. There is internal code in the local agent (described more fully above) to enable it to resolve the identities of controllers in its host 111, i.e., controllers 130 and 131. Therefore, the LL_ListPrimaryConn call to host 111 returns controllers 130 and 131, the ten disk storage devices, and two unknown devices (designated U1 a and U1 b). The unknown devices are in fact controllers 132 and 133, but the local agent in host 111 has no way of knowing their identities, and so reports them as unknowns. Upon receipt of this information, the manager creates the appropriate objects in DiscoverResults for all new devices and connections found, and adds them to the appropriate lists (step 1714). FIG. 20G shows the condition of DiscoverResults after parsing Controller 131. It will be noted that connection list 2016 contains no connections to controllers 132 and 133, which at this point are unknown devices., 132639=The simplest case of configuration analysis performed by daemon 1002 is a legal network configuration attached to a type \u201cF\u201d adapter. In this case, the network daemon issues a List_SSANodes call to the adapter to list all devices visible to it. The adapter responds with a complete list of devices on the network, including device identifiers and position information. The network daemon then formats this information according to the format described above and stores it in shared memory 1003., 193994=At this point, there remain additional unresolved devices (U2 c and U3 a), and additional hosts (H112 and H113) for which substrings have not been built. The manager accordingly takes the \u201cyes\u201d branch from step 1812 and selects host H112. The substrings built from this host are shown in FIG. 21C., 128990=It will be observed that the data structures can be easily expanded to accommodate devices having different numbers of ports, by addition of another substructure containing fields 1230-1240 (in the case of an adapter serving more than two SSA buses) or 1270 and 1272 (in the case of a disk or other device at an SSA node)., 130644=While network daemon 1002 is active, it periodically checks the configuration of all networks attached to the host in which the daemon is located. It initially obtains a listing of all adapters in the host (via an odm_get_list call to ODM 1010), and establishes the topology information repository in shared memory 1003. It then analyzes the topology of the network(s) attached to the listed adapters, and updates the topology information repository in shared memory 1003. The daemon then idles for a period, at the end of which it wakes up, checks for events and re-analyzes the network as necessary, and then updates the data in shared memory again. It continues to idle and re-check the network at periodic intervals. The period may be specified by a user, and is typically 10 seconds. It will be observed that the network daemon has no knowledge of how devices are grouped in management sets; it simply obtains information for all devices attached to its host, and stores this in shared memory 1003., 147447=The daemon then compares the PossInd fields and finds a match, namely, gap3 (step 1308, 1309). The daemon therefore concludes that gap3 is the proper location for C131, and the map is updated as follows (step 1310):, 199970=The \u201cdeep\u201d compare involves looking at device attributes and connections, but only for the old devices that were found in the shallow compare operation. This process selects a found device (step 1910), and compares the attributes previously recorded for the device with the attributes obtained during the discover operation (step 1911). If any attributes are different, a message is generated (step 1912). The manager then compares the connections associated with the selected device with connection objects associated with the corresponding device found in the discover operation (step 1913). If the connections are the same, the connection objects created in the discover operation (in DiscoverResults 1511) are also added to ProcessResults object 1512 (step 1914). If the connections are different, the old connections are added to the list of missing connections for the network, and an appropriate message is generated (step 1915). If there are more devices to compare (step 1916), the process repeats until all old found devices have been examined., 114890=A hash key for accessing one of hash tables 1121-1125 is generated from the parameters of the request. The hash key function for each respective table is listed below:, 164089=FIGS. 16 and 17 are flowcharts of the various steps performed in parsing a management set. As a preliminary matter, it should be explained that DiscoverResults 1511 contains a collection of found objects, and several lists referencing the collection. The contents of these lists at various stages of an example discover operation are shown in FIGS. 20A through 20K. One set of lists is used for processing, and includes: device list (DL) 2001, a list of all devices found; unsearched device list (UDL) 2002, a list of devices found but not yet parsed; and block list (BL) 2004, a list of devices which are not to be parsed. Another set of lists categorizes objects found by type: host 2010, adapter 2011, disk 2012, device bus 2013, host bus 2014, unknown device 2015, and connection 2016. E.g., host list 2010 contains objects of type host 515, disk list 2012 contains objects of type PhysicaiDisk 507, etc. Host bus list 2014 contains host bus objects, which are temporary objects for use only by the DiscoverCtlr 1510, and are not later made part of the collection of objects representing the network, as shown in FIG. 5. The list 2010 of host device objects in DiscoverResults 1511 is not to be confused with HostList object 1502, which lists host objects forming a management set. Also shown in FIGS. 20A through 20K is LPC 2003, which is not strictly speaking a list of objects, but represents the list of devices that is returned by the local agent when the host makes a LL_ListPrimaryConnected call to the agent., 114391=Each entry in one of hash tables 1121-1125 contains a set of input parameters and a pair of function pointers. The first function pointer points to a function used to read the requested information; the second function pointer points to a function used to write the information. This design includes the flexibility to read or write any data, although in general, one of the function pointers is null, since most information is either read or written, but not both., 191871=The manager then selects a host and builds the \u201csubstrings\u201d from the host's strings (step 1806), as shown in FIG. 21B. In this example, host 111 is selected. Substrings are built by selecting each string in turn and generating a new string by starting at each unknown device. In string 2101, there are two unknown devices. Substring 2111 is generated by starting with device U1 a, and substring 2112 is generated by starting with device U1 b. Because this strings represent loops, the substring wraps around the starting element of the original string. The manager continues by building substrings 2113 and 2114 from string 2102. The substrings constructed from the two remaining strings from host 111 are duplicates of 2111-2114., 176286=The manager then repeats this process for Host 112 and Host 113, causing the respective HostBus objects (designated B112 and B113) to be added to the appropriate lists. The one difference is that on these occasions, step 1709 is by-passed, since the manager already has type information about host buses. In this simplified example, it is assumed that all hosts, busses, controllers, etc., are of the same type; however, this is not necessarily always the case, and it may be required in some circumstances to issue the calls in step 1709 again if the device types are not identical. FIG. 20C shows the condition of the DiscoverResults lists after parsing Host 113., 161846=DiscoverCtlr 1510 controls the discover process. The discover is initiated by invoking the discover( ) method in DiscoverCtlr 1510, passing a list of host systems. DiscoverCtlr creates a DiscoverResults object 1511 and a ProcessResults object 1512. DiscoverResults 1511 contains a collection of objects representing all components that were found as a result of parsing the network; these are not identified with particular networks and device relationships immediately after parsing. ProcessResults 1512 is used during the compare process (after parsing), and contains those objects found during parsing that are not in the current management set. I.e., it contains a subset of the collection in DiscoverResults 1511 consisting of new objects., 491293=The name of the rule is Scorpion1100,, 112245=The process whereby the local library determines how to service a request is shown diagrammatically in FIG. 11. A request received from the central manager is represented generically as 1101. This request contains a command field 1102 identifying the type of request, and multiple parameter fields 1103, 1104, 1105 containing the parameters of the request, it being understood that the number of parameters may vary. A parameter may contain a wild card. In the example of FIG. 11, parameter field 1105 contains a wild card parameter. The local library initially expands all wild card parameters by looking in wild card table 1120 for any entry corresponding to the field, command, or other parameters. In the preferred embodiment, the wild card table is fairly small, and therefore sophisticated indexing (such as hashing, binary tree search, etc) is not necessary. Each entry in wild card table 1120 contains a list of the parameters to which the wild card is expanded. The local library uses this list to convert the original request into a series of requests 1110, 1111, 1112, one corresponding to each parameter on the list, by replacing the original wild card with a respective list entry from wild card table 1120., 157955=Toolbar 1403 contains a series of icons which are selectable with a pointing device such as a mouse. Selecting such an icon is an alternate path to one of the options listed above, available from menu bar 1402. The toolbar icons represent the following options: New (from the File menu), Open (from the File menu), Save (From the File menu), Print (from the File menu), Delete (from the Edit menu), Pan to . . . (from the View menu), Event Monitor (from the Tools menu), and Help., 127788=Map coordinate fields 1266-1269 are used only in diagnostic mode, for displaying a direct map of the network as seen by the network daemon, without intermediate alteration of data by the central manager. The Map position uncertain field 1265 is similarly used in diagnostic mode to indicate uncertainty in map position., 490815=longDesc=IBM Ultrastar 2 XP DCHC\u201431100, 108984=Ssaraid facility 1012 is also a portion of operating system 421. Ssaraid 1012 is an auxiliary tool designed to support RAID functions. It is used by local library 1001 to obtain certain RAID-related attributes of the storage devices. Normally, this tool is invoked by a user by entering a command on an operating system command line or via \u201csmit\u201d. The local library achieves the same result by creating a string containing the command line text, and then executing the command by opening a pipe to the process (i.e. performing a popen( ) call). The output is then read from the process's stdout., 538646=The rule is applied to Controller objects with a product ID of 3155 and a uCode level of 1.45-1.47 or 1.50. No connection information is used to identify the device,, 110157=Local library 1001 is activated upon receiving a call from the central manager. A timer is set upon the receipt of the call, and reset every time another call is received. If the timer times out without receiving a call during the timeout period, (currently two minutes), the local library thread of execution dies, and its local data disappears. In order to keep the library continuously running and avoid the need to restart it, the central manager normally sends an LL_GetAttr request at intervals of about 1 minute, requesting event counts. This request also lets the manager know if there has been any change in event counts which might indicate that other action should be taken., 194374=The manager then compares the various substrings with strings. It will be observed that substrng 2123 matches string 2107, and that it will therefore be possible to resolve unknowns U3 a and U2 c. Depending on the order of substring comparison, the manager may actually match other strings first., 196302=In the example discover operation described above, all controllers were type \u201cM\u201d adapters, which have limited capability to determine the identity of other type \u201cM\u201d adapters on the same SSA bus. However, some controllers (type \u201cF\u201d adapters) have greater capability, and can in fact determine the identities of other adapters, including the host systems in which they reside. In this case, it is possible that the discover operation will discover the identity of a host which is not in the original management set. If this happens, the discovered host is treated like any other discovered device, i.e., it is placed on device list 2001, UDL 2002, and ultimately parsed to discover all buses, controllers, etc., attached to it. Like any newly discovered device, the discovered host, and devices attached to it, will be added to the management set at the conclusion of the discover operation, as described below., 113569=The local library then processes each of the series of requests 1110, 1111, 1112 (or the original request if there were no wild cards in it) by generating a hash key 1115 from certain request parameters, and using this key to access one of hash tables 1121, 1122, 1123,1124, or 1125. The library contains five hash tables, each corresponding to one or more types of requests. Specifically, these tables are:, 131702=The complexity of configuration analysis performed by daemon 1002 depends greatly on the type of adapter and network configuration. Certain controllers have more advanced capabilities. The network daemon of the preferred embodiment currently supports controllers of two basic types (designated type \u201cM\u201d adapters and type \u201cF\u201d adapters), it being understood that additional types having other capabilities could be supported. Type \u201cF\u201d adapters have more advanced function than type \u201cM\u201d adapters. Specifically, a type \u201cF\u201d adapter is able to determine the identity and position of all devices attached to it via a network (assuming the network is a \u201clegal\u201d configuration, i.e., configured according to certain pre-established rules). A type \u201cM\u201d adapter will not be able to determine the identity of other controllers in the same network, although it may know that there is a device of unknown type at the location., 124493=FIG. 12C shows the structure of a SSA node record 1250. SSA node records are organized as a doubly linked list of records in hash index order. I.e., a hash index number for each SSA node record 1250 is computed from the lower order digits of the device universal identifier, and records are inserted into the list at the appropriate ordered location. Previous hash entry field 1251 and next hash entry field 1252 contain pointers to the previous and next SSA node record, respectively. If a specific device is to be accessed, its hash table index can be readily computed, and hash table 1204 used to obtain a pointer to a SSA node record having the same hash index. If this is not the desired record, the chain of next hash entry pointers 1252 is followed until the desired record is found. This is much faster than traversing the entire list of SSA node records (which may be very large) every time a record is to be accessed. Old unused SSA node records are placed on a separate free list, which is a singly linked list, for recycling should a new record be needed. Next free entry field 1257 contains a pointer to the next device on the free list if the record is on the free list. In use flag 1260 indicates whether a SSA node record is currently in use (i.e., on the doubly linked list of active records)., 194732=Because all unknowns have now been resolved, the manager takes the \u201cno\u201d branch from step 1812. All unknown devices having been resolved, the corresponding unknown device objects are deleted (step 1820). The manager then creates any necessary connection objects (step 1821). In this case, only one additional connection object is required: the connection between two previously unknown devices in different hosts, i.e., between controllers C132 and C133. Because no single host previously had a complete view of this connection (every host's view had at least one unknown object), it had been impossible to define the connection, and no connection object was previously created. Note, however, that in the case of connections involving devices that were unknown to one host but known to another, it was previously possible to create a connection object from the information supplied by one of the hosts; in this case, it is merely necessary to delete the unknown device as duplicative. There being only one bus in this example (step 1822), the resolution process is complete., 143661=A \u201chop count\u201d of 0 means the immediately adjacent device, while a hop count of 1 indicates one device is skipped. At steps 1303-1307, the daemon hops from each of the cross-reference devices on the network map to obtain the PossInd values. E.g., starting from D125, it hops 0 times (adjacent device) in one direction to find D126. This is one of the PossInd values. It then hops 0 times in the opposite direction to find gap3. This process is repeated for the other cross-reference device. Because this example is a loop configuration, the \u201cYes\u201d branch from step 1304 is never taken. When the \u201cNo\u201d branch from step 1307 is taken, the cross-reference objects contain the following data:, 110869=While running, the local library is normally idling while waiting for a request from the central manager. When the request is received, the library must parse it to determine how the information will be obtained. There is an action corresponding to each type of request, which may also vary with the parameters of the request. Most information used to satisfy requests is obtained from shared memory 1003, but it may also be obtained from ssaraid facility 1012, ODM facility 1010, or directly from an adapter itself. The requested information might be read directly from data records (e.g., from shared memory), or it might involve an exchange of communications between the library and the adapter. For example, a LL_GetAttr request, which requests attribute information, is handled by calling the ssaraid facility 1012 if the requested attribute is a RAID-related attribute, but the same request is handled by retrieving information in shared memory 1003 if the requested attribute is an event count. The local library must also determine in which data structure and location the information can be found. The requested attribute may, for example, be located in one place for a disk and another for an adapter. Finally, some requests contain \u201cwild cards\u201d which may be used in place of specific parameters of the request., 117706=While shared memory is depicted as a single block 1003 in FIG. 10, its structure and operation are actually somewhat more complex. Daemon 1002 needs to be able to update a configuration record synchronously with local library 1001 reading configuration information. Therefore, there are actually three repositories of configuration information, one local to the local library, one local to the daemon, and one shared.}",
    "textBeforeTable": "Patent Citations A Network to Network connection specifies the other networks that contain the host or host systems that are in the network. This is currently undefined. C.6.6.6 Network to Network A Network to LogicalDisk connection specifies the connection from a network to the logical disks; contained in the network. This is currently undefined. C.6.6.5 Network to LogicalDisk specific info: undefined. class_count: Number of different buses of the type that the network contains. object_count: Number of connections the network has to a specific bus. A Network to Bus connection specifies the connection from a network to the buses contained in the network. C.6.6.4 Network to Bus specific info: undefined. class_count: Number of different hosts of the type that the network contains. object_count: Number of connections the network has to a specific host. A Network to Host connection specifies the connection from a network to the hosts contained in the network. C.6.6.3 Network to Host specific info: undefined. class_count: Number of different controllers of the type that the network contains. object_count: Number of connections the network has to a specific controller. A Network to Controller connection specifies the connection from a network to the controllers contained in the network. C.6.6.2 Network to Controller A Network to PhysicalDisks connection specifies the connection from a network to the physical disks contained in the network. This is currently undefined. C.6.6.1 Network to PhysicalDisk C.6.6 Network connections A LogicalDisk to Network connection specifies",
    "textAfterTable": "US20020152302 * Feb 14, 2001 Oct 17, 2002 Ricoh Co. Ltd. Method and system of remote diagnostic, control and information collection using multiple formats and multiple protocols with delegating protocol processor US20040117476 * Dec 17, 2002 Jun 17, 2004 Doug Steele Method and system for performing load balancing across control planes in a data center US20040167942 * Nov 24, 2003 Aug 26, 2004 Oshinsky David Alan Logical view and access to data managed by a modular data and storage management system US20040186881 * Dec 16, 2003 Sep 23, 2004 Emc Corp. Automated media library configuration US20040221049 * May 19, 2004 Nov 4, 2004 Emc Corporation Method and apparatus for identifying network devices on a storage network US20040249937 * Mar 24, 2004 Dec 9, 2004 Hidekazu Tachihara Performance management method, system and program US20040267752 * Apr 23, 2004",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}