{
    "relation": [
        [
            "Field name",
            "username",
            "timestamp",
            "req_token",
            "action",
            "friend"
        ],
        [
            "Type",
            "str",
            "int",
            "str",
            "str",
            "str"
        ],
        [
            "Explanation",
            "See: Common fields",
            "See: Common fields",
            "See: Creating request tokens",
            "What type of action you're taking: add, delete, block, unblock, or display.",
            "The user (account name) we're applying this action to."
        ]
    ],
    "pageTitle": "Snapchat - GSFD",
    "title": "",
    "url": "http://gibsonsec.org/snapchat/fulldisclosure/",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988317.67/warc/CC-MAIN-20150728002308-00313-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 101047511,
    "recordOffset": 101022948,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{7601=This documentation is based on the current build (4.1.01 at the time of writing 23-12-2013) of Snapchat for Android. The Android app uses a mixture of /ph and /bq endpoints - the iOS app is pure /bq, but we haven't documented them all, sorry!, 163240=Using the reported 8 million users in June as a rough estimate for Snapchat's user base (however, it will have undoubtedly exponentially grown since then), we can do some rough calculations on how long it would take to crunch through all of Snapchat's user base (clarification: we mean how long it would take to crunch through 8 million American numbers, seeing as it's still hit and miss):}",
    "lastModified": "Fri, 27 Dec 2013 22:45:47 GMT",
    "textBeforeTable": "Requests: There are a few fields that are common to most requests and responses: Common fields \u00b6 Include it in your request! Run request_token(static_token, timestamp) Take the current timestamp Take the static token, m198sOkJEn37DjqZ32lpRu76xmw288xSQ9 If you're logging in, you won't have an auth_token yet. Not to fear! Creating static tokens \u00b6 Include it in your request! Run request_token(auth_token, timestamp) Take the current timestamp (epoch/unix timestamp) which you'll need for the req_token and inclusion in the request. Take the auth_token you got from logging in To create a request token (which you will need for 90% of requests), you need to: Creating request tokens \u00b6 1 means take a character from hash 2 at the point. 0 means take a character from hash 1 at the point. The pattern is 0001110111101110001111010101111011010001001110011000110001000110 timestamp + secret secret + auth_token You need two sha256 hashes. The secret is iEk21fuwZApXlz93750dmW22pw389dPwOk Things to note: # '9301c956749167186ee713e4f3a3d90446e84d8d19a4ca8ea9b4b314d1c51b7b' # >>> request_token(\"m198sOkJEn37DjqZ32lpRu76xmw288xSQ9\", 1373209025) # Here's a benchmark to make sure your implementation works: return \"\".join(bits) bits = [first[i] if c == \"0\" else second[i] for i, c in enumerate(",
    "textAfterTable": "logged bool This is usually indicative of whether or not your response was successful. Encrypting/decrypting data \u00b6 Encrypting normal snaps \u00b6 All standard media (read: picture and video) data sent to Snapchat is: Padded using PKCS#5. Encrypted using AES/ECB with a single synchronous key: M02cnQ51Ji97vwT4 Encrypting stories \u00b6 Stories are: Padded using PKCS#7. Encrypted using AES/CBC with a unique IV and key per piece of the story (i.e, there isn't a single key/IV you can use). You can find a media_key and media_iv deep within the return values of a request to /bq/stories. The server does the AES/CBC encryption - segments are sent to the server using the normal AES/ECB (M02c..) encryption. StoryEncryptionAlgorithm#encrypt just calls SnapEncryptionAlgorithm#encrypt. Here's a rough idea of how to decrypt them: # To find `media_key` and `media_iv`, see: /bq/stories documentation import requests import base64 import mcrypt res = requests.post(...) # POST /bq/stories and ensure res is a dict. data = requests.get(...) # GET /bq/story_blob?story_id=XXXXX from result key = base64.b64decode(res[...][\"media_key\"]) iv = base64.b64decode(res",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}