{
    "relation": [
        [
            "Parameter",
            "chain_name",
            "step_name",
            "event_schedule_name",
            "timeout",
            "event_condition",
            "queue_spec"
        ],
        [
            "Description",
            "The name of the chain that the step is in",
            "The name of the step",
            "The name of the event schedule that the step waits for",
            "This parameter is reserved for future use",
            "See the CREATE_EVENT_SCHEDULE Procedure",
            "See the CREATE_EVENT_SCHEDULE Procedure"
        ]
    ],
    "pageTitle": "DBMS_SCHEDULER",
    "title": "",
    "url": "http://docs.oracle.com/cd/B28359_01/appdev.111/b28419/d_sched.htm",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042987402.78/warc/CC-MAIN-20150728002307-00083-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 71506607,
    "recordOffset": 71437195,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{283550=Time in seconds before an event generated by the Scheduler and enqueued onto the Scheduler event queue expires. May be NULL., 38296=As an example, in the year 1998 the ISO week 1 began on Monday December 29th, 1997; and the last ISO week (week 53) ended on Sunday January 3rd, 1999. So December 29th, 1997, is in the ISO week 1998-01; and January 1st, 1999, is in the ISO week 1998-53., 54786=Because an INCLUDE clause is present, date-related information is not retrieved from the start date. However, time-specific information is, so the preceding schedule executes on 07/01/05 9:00:00, 07/01/06 9:00:00, 07/01/08 9:00:00, and so on., 56433=The byweekno clause is only allowed if the frequency is YEARLY. It cannot be used with other frequencies. When it is present, it will return all days in that week number. If you want to limit it to specific days within the week, you have to add a BYDAY clause. For example, \"FREQ=YEARLY;BYWEEKNO=2\" with a start date of 01/01/2003 will return:, 59023=Repeating jobs with frequencies smaller than daily follow their frequencies exactly across daylight savings adjustments. For example, suppose that a job is scheduled to repeat every 3 hours, the clock is moved forward from 1:00 a.m. to 2:00 a.m., and the last time the job ran was midnight. Its next scheduled time will be 4:00 a.m. Thus, the 3 hour period between subsequent job runs is retained. The same applies when the clock is moved back. This behavior is not the case for repeating jobs that have frequencies of daily or larger. For example, if a repeating job is supposed to be executed on a daily basis at midnight, it will continue to run at midnight if the clock is moved forward or backward. When the execution time of such a daily (or larger frequency) job happens to fall inside a window where the clock is moved forward, the job executes at the end of the window., 56203=\"FREQ=YEARLY;BYMONTH=JAN,JUL\" with start date 01/21/2003 becomes \"FREQ=YEARLY;BYMONTH=JAN,JUL;BYMONTHDAY=21\", which means every year on January 21 and July 21., 30513=The Scheduler uses a rich calendaring syntax to enable you to define repeating schedules, such as \"every Tuesday and Friday at 4:00 p.m.\" or \"the second Wednesday of every month.\" This calendaring syntax is used in calendaring expressions in the repeat_interval argument of a number of package subprograms. Evaluating a calendaring expression results in a set of discrete timestamps., 65682=Many companies in the retail industry share the same fiscal year. The fiscal year starts on the Sunday closest to February 1st, and subsequent quarters start exactly 13 weeks later. The fiscal year schedule for the retail industry can be defined as the following:, 44299=The BYSETPOS clause is applied to the list of timestamps once per frequency period. For example, when the frequency is defined as MONTHLY, the Scheduler determines all valid timestamps for the month, orders that list, and then applies the BYSETPOS clause. The Scheduler then moves on to the next month and repeats the procedure. Assuming a start date of Jun 10, 2004, the example evaluates to: Jun 30, Jul 30, Aug 31, Sep 30, Oct 29, and so on., 46550=For example, assume that the named schedule last_sat indicates the last Saturday in every month, and that for the year 2005, the only months where the last day of the month is also a Saturday are April and December. Assume also that the named schedule end_qtr indicates the last day of each quarter in 2005:, 39884=BYDATE=0115,0315,0615,0915,1215,20060115, 64128=then the execution times on 05/02 and 09/22 are 8:00 a.m., 1:00 p.m., and 6:00 p.m., 55854=When not enough BY clauses are present to determine what the next date is, this information is retrieved from the start date. For example, \"FREQ=YEARLY\" with a start date of 02/15/2003 becomes \"FREQ=YEARLY;BYMONTH=FEB; BYMONTHDAY=15\", which means every year on the 15th of February., 282918=Maximum number of job slave processes that the Scheduler can start. May be NULL., 15796=If TRUE and if the job start_date is null, then when the default_timezone scheduler attribute is changed, the Scheduler recomputes the next run date and time for this job so that it is in accordance with the new time zone. For example, if the job was set to run at 02:00 in the previous time zone, it will run at 02:00 in the new time zone. (If the job start_date is not null, then the time zone for the run date and time for the job is always specified by the time zone of the start_date.) If FALSE, the next start date and time for the job is not recomputed when the default_timezone scheduler attribute is changed. In this case, if the old time zone is three hours earlier than the new time zone, then a job scheduled to run at 02:00 in the old time zone runs at 05:00 in the new time zone., 39015=This specifies the day of the year as a number. Valid values are 1 to 366. An example is 69, which is March 10 (31 for January, 28 for February, and 10 for March). 69 evaluates to March 10 for non-leap years and March 9 in leap years. -2 will always evaluate to December 30th independent of whether it is a leap year., 50866=In this example, the dates 1/30, 2/20, and 7/25 are added to the main schedule. However, the Scheduler does not include dates that fall in months that are skipped by the INTERVAL clause. If the start date of the main schedule is 1/1/2005, then 2/20 isn't added. On the dates that are added, the embedded schedule follows the execution pattern of the main schedule: jobs are executed at 9:00 a.m. and 5:00 p.m. on 1/30 and 7/25. If the embedded schedule does not itself have a start date, it inherits the start date from the main schedule., 56995=Note that when the byweekno clause is used, it is possible that the dates returned are from a year other than the current year. For example, if returning dates for the year 2004 and the calendar string is \"FREQ=YEARLY;BYWEEKNO=1,53\" for the specified week numbers in 2004, it will return the dates:, 346109=In heavily loaded systems, jobs are not always started at their scheduled time. This attribute enables you to have the Scheduler not start a job at all if the delay in starting the job is larger than the interval specified. It can be a value of 1 minute to 99 days. For example, if a job was supposed to start at noon and the schedule limit is set to 60 minutes, the job will not be run if it has not started to run by 1:00 p.m., 257624=If zero, then the job run is logged as succeeded. If non-zero, then the job run is logged as failed with this error number. If -1013, then the job run is logged as stopped., 54365=The preceding schedule executes on 04/15/05 9:00:00, 04/15/06 9:00:00, 04/15/07 9:00:00, and so on., 37185=This specifies which month or months you want the job to execute in. You can use numbers such as 1 for January and 3 for March, as well as three-letter abbreviations such as FEB for February and JUL for July., 63159=on 01/01/2004 or 01/15/2004, in both cases the expression evaluates to Friday 01/02/2004, and Tuesday 01/06/2004. The only difference is that when the expression is evaluated on 01/15/2004, the Scheduler determines that there are no matches in January because the timestamps found are in the past, and it moves on to the matches in the next month, February., 37632=This specifies the week of the year as a number. It follows ISO-8601, which defines the week as starting with Monday and ending with Sunday; and the first week of a year as the first week, which is mostly within the Gregorian year. That last definition is equivalent to the following two variants: the week that contains the first Thursday of the Gregorian year; and the week containing January 4th.}",
    "lastModified": "Thu, 09 Jul 2015 23:29:24 GMT",
    "textBeforeTable": "Table 114-26 DEFINE_CHAIN_EVENT_STEP Procedure Parameters Parameters timeout IN INTERVAL DAY TO SECOND DEFAULT NULL); queue_spec IN VARCHAR2, event_condition IN VARCHAR2, step_name IN VARCHAR2, chain_name IN VARCHAR2, DBMS_SCHEDULER.DEFINE_CHAIN_EVENT_STEP ( timeout IN INTERVAL DAY TO SECOND DEFAULT NULL); event_schedule_name IN VARCHAR2, step_name IN VARCHAR2, chain_name IN VARCHAR2, DBMS_SCHEDULER.DEFINE_CHAIN_EVENT_STEP (  Syntax This procedure adds or replaces a chain step and associates it with an event schedule or an inline event. Once started in a running chain, this step will not complete until the specified event has occurred. Every step in a chain must be defined before the chain can be enabled and used. Defining a step gives it a name and specifies what happens during the step. If a step already exists with this name, the new step will replace the old one. DEFINE_CHAIN_EVENT_STEP Procedure   \"SET_JOB_ANYDATA_VALUE Procedure\" \"DEFINE_PROGRAM_ARGUMENT Procedure\" See Also: Defining a program argument requires that you be the owner of the program or have ALTER privileges on that program. You can also define a program argument if you have the CREATE ANY JOB privilege. All program arguments from 1 to the number_of_arguments value must be defined before a program can be enabled. If a default value for an argument is not defined with this procedure, a value must be defined in the job. Usage Notes",
    "textAfterTable": "Usage Notes Defining a chain step requires ALTER privileges on the chain either by being the owner of the chain, or by having the ALTER object privilege on the chain or by having the CREATE ANY JOB system privilege. See Also: \"DEFINE_CHAIN_STEP Procedure\" DEFINE_CHAIN_RULE Procedure This procedure adds a new rule to an existing chain, specified as a condition-action pair. The condition is expressed using either SQL or the Scheduler chain condition syntax, and indicates the prerequisites for the action to occur. The action specifies what is to be done as a result of the condition being met. An actual rule object is created to store the rule in the schema in which the chain resides. If a rule name is given, this name will be used for the rule object. If a rule name is given and a rule already exists with this name in the chain's schema, the existing rule will be altered. (A schema different than the chain's schema cannot be specified). If no rule name is given, one will be generated of the form SCHED_RULE${N}. Syntax  DBMS_SCHEDULER.DEFINE_CHAIN_RULE ( chain_name IN VARCHAR2, condition IN VARCHAR2, action IN VARCHAR2, rule_name IN VARCHAR2 DEFAULT NULL, comments IN VARCHAR2 DEFAULT NULL); Parameters Table 114-27 DEFINE_CHAIN_RULE Procedure Parameters",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}