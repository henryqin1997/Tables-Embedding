{
    "relation": [
        [
            "Citing Patent",
            "US8458679 *",
            "US8561037 *",
            "US8726252 *",
            "US20090064095 *",
            "US20110072419 *",
            "US20120198425 *",
            "US20140237480 *"
        ],
        [
            "Filing date",
            "Sep 22, 2010",
            "Aug 29, 2007",
            "Jan 28, 2011",
            "Aug 29, 2007",
            "Sep 22, 2010",
            "",
            "Mar 14, 2013"
        ],
        [
            "Publication date",
            "Jun 4, 2013",
            "Oct 15, 2013",
            "May 13, 2014",
            "Mar 5, 2009",
            "Mar 24, 2011",
            "Aug 2, 2012",
            "Aug 21, 2014"
        ],
        [
            "Applicant",
            "International Business Machines Corporation",
            "Convey Computer",
            "International Business Machines Corporation",
            "Convey Computer",
            "International Business Machines Corporation",
            "International Business Machines Corporation",
            "Halis ASLAN"
        ],
        [
            "Title",
            "May-constant propagation",
            "Compiler for generating an executable comprising instructions for a plurality of different instruction sets",
            "Management of conditional branches within a data parallel system",
            "Compiler for generating an executable comprising instructions for a plurality of different instruction sets",
            "May-constant propagation",
            "Management of conditional branches within a data parallel system",
            "Method, processing modules and system for executing an executable code"
        ]
    ],
    "pageTitle": "Patent US8196127 - Pervasively data parallel information handling system and methodology for ... - Google Patents",
    "title": "",
    "url": "http://www.google.com/patents/US8196127?dq=6,128,731",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042987866.61/warc/CC-MAIN-20150728002307-00119-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 488684711,
    "recordOffset": 488637128,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{6578=FIG. 15B is a flowchart that depicts a select promotion optimization on the results of the method of FIG. 13 wherein the compiler promotes select operations ahead of other operations in a data flow graph. Moreover, the optimization shown in FIG. 15B illustrates the select promotion optimization of the operations resulting from the graph of FIG. 15A. Process flow commences with the initialization of i0=0, as per block 1530. The compiler executes or forces phi nodes for i1 and j1. Next, the compiler assigns a[i1] and b[i1] to t0 and t1, respectively. The compiler then assigns the test result of t0>t1 to t2 as shown. In this example, the compiler promotes t11 and t12 select operations forward in the code still within the basic block 1540. Next, the compiler assigns the resultant of t11*t12 to s1. The compiler also assigns s1, j1+1, and i1+1 to m[j1], j4, and i2, respectively. Finally, the compiler performs a test on vector length VL, as per t5. If the vector length test indicates that the loop did not complete, control flow returns back to the beginning of block 1540. Otherwise, the control flow completes and the operation ends, as per block 1545.}",
    "TableContextTimeStampAfterTable": "{207561=Both the coded equation path of block 1830 and the default assignment paths of block 1840 merge to loop terminating conditions represented as i3=i2+1, and t5=i3<VL, as per block 1850. If condition t5, per block 1850 is true, the compiler returns to the conditional test computation of block 1820 and the vector culling loop continues. If the condition t5 in block 1850 is false as indicated by, 195980=Next, the compiler deletes the original select statement selection, selected per block 1620 and cleans up any dead computations, as per block 1650. Operational flow continues until the select predicate combining operation is complete and flow ends at end block 1660., 135510=The compiler converts a phi-node j4 to a select statement, as per block 1190. More particularly, if the third condition operand t2, of the select operation statement per block 1190 is true, the compiler assigns the first operand j2 selection to j4. Moreover, if the third condition operand t2 is false, the compiler assigns the second operand j3 selection to j4, as per block 1190. The compiler assigns i1+1 to i2 and also performs a test against the vector length VL, as per block 1190. If the vector length test returns a not satisfied result as per t5, flow returns to block 1160 and execution continues. If the t5 test shows satisfaction of the vector length, namely a true result, the phi-node conversion method step is complete and flow ends at end block 1197., 164065=The compiler then generates a new select instruction, as per block 1455. In block 1455 the compiler selects from a source of the select statement feeding the chosen statement per block 1420 and a source of the select statement under control of the common select condition. In block 1455 the compiler uses the coded sequence insert(assign(dest(select_stmt), select_op(src1(setting_stmt(src1(select_stmt))), src2(select_stmt), src3(select_stmt)))) for the new select instruction generation., 164962=Returning to block 1450, the compiler performs a test to determine if the select condition of the select instruction chosen in block 1420 and the feeding select instruction for src1 share the same condition. If the compiler test of block 1450 returns a false result, the compiler then performs a test to determine if the select condition for the chosen select instruction of step 1420 and the feeding select instruction for src1 share the same condition, but in an inverted form, as per block 1470. The compiler uses the coded sequence is_invert(src3(select_stmt)), src3(setting_stmt(src1(select_stmt))))? to perform the test for inverted form in block 1470., 127268=Flow converges at block 1050 that includes a phi-node for this execution sequence. More specifically, the compiler performs a phi-node operation on j4 and computes i2 as i1+1. Finally the compiler performs a test on t2 to determine if j2<VL, wherein VL is a test vector length. If t5 evaluates false such that the vector length VL is not satisfied, then flow returns to block 1020 per t5 such that the process continues until the full vector length is satisfied and process flow ends at end block 1060., 199519=The compiler initializes a vector culling operation on a basic block at start block 1710. The compiler then identifies a culling condition X, as per block 1715. The compiler identifies a branch point BP to provide efficient scheduling, as per block 1720. In one embodiment, the compiler performs an optimization operation by using static prediction to select a branch point BP, and to further allow the efficient use of static prediction by ensuring the availability of the input operands for the static prediction., 191585=The compiler then inserts a statement into the intermediate representation by selecting from the first input of a SELECT statement feeding the picked SELECT statement of block 1620, and a second input of the picked SELECT statement of block 1620, as per block 1645. The second input of the picked SELECT statement of block 1620 is the same as the second input of the SELECT statement feeding the picked SELECT statement of test block 1630. The compiler generates insert statement insert(assign(dest(select_stmt), select_op(src1(setting_stmt(src1(select_stmt))), src2(select_stmt),p1))); as per block 1645., 157035=However, if the test for more select operations returns a true result, the compiler selects the next select-stmt on which to perform select promotion optimization, again as per block 1320. If the test for additional select operations returns a false result, the select promotion operation is complete and flow ends at end block 1345., 137416=If the test t2 evaluates as true, the compiler assigns t0*2 to t3 and also assigns mb[j1] to vector element m0, as per block 1230. Next, a select operation executes for s0. The compiler also assigns s0 to vector element m[j1] and further assigns j1+1 to j2. The m[j1] assignment represents the conditional store conversion methodologies detailed for the predicated basic block example of coding TABLE 4. The compiler passes flow for the false condition of the t2 test to t2 false block 1240. Per block 1240, the compiler assigns t1*3 to t4, and further assigns m[j1] to vector element m1. Next, the compiler assigns a data select operation to s1. The compiler also assigns s1 to vector element m[j1], and further assigns j1+1 to j3. The m[j1] assignment represents the conditional store conversion for this predicated block. Continuing to block 1250, j4 executes a data-select operation and the compiler assigns i1+1 to i2. Finally, if the vector length test t5 returns a result of not completed, flow returns to block 1220 as per t5 and compilation continues. However, if the vector length returns a completed result, the compiler operation ends as per end block 1255. Blocks 1220, 1230, 1240, and 1250 may together be viewable as a whole to represent a hyperblocking opportunity for the compiler to introduce additional efficiencies and optimizations., 130405=After completing the t2 block 1130, the compiler proceed s to, 201440=If the compiler test of block 1750 returns a true result, the compiler performs a new test to determine if the operation I exhibits a select condition corresponding to the culling condition X with coded sequence, condition(I)=X, as per block 1755. If the compiler test of block 1755 returns a true result, then the compiler identified a select operation that selects between an L input and an S input, as per block 1760. The compiler bases the L and S input selections on the culling condition X that block 1715 identifies. The compiler adds the input that culling condition X selects to the set of values L, via pseudocode L=L\u222aSrc(I,X), as per block 1760. The compiler records an assignment of that input to the target of the select operation in the set S as shown by pseudocode S=S\u222a\u201ctarget(I)=src(I,X)\u201d, as per block 1760. During compiler operation the input that culling condition X selects adds to the set of values L., 158817=The compiler then generates, in block 1380, a new arithmetic operation using the particular select statement chosen in block 1320, and the select results that block 1360 and block 1370 of the first and second select operations produce, respectively. In block 1380 the compiler assigns the generated arithmetic operation as seen by the coded representation of insert(assign(dest(select_stmt), gen_op(setting_op(src1(select_stmt)), t1, t2)))., 91544=As per block 470, the compiler vectorizes the code that results from the optimizations of block 460. In this step, the compiler vectorizes the code by using known vectorization techniques for computational operations, such as described by Bik et al., \u201cAutomatic Intra-Register Vectorization for the Intel Architecture\u201d, International Journal of Parallel Programming, 2002, and Eichenberger et al., \u201cOptimizing Compiler for the Cell Processor\u201d, Conference on Parallel Architectures and Compilation Techniques, 2005, both of which are incorporated herein by reference in their entirety. Finally, the compiler may employ an optional vector culling operation, as per block 480. Vector culling is a technique that the compiler employs to remove, or simplify, execution flow in one or more hyperblocks for entire vectors. Moreover, the compiler performs vector culling when all elements of a vector share the same condition. For strongly biased branches or misbalanced then-else paths, vector culling can provide a performance optimization for the compiled code with respect to data parallel select operations. The compiler removes or culls processing on vectors when computation follows a common condition for all vector elements. In this manner, computation can be simplified when the entire vector corresponds to one execution path through a conditional computation., 195441=The compiler then inserts a statement into the intermediate representation selecting from the second input of the select operation feeding the select operation pick per block 1620, and the second input of the select operation pick of block 1620, as per block 1690. The compiler generates an insert statement insert(assign(dest(select_stmt), select_op(src1(setting_stmt(src1 (select_stmt))), src2(select_stmt), src3(select_stmt)))); as per block 1620., 157415=Returning to block 1330, if the semantic comparison test of setting_op(src1(select_stmt)) and setting_op(src2(select_stmt)) returns a true result, the compiler select promotion operation passes flow to block 1350. The compiler generates two intermediate variables t1 and t2, as per block 1350. Next, the compiler inserts a statement into the intermediate representation with the insert statement insert(assign(t1,select_op(src1(setting_stmt(src1(select_stmt))), src1(setting_stmt(src2(select_stmt))), src3(select_stmt)))), as per block 1360. In block 1360, the compiler inserts a statement into the intermediate representation, by selecting from the first inputs of the first and second operation feeding the select statement chosen in block 1320., 156120=In more detail, the compiler initializes the select promotion operation, as per start block 1310. The compiler then identifies a select_stmt argument to perform the select promotion optimization operation, as per block 1320. The compiler performs a test to determine if the same semantic operation, namely the same type of operation, feeds both src1 and src2, as per block 1330. An example of two operations that exhibit the same type, namely the same semantic type, is two addition operations. Another example of two operations with the same semantic type is two multiplication operations. If the semantic comparison test of setting_op(src1(select_stmt)) and setting_op(src2(select_stmt)) returns a false result, the compiler performs a test to determine if more select operations are available to promote, as per block 1340., 192293=The compiler deletes the original select statement selection, selected per block 1620 and cleans up any dead computations, as per block 1650. The compiler performs a test to determine if more select operations are candidates for select predicate combining, as per block 1655. If the compiler test of block 1655 returns a true result, the compiler picks the next select_stmt on which to perform the select predicate combining optimization, as per block 1620. If the test of block 1655 for additional select operations returns a false result, the select predicate combining operation is complete and flow ends at end block 1660., 200088=The compiler computes a live set of values at the exit of the current basic block BB, shown with pseudocode L=live_out(BB), as per block 1725. The compiler initializes S to the empty set with coded sequence S={}, as per block 1730. The compiler optimization methodology uses coded sequence S to collect operations for injection into a simpler basic block. The collected operations exhibit the coded attributes of culling condition X. With pseudo code I=last_insn(BB), the compiler identifies the last operation of the basic block BB, as per block 1735. More particularly, the compiler assigns the last operation to the condition of I, and begins a backward sweep of the basic block BB., 194178=If the test for select predicate combining returns a false result, the compiler performs a test to determine if any additional predicate combining select operations exist, again per block 1655, and operational flow continues. If the compiler test of block 1670 for select predicate combining of select statement operations returns a true result, the compiler generates variable p1 as intermediate code, as per block 1675., 190858=The compiler inserts a statement into the intermediate representation with the insert statement insert(assign(p1, and_op(src3(setting_stmt(src1(select_stmt))), src3(select_stmt)))); per block 1640. The compiler combines the select predicates (conditions) for the select statements that block 1620 selects, by combining predicates (conditions) of the first and second SELECT statements, as per block 1640. More particularly, the compiler selects the src1 input of a SELECT statement feeding the picked SELECT statement of block 1620 if the conditions of both the first and second select statement are TRUE, as per block 1640., 159346=The compiler performs a dead code elimination operation at block 1390 to eliminate any identifiable unused code. Next, the compiler performs a test to determine if more select operations are available to promote and process flow continues as described per block 1340., 162935=If the test for more select fusion operations of block 1435 returns a true result, the compiler selects the next select_stmt on which to perform select fusion optimization, again as per block 1420. If the test for additional select operations returns a false result, the select fusion operation is complete and flow ends at end block 1440., 203813=The compiler performs a test in block 1755 to determine if compiler operation reaches the branch point BP that block 1720 previously identifies or selects. The culling condition X identifies the branch point BP. If the compiler test of block 1775 returns a false result, the compiler continues the backward sweep operation with the next operation, as per block 1745. Subsequently, the compiler performs an additional test 1745 to determine if the operation condition of I defines one of the values in L, again as per block 1745. If the compiler test 1775 returns a true result, the compiler then generates a new basic block NBB, as per block 1780. Moreover, the compiler generates a representative code path with pseudocode NBB=gen_basic_block( ), per culling condition X, as per block 1780. The compiler then inserts a culling branch or culling branch sequence, at branch point BP based on the culling condition X, to new basic block NBB, as shown by representative pseudocode gen_culling_branch(BP,X,NBB), as per block 1785., 200827=The compiler then performs a test to determine if the operation condition of I represents a branch operation, as per block 1740. If the compiler test of block 1740 returns a false result, the compiler then performs a test to determine if the operation I defines one of the values in L, as per block 1745. If the compiler test of block 1745 returns a true result, the compiler then performs an additional test to determine whether operation i, defining a value in L, is a select operation shown with pseudocode of is_select(I), as per block 1750., 165730=If the compiler test of block 1470 returns a false result, flow continues again to block 1435 wherein the compiler performs a test to determine if more select operations exist that will benefit from select fusion. If the test of block 1470 returns a true result, the compiler determines that the select statement chosen by block 1420 can benefit from the select fusion operation., 162375=The compiler performs a test at block 1430 to determine if a select operation provides an input to the select operation chosen in block 1420. Per block 1430, if the test for input setting_op(src1(select_stmt))==SELECT? returns a false result, the compiler determines that the select operation chosen in block 1420 is not a candidate for select fusion. The compiler then performs a test to determine if more select operations are available for the select fusion operation in block 1435., 166170=The compiler generates a new select instruction using the coded sequence insert(assign(dest(select_stmt), select_op(src1(setting_stmt(src1(select_stmt))), src1(select_stmt), src3(select-stmt)))), as per block 1480. In other words, the compiler generates the new select instruction by selecting from a source of the select statement feeding the chosen select statement, and a source of the select statement under control of the common select condition. The compiler then cleans up dead computations, as per block 1460. The select fusion operation continues until flow ends, as per block 1440., 158307=Next, the compiler inserts a statement into the intermediate representation selecting from the second inputs of the first and second operations feeding the select statement chosen in block 1320, as per block 1370. Also, as per block 1370, the compiler inserts a select statement shown by insert(assign(t2,select_op(src2(setting_stmt(src1(select_stmt))), src2(setting_stmt(src2(select_stmt))), src3(select_stmt))))., 204942=The compiler next inserts operations into new basic block NBB, as per block 1790. The compiler collects operations in set S, and respecting operational def-use dependencies and other such ordering constraints, generates new basic block NBB by inserting the operations from set S into the basic block NBB, as per block 1790. The compiler connects the output control flow edge(s) of new basic block NBB to correspond to an output control flow edge emanating from basic block BB., 193001=Returning to block 1630, if the compiler test with coded sequence setting_op(src1(select-stmt))==SELECT && src2(setting_stmt(src1(select_stmt))==src2(select_stmt)? returns a false result, the compiler then tests to determine if a select operation receives as its input the output of another select operation, as per block 1670. Moreover, the compiler test per block 1670 tests whether the select operations of block 1630 include common features, specifically whether the first input of the first SELECT operation is the same as the second input of the second SELECT operation, for predicate combining. The compiler test of block 1670 utilizes intermediate code setting_op(src1(select_stmt))==SELECT && src1(setting_stmt(src1(select_stmt))==src2(select_stmt)?. The compiler test of block 1670 evaluates an inverse of select statements selected previously in block 1620. Moreover, the compiler test per block 1670 determines if the inverse select statements are candidates for the select predicate combining operation., 163328=If the test for input of block 1430 returns a true result, the compiler select fusion operation passes flow to block 1450. The compiler performs a test in block 1450 to determine if the select condition of the select instruction chosen in block 1420 and the feeding select instruction for src1 share the same condition. The compiler then executes the coded sequence is_same(src3(select_stmt)), src3(setting_stmt(src1(select_stmt))))? for the test, as per block 1450. If the test of block 1450 returns a true result, the compiler determines that the select statement chosen in block 1420 can benefit directly from select fusion., 164642=The compiler performs a dead code elimination operation at block 1460. In this operation the compiler eliminates any identifiable unused code The compiler performs a test at block 1435 to determine if any additional opportunities for select fusion exist and flow continues., 194660=Next, the compiler inserts a statement into the intermediate representation with the insert statement insert(assign(p1,and_op(not_op(src3(setting_stmt(src1(select_stmt))), src3(select_stmt)))); as per block 1680. The compiler inserts the insert statement of block 1680, which combines the select predicates (conditions) of the first and second select operations, as per block 1680. More specifically, the select statements per block 1680 are fed by the second operand of the first select statement pick per block 1620 if the test per block 1630 is False, and the second operand of the second select statement pick per block 1620 if the test per block 1630 is True., 202444=The compiler then identifies the predecessor of the operation I, as per block 1765. Returning to block 1740, if the compiler test of block 1740 returns a true result and if the operation condition of I describes a branch operation, then the compiler executes pseudocode of L=L\u222asources(I) and S=S\u222aI, as per block 1770. Moreover the compiler adds the sources of operation I to the set of variable L, and adds the operation I to the set of instructions S, as per block 1770. Subsequently, returning to the select operation compiler test of block 1750, if the compiler test returns a false result then the compiler executes the pseudocode for L and S, as per block 1770. Returning to the condition compiler test of block 1755, if that compiler test returns a false result, the compiler again executes the pseudocode for L and S, as per block 1770. After the compiler executes the pseudocode for L and S, the compiler again identifies the predecessor of the operation condition of I, as per block 1765. Moreover, if the compiler test of block 1745 determines that the operation condition of I defines one of the values in L by returning a false result, the compiler identifies the predecessor of the operation condition of 1, again as per block 1765.}",
    "textBeforeTable": "Patent Citations Modifications and alternative embodiments of this invention will be apparent to those skilled in the art in view of this description of the invention. Accordingly, this description teaches those skilled in the art the manner of carrying out the invention and is intended to be construed as illustrative only. The forms of the invention shown and described constitute the present embodiments. Persons skilled in the art may make various changes in the shape, size and arrangement of parts. For example, persons skilled in the art may substitute equivalent elements for the elements illustrated and described here. Moreover, persons skilled in the art after having the benefit of this description of the invention may use certain features of the invention independently of the use of other features, without departing from the scope of the invention. The foregoing discloses an information handling system that employs a compiler methodology to convert or optimize code with respect to data parallel select operations. In one embodiment, the disclosed method includes generating data parallel select operations for use in a SIMD environment to replace conventional test and branch statements. The method may provide optimization processes to improve both code length efficiency and data flow graph efficiency. The method may also include a select promotion optimization methodology wherein a compiler promotes select operations ahead of other operations in a dataflow graph. The method may further include a select sinking process that",
    "textAfterTable": "US20050071828 Sep 25, 2003 Mar 31, 2005 International Business Machines Corporation System and method for compiling source code for multi-processor environments US20050097301 * Oct 29, 2003 May 5, 2005 International Business Machines Corporation Vectorization in a SIMdD DSP architecture US20050273770 * Aug 16, 2004 Dec 8, 2005 International Business Machines Corporation System and method for SIMD code generation for loops with mixed data lengths US20050283769 Jun 7, 2004 Dec 22, 2005 International Business Machines Corporation System and method for efficient data reorganization to satisfy data alignment constraints US20050283773 Aug 16, 2004 Dec 22, 2005 International Business Machines Corporation Framework for efficient code generation using loop peeling for SIMD loop code with multiple misaligned statements US20070079302 * Sep 30, 2005 Apr 5, 2007 Intel Corporation Method for predicate promotion in a software loop US20070124722 * Nov 29, 2005 May 31, 2007 Gschwind Michael K Compilation for",
    "hasKeyColumn": false,
    "keyColumnIndex": -1,
    "headerRowIndex": 0
}