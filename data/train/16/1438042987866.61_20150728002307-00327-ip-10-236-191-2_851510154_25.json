{
    "relation": [
        [
            "",
            "55",
            "56",
            "57",
            "58",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "59",
            "60",
            "61",
            "62",
            "63",
            "\u2026",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "",
            "",
            "77",
            "78",
            "79",
            "\u2026",
            "83",
            "84",
            "85",
            "",
            "",
            "",
            "",
            "86",
            "87",
            "88",
            "89",
            "90",
            "91",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "99",
            "100",
            "",
            "",
            "",
            "",
            "101",
            "102",
            "103",
            "",
            "104",
            "105",
            "106",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "107",
            "108",
            "109",
            "",
            "",
            "110",
            "111",
            "112"
        ],
        [
            "",
            "55",
            "56",
            "57",
            "",
            "58",
            "59",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "",
            "66",
            "67",
            "68",
            "\u2026",
            "76",
            "77",
            "78",
            "",
            "",
            "",
            "79",
            "80",
            "81",
            "82",
            "83",
            "\u2026",
            "87",
            "88",
            "89",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "",
            "99",
            "100",
            "101",
            "102",
            "103",
            "104",
            "105",
            "106",
            "107",
            "108",
            "109",
            "110",
            "111",
            "112",
            "",
            "",
            "113",
            "114",
            "115",
            "116",
            "117",
            "118",
            "119",
            "120",
            "121",
            "",
            "122",
            "123",
            "124",
            "125",
            "126",
            "127",
            "",
            "128",
            "129",
            "",
            "130",
            "131",
            "132",
            "133",
            "134",
            "135",
            "136",
            "137",
            "138",
            "",
            "",
            "139",
            "140",
            "141",
            "142",
            "143"
        ],
        [
            "",
            "db = options.get('database')",
            "connection = connections[db]",
            "cursor = connection.cursor()",
            "",
            "converter = connection.introspection.qname_converter",
            "# We might fetch the same table multiple times - once as qualified and",
            "# once as visible table (None, t). That is wanted, so that we can easily",
            "# see if a model with schema = None is installed, as well as if model with",
            "# locked schema is installed.",
            "tables = connection.introspection.all_qualified_names()",
            "",
            "# Get a list of already installed *models* so that references work right.",
            "tables = connection.introspection.table_names()",
            "seen_models = connection.introspection.installed_models(tables)",
            "created_models = set()",
            "pending_references = {}",
            "",
            "]",
            "def model_installed(model):",
            "opts = model._meta",
            "converter = connection.introspection.table_name_converter",
            "return not ((converter(opts.db_table) in tables) or",
            "(opts.auto_created and converter(opts.auto_created._meta.db_table) in tables))",
            "return not ((converter(opts.qualified_name) in tables) or",
            "(opts.auto_created and converter(opts.auto_created._meta.qualified_name) in tables))",
            "",
            "manifest = SortedDict(",
            "(app_name, filter(model_installed, model_list))",
            "",
            "# Create the tables for each model",
            "if verbosity >= 1:",
            "print \"Creating tables ...\"",
            "seen_schemas = connection.introspection.schema_names()",
            "seen_schemas = set([connection.introspection.identifier_converter(s)",
            "for s in seen_schemas])",
            "",
            "for app_name, model_list in manifest.items():",
            "for model in model_list:",
            "# Create the model's database table, if it doesn't already exist.",
            "if verbosity >= 3:",
            "print \"Processing %s.%s model\" % (app_name, model._meta.object_name)",
            "sql, references = connection.creation.sql_create_model(model, self.style, seen_models)",
            "sql = []",
            "schema = connection.convert_schema(model._meta.qualified_name[0])",
            "if schema and schema not in seen_schemas:",
            "q = connection.creation.sql_create_schema(schema, self.style)",
            "if q:",
            "sql.append(q)",
            "seen_schemas.add(schema)",
            "table_sql, references = connection.creation.sql_create_model(model, self.style, seen_models)",
            "sql.extend(table_sql)",
            "seen_models.add(model)",
            "created_models.add(model)",
            "for refto, refs in references.items():",
            "pending_references.setdefault(refto, []).extend(refs)",
            "if refto in seen_models:",
            "sql.extend(connection.creation.sql_for_pending_references(refto, self.style, pending_references))",
            "sql.extend(connection.creation.sql_for_pending_references(model, self.style, pending_references))",
            "ref_sql = connection.creation.sql_for_pending_references(",
            "refto, self.style, pending_references)",
            "if ref_sql:",
            "sql.extend(ref_sql)",
            "ref_sql = sql.extend(connection.creation.sql_for_pending_references(",
            "model, self.style, pending_references))",
            "if ref_sql:",
            "sql.extend(ref_sql)",
            "if verbosity >= 1 and sql:",
            "print \"Creating table %s\" % model._meta.db_table",
            "if model._meta.db_schema:",
            "print \"Creating table %s.%s\" % model._meta.qualified_name",
            "else:",
            "print \"Creating table %s\" % model._meta.db_table",
            "for statement in sql:",
            "cursor.execute(statement)",
            "tables.a ppend(connection.introspection.table_name_converter(model._meta.db_table))",
            "tables.a dd(connection.introspection.qname_converter(model._meta.qualified_name))",
            "",
            "",
            "transaction.commit_unless_managed(using=db)",
            "# We need to see if there are still some pending references left: this",
            "# is possible on backends where we must do cross-schema references",
            "# using different connections (hence also outside the above",
            "# transaction)",
            "if pending_references:",
            "# Pass the references to connection-specific handler.",
            "connection.creation.post_create_pending_references(pending_references)",
            "",
            "# Send the post_syncdb signal, so individual apps can do whatever they need",
            "# to do at this point.",
            "# Send the post_syncdb signal, so individual apps can do whatever they",
            "# need to do at this point.",
            "emit_post_sync_signal(created_models, verbosity, interactive, db)",
            "",
            "# The connection may have been closed by a syncdb handler."
        ]
    ],
    "pageTitle": "6148_django1.5.diff on Ticket #6148 \u2013 Attachment \u2013 Django",
    "title": "",
    "url": "https://code.djangoproject.com/attachment/ticket/6148/6148_django1.5.diff",
    "hasHeader": true,
    "headerPosition": "FIRST_COLUMN",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042987866.61/warc/CC-MAIN-20150728002307-00327-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 851602551,
    "recordOffset": 851510154,
    "tableOrientation": "VERTICAL",
    "TableContextTimeStampAfterTable": "{931495=\u00a9 2005-2015 Django Software Foundation unless otherwise noted. Django is a registered trademark of the Django Software Foundation.}",
    "textBeforeTable": "django/conf/global_settings.py File 6148_django1.5.diff, 194.6 KB (added by akaariai, 3 years ago) Ticket #6148: 6148_django1.5.diff Back to Ticket #6148 Context Navigation Search Wiki Timeline Reports View Tickets API Preferences DjangoProject Login GitHub Login Code \u2665 Donate About Code Community News Documentation Download Overview The web framework for perfectionists with deadlines. Django",
    "textAfterTable": "1226 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 target = self.rel.to._meta. db_table \u00a0 1250 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 target = self.rel.to._meta. qualified_name 1227 1251 \u00a0 \u00a0 \u00a0 \u00a0 cls._meta.duplicate_targets[self.column] = (target, \"m2m\") 1228 1252 1229 1253 \u00a0 \u00a0 def contribute_to_related_class(self, cls, related): django/db/models/query.py \u00a0 1558 1558 \u00a0 \u00a0 \u00a0 \u00a0 A dict mapping column names to model field names. 1559 1559 \u00a0 \u00a0 \u00a0 \u00a0 \"\"\" 1560 1560 \u00a0 \u00a0 \u00a0 \u00a0 if not hasattr(self, '_model_fields'): 1561 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 converter = connections[self.db].introspection. table_name_converter \u00a0 1561 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 converter = connections[self.db].introspection. identifier_converter 1562 1562 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 self._model_fields = {} 1563 1563 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for field in self.model._meta.fields: 1564 1564 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 name, column = field.get_attname_column() django/db/models/sql/query.py",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}