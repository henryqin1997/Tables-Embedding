{
    "relation": [
        [
            "Name",
            "consumeDelete",
            "consumer.delay",
            "consumer.initialDelay",
            "consumer.userFixedDelay"
        ],
        [
            "Default Value",
            "true",
            "500",
            "1000",
            "false"
        ],
        [
            "Description",
            "Option for Db4oConsumer only. Specifies whether or not the entity is deleted after it is consumed.",
            "Option for consumer only. Delay in millis between each poll.",
            "Option for consumer only. Millis before polling starts.",
            "Option for consumer only. Set to true to use fixed delay between polls, otherwise fixed rate is used. See ScheduledExecutorService in JDK for details."
        ]
    ],
    "pageTitle": "Book Component Appendix - Apache Camel - Apache Software Foundation",
    "title": "",
    "url": "https://cwiki.apache.org/confluence/display/CAMEL/Book+Component+Appendix",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042989043.35/warc/CC-MAIN-20150728002309-00224-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 870603303,
    "recordOffset": 870405312,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{539041=ftp://someone@someftpserver.com/public/upload/images/holiday2008?password=secret&binary=true ftp://someoneelse@someotherftpserver.co.uk:12049/reports/2008/password=secret&binary=false ftp://publicftpserver.com/download, 422297=However its more common to have one done file per target file. This means there is a 1:1 correlation. To do this you must use dynamic placeholders in the doneFileName option. Currently Camel supports the following two dynamic tokens: file:name and file:name.noext which must be enclosed in ${ }., 718776=sync=true indicates that this listener is synchronous and therefore will return a HL7 response to the caller. The HL7 codec is setup with encoder=#hl7encoder and decoder=#hl7decoder. Note that hl7encoder and hl7decoder are just bean IDs, so they could be named differently. The beans can be set in the Spring XML file:, 328159=This looks up a domain's IP. For example, www.example.com resolves to 192.0.32.10. The IP address to lookup must be provided in the header with key \"dns.domain\"., 715192=sync=true indicates that this listener is synchronous and therefore will return a HL7 response to the caller. The HL7 codec is setup with codec=#hl7codec. Note that hl7codec is just a Spring bean ID, so it could be named mygreatcodecforhl7 or whatever. The codec is also set up in the Spring XML file:, 306860=1000, 362416=Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again., 713126=The encoding (a charset name) to use for the codec. If not provided, Camel will use the JVM default Charset., 721201=The sample below is a request to lookup a patient with the patient ID 0101701234., 414978=When Camel is producing files (writing files) there are a few gotchas affecting how to set a filename of your choice. By default, Camel will use the message ID as the filename, and since the message ID is normally a unique generated ID, you will end up with filenames such as: ID-MACHINENAME-2443-1211718892437-1-0. If such a filename is not desired, then you must provide a filename in the CamelFileName message header. The constant, Exchange.FILE_NAME, can also be used., 1016863=1000, 419767=However its more common to have one done file per target file. This means there is a 1:1 correlation. To do this you must use dynamic placeholders in the doneFileName option. Currently Camel supports the following two dynamic tokens: file:name and file:name.noext which must be enclosed in ${ }. The consumer only supports the static part of the done file name as either prefix or suffix (not both)., 800426=An integer to define a maximum messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it., 730434=1234, 113251=1500, 711142=HL7 is often used with the HL7 MLLP protocol, which is a text based TCP socket based protocol. This component ships with a Mina and Netty4 Codec that conforms to the MLLP protocol so you can easily expose an HL7 listener accepting HL7 requests over the TCP transport layer. To expose a HL7 listener service, the camel-mina2\u00a0or camel-netty4 component is used with the HL7MLLPCodec\u00a0(mina2) or HL7MLLPNettyDecoder/HL7MLLPNettyEncoder (Netty4)., 711727=HL7 MLLP codec can be configured as follows:, 1062993=In this example the fixed reply queue named \"bar\" is used. By default Camel assumes the queue is shared when using fixed reply queues, and therefore it uses a JMSSelector to only pickup the expected reply messages (eg based on the JMSCorrelationID). See next section for exclusive fixed reply queues. That means its not as fast as temporary queues. You can speedup how often Camel will pull for reply messages using the receiveTimeout option. By default its 1000 millis. So to make it faster you can set it to 250 millis to pull 4 times per second as shown:, 720305=The HL7 MLLP codec uses plain String as its data format. Camel uses its Type Converter to convert to/from strings to the HAPI HL7 model objects, but you can use the plain String objects if you prefer, for instance if you wish to parse the data yourself., 436960=By default Camel uses a in memory based store for keeping track of consumed files, it uses a least recently used cache holding up to 1000 entries. You can plugin your own implementation of this store by using the idempotentRepository option using the # sign in the value to indicate it's a referring to a bean in the Registry with the specified id., 48132=Is only used by the filter, as the starting timestamp for selection never entries (uses the entry.updated timestamp). Syntax format is: yyyy-MM-ddTHH:MM:ss. Example: 2007-12-24T17:45:59., 133857=2048, 314956=1000, 49925=1000, 378378=An integer to define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. See more details at Batch Consumer. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.}",
    "textBeforeTable": "URI Options The queue will be created if they don't already exists. You can append query options to the URI in the following format, ?options=value&option2=value&... ]]> </property> </bean> <property name=\"topicPrefix\" value=\"topic://\" /> <!-- only necessary when connecting to ActiveMQ over AMQP 1.0 --> <constructor-arg index=\"0\" type=\"java.lang.String\" value=\"amqp://localhost:5672\" /> <bean class=\"org.apache.qpid.amqp_1_0.jms.impl.ConnectionFactoryImpl\" factory-method=\"createFromURL\"> <property name=\"connectionFactory\">",
    "textAfterTable": "null Shared The region with which the AWS-SQS client wants to work with. Only works if Camel creates the AWS-SQS client, i.e., if you explicitly set amazonSQSClient, then this setting will have no effect. You would have to set it on the client you create directly attributeNames null Consumer A list of attributes to set in the com.amazonaws.services.sqs.model.ReceiveMessageRequest. concurrentConsumers 1 Consumer (as of 2.15.0) Allows you to use multiple threads to poll the sqs queue to increase throughput defaultVisibilityTimeout null Shared The visibility timeout (in seconds) to set in the com.amazonaws.services.sqs.model.CreateQueueRequest. deleteAfterRead true Consumer Delete message from SQS after it has been read deleteIfFiltered true Consumer Camel 2.12.2,2.13.0 Whether or not to send the DeleteMessage to the SQS queue if an exchange fails to get through a filter. If 'false' and exchange does not make it through a Camel filter upstream in the route, then don't send DeleteMessage. maxMessagesPerPoll null Consumer The maximum number of messages which can be received in one poll to set in the com.amazonaws.services.sqs.model.ReceiveMessageRequest. visibilityTimeout null Shared The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request to set in the com.amazonaws.services.sqs.model.SetQueueAttributesRequest. This only make sense",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}