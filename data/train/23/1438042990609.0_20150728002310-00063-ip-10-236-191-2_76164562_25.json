{
    "relation": [
        [
            "Http Status Code",
            "200",
            "200"
        ],
        [
            "Sently Plus Error Code",
            "5026",
            "5017"
        ],
        [
            "Description",
            "Campaign job does not exist",
            "Cannot delete campaign"
        ],
        [
            "Scenario",
            "There was no campaign with the specified id",
            "Processing for the campaign may have already started or is about to start"
        ],
        [
            "Resolution",
            "Please change the id in the request and try again",
            "Try again later after the campaign has been processed"
        ]
    ],
    "pageTitle": "SentlyPlus API v1.0\u2014by apiary.io",
    "title": "",
    "url": "http://docs.sentlyplus.apiary.io/",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990609.0/warc/CC-MAIN-20150728002310-00063-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 76186639,
    "recordOffset": 76164562,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{3313=URL encode the consumer key and the consumer secret according to RFC 1738. Note that at the time of writing, this will not actually change the consumer key and secret, but this step should still be performed in case the format of those values changes in the future.}",
    "textBeforeTable": "Below are example values showing the result of this algorithm. Note that the consumer secret used in this page has been disabled and will not work for real requests. Base64 encode the string from the previous step. Concatenate the encoded consumer key, a colon character \":\", and the encoded consumer secret into a single string. URL encode the consumer key and the consumer secret according to RFC 1738. Note that at the time of writing, this will not actually change the consumer key and secret, but this step should still be performed in case the format of those values changes in the future. The steps to encode an application's consumer key and secret into a set of credentials to obtain a bearer token are: Step 1: Encode consumer key and secret Issuing authenticated requests This manner of authentication is only secure if SSL is used. Therefore, all requests (both to obtain and use the tokens) must use HTTPS endpoints, which is also a requirement of using API v1.0. SSL absolutely required Keep in mind that the consumer key & secret, bearer token credentials, and the bearer token itself grant access to make requests on behalf of an application. These values should be considered as sensitive as passwords and must not be shared or distributed to untrusted parties. Tokens are passwords About Client Credentials Grant authorization When accessing the REST API, the application uses the bearer token to",
    "textAfterTable": "TTJFNU1EZGpNbVl0WldNMU5DMDBZbVJsTFRsa1kxSXRaakUzTTJabU1qWTVNVEEwOk 5HVTFOemc1WTJVdFlUWXhOeTAxTURNMkxXSmlZV1l0WXpFNFkySTVaR1kyTVRjeA== Step 2: Obtain a bearer token The value calculated in step 1 must be exchanged for a bearer token by issuing a request to POST api/token: The request must be a HTTP POST request. The request must include an Authorization header with the value of Basic <base64 encoded value from step 1>. The request must include a Content-Type header with the value of application/x-www-form-urlencoded;charset=UTF-8. The body of the request must be grant_type=client_credentials. Example request (Authorization header has been wrapped): POST /api/token HTTP/1.1 Host: plus.sent.ly User-Agent: My SMS App Authorization: Basic TTJFNU1EZGpNbVl0WldNMU5DMDBZbVJsTFRsa1kxSXRaakUzTTJabU1qWTVNVEEwOk 5HVTFOemc1WTJVdFlUWXhOeTAxTURNMkxXSmlZV1l0WXpFNFkySTVaR1kyTVRjeA== Content-Type: application/x-www-form-urlencoded;charset=UTF-8 Content-Length: 29 Accept-Encoding: gzip grant_type=client_credentials If the request was formatted correctly, the server will respond with a JSON-encoded payload: Example response (access_token has been wrapped): HTTP/1.1 200 OK Status: 200 OK Content-Type: application/json; charset=utf-8 ... Content-Encoding: gzip Content-Length: 140 {\"token_type\":\"bearer\",\"access_token\":\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAA AAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"} Applications should verify that the value associated with the token_type key of the returned object is bearer. The value associated with the access_token key is the bearer token. Note that one bearer token is valid for an application at a time. Issuing another request with the same credentials to /api/token will return the same token until it is invalidated. Step 3: Authenticate API requests with the bearer token The bearer token may be used to issue requests to the REST API endpoints. To use the bearer token, construct a normal HTTPS request and include an Authorization header with the",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}