{
    "relation": [
        [
            "Date",
            "Sep 14, 2011",
            "Apr 10, 2015"
        ],
        [
            "Code",
            "AS",
            "REMI"
        ],
        [
            "Event",
            "Assignment",
            "Maintenance fee reminder mailed"
        ],
        [
            "Description",
            "Owner name: U.S.A. AS REPRESENTED BY THE SECRETARY OF THE NAVY Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:ROUSON, DAMLAN;REEL/FRAME:026909/0311 Effective date: 20070912",
            ""
        ]
    ],
    "pageTitle": "Patent US8010943 - Dynamic memory management system and method - Google Patents",
    "title": "",
    "url": "http://www.google.com/patents/US8010943?dq=6,957,233",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990609.0/warc/CC-MAIN-20150728002310-00054-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 469077731,
    "recordOffset": 469044998,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{6349=\u2202 T \u2202 t = 1 \u03b1 ( \u2202 2 T \u2202 x 2 + \u2202 2 T \u2202 y 2 + \u2202 2 T \u2202 z 2 ) - ( u \u2202 T \u2202 x + v \u2202 T \u2202 y + w \u2202 T \u2202 z ) Eq . ( 1 ) where u=(u,v,w)1 is the Fluid velocity field and \u03b1 is the thermal diffusivity. The first parenthetical terms on the right-hand side (RHS) of Eq. (1) model thermal diffusion, which is energy transport by random molecular motions. The second parenthetical terms model thermal advection, or \u201cconvection\u201d, which is energy transport by organized motions (fluid flow). The operators required to evaluate the RHS of Eq. (1) include the arithmetic operators x, +, and \u2212, the differential operators \u2202/\u2202x, \u2202/\u2202y, and \u2202/\u2202z and combinations thereof. For example, the Fortran 95 or Fortran 2003 source code is as follows: dT \u2014 dt=(1/alpha)*(d2\u2014 dx2(T,1)+d2\u2014 dx2(T,2)+d2\u2014 dx2(T,3))&\u2212(u*d \u2014 dx(T,1))+v*d \u2014 dx(T,2))+w*d \u2014 dx(T,3)), wherein \u201c&\u201d is a continuation character joining the previous two lines.}",
    "TableContextTimeStampAfterTable": "{64671=The Fortran 95 and Fortran 2003 standards require overloaded operators and the procedures they call to be free of side effects. That is, they cannot modify their arguments. The \u201cINTENT(IN)\u201d attribute enforces this condition, but also poses a memory management dilemma. In composite (nested) function calls, the left and right arguments could have appeared as a RESULT in an operator of higher precedence. The operator passing its result to field_plus_field is likely to have allocated memory for that result's fourier or physical component just as field_plus_field will likely need to allocate space for total % fourier or total % physical via a statement of the form ALLOCATE(total%physical(nx,ny,nz)) where nx, ny, and nz are integers. The easiest and most efficient place for the programmer to release memory that was dynamically allocated inside the result of one operator is inside the operator to which this result is passed. However, the operator receiving the result cannot modify it. A similar dilemma relates to defined assignments such as, 57375=Although OCL is programming language-independent, it will prove fruitful to discuss programming language characteristics amenable for use with the instant invention. Factors for choosing an acceptable language for use in an embodiment of the instant invention, e.g., Fortran 95 and Fortran 2003, include the language's operator overloading ability and ability to allocate and de-allocate memory dynamically., 38298=The Fortran 95 standard provided only one mechanism for derived type components whose memory requirements are not known at compile-time. That mechanism was pointer components. Given the havoc pointers potentially wreak on optimizing compilers and the resulting performance penalty, this mechanism offered limited utility for the class of CS&E programs in which long loops over fine-grained data objects form the dominant activity. This deficiency was recognized soon after the publication of the Fortran 95 standard, and the standards committee promised in a 1998 technical report to include allocatable components in derived types in its next standard. Allocatable components are now officially a feature of Fortran 2003., 89406=Reusing the entire temporary object is advised though not required, while giving its array component the ALLOCATABLE attribute, rather than the POINTER attribute. In Fortran 95 and Fortran 2003, an ALLOCATABLE array can be thought of as a limited type of pointer\u2014one which can be associated with memory only through an ALLOCATE statement, not through target redirection or pointer arithmetic. This limitation has important performance benefits with optimizing compilers. ALLOCATABLE arrays are guaranteed to contain contiguous memory that can be accessed with unit stride; whereas a Fortran POINTER can target an array subsection that might not be contiguous. Any resulting lack of spatial locality could retard cache performance., 81936=As valid OCL expressions, the above constraints are backed by a formal grammar defined in Extended Backus-Naur Form (EBNF). An EBNF grammar specifies the semantic structure of allowable statements in a formal language. The statements' meanings can therefore be communicated unambiguously as part of the UML design document. An additional advantage of formal methods is their ability to express statements that could not be written in an executable language. One example is the relationship between the Boolean expressions in the implies statement. Another is the fact that these constraints must be satisfied on the set of all instances of the class. Programs that run on finite state machines cannot express conditions on sets that must in theory be unbounded. An additional benefit is that the set theory and predicate logic behind formal methods facilitate proving additional desirable properties from the specified constraints. (Such proofs are most naturally developed by translating the constraints into a mathematical notation that is opaque to those who are not formal methods specialists. Since the non-specialists OCL targets coincide with our intended audience, proving additional properties mathematically would detract from our main purpose.) Finally, a more concrete benefit will be explained. After detailing the run-time checks inspired by the OCL pre- and postconditions., 98770=Although the above-described embodiments of the invention refer to Fortran 2003, it is to be understood that any programming language that, for example, permits operator overloading is within the scope of the invention. For example, an embodiment of the invention is implemented using C++., 53121=D. W. I. Rouson et al., Dynamic Memory De-allocation in Fortran 95/2003 Derived Type Calculus, Scientific Programming 13(3) 2005, (\u201cRMX\u201d) incorporated herein by reference, discusses informal memory management rules for using the Integrand class to integrate the time derivative on the left-hand side of evolutions equations such as Eq. (1). specification in any natural language such as English is inherently informal due to the ambiguities associated with such languages. Evaluation of the right-hand side of Eq. (1) is discussed as follows in light of increased memory requirements of 3D fields., 29716=In operator overloading, a programmer writes a definition for the application of an intrinsic or built-in operator to arguments of a non-intrinsic or programmer-defined data type. Such a definition comprises a procedure and its interface. Using Fortran 95 and Fortran 2003 as illustrative tools, the programmer who has defined a data type foo containing one floating point component bar as follows:, 83357=The above rules can be refined to encourage more economical memory usage. For this purpose, consider again the function field_plus_field( ), which takes arguments left and right, return total and has the generic interface operator (+)]. We can ensure economical memory usage by specifying that temporary memory be recycled. To facilitate this, left, right, and total must be pointers. In Fortran 2003, this means adding the POINTER attribute to their declarations as follows:, 75260=Although there is no explicit result passed by a defined assignment (Fortran 95 and Fortran 2003 require a defined assignment to be a SUBROUTINE), the implicit result is the left-hand argument, which is passed by reference and modified to contain a copy of the right-hand argument. The latter postcondition specifies that left must be persistent., 90169=In an embodiment of the invention, a benefit of developing the economizing constraints relates to the conceptual leap required to model pointers in OCL. Prior to making that leap, expressing INTENT for POINTER arguments was thought not possible. The ability to do so is a Fortran 2003 feature not yet available in some compilers, and only very recently added to others. Developing the Field_Pointer class model inspired us to implement an analogous data structure that facilitated emulating pointer intent before it was available in compilers. This breakthrough enabled operator overloading. Without it, the above-mentioned hermeticity constraints would not be satisfied, unless an awkward syntax was used, such as described in RMX., 85527=Since OCL does not have a pointer type, pointers are modeled as a UML association between two classes. Left, right and total are modeled as instances of a Field_Pointer class that exists solely for its association with the Field class. It is assumed here the Field_Pointer class implements the services of Fortran 95 and Fortran 2003 pointers, including an ASSOCIATED( ) method that returns a Boolean value specifying whether its first argument is associated with its second argument.}",
    "textBeforeTable": "Patent Citations Obviously, many modifications and variations of the present invention are possible in light of the above teachings without departing from the true scope and spirit of the invention. It is therefore to be understood that the scope of the invention should be determined by referring to the following appended claims. Although the above-described embodiments of the invention refer to Fortran 2003, it is to be understood that any programming language that, for example, permits operator overloading is within the scope of the invention. For example, an embodiment of the invention is implemented using C++. This restricts changing with what target object the target field pointer is associated, while it allows one to DEALLOCATE the ALLOCATABLE array inside the target. \u2003TYPE (Field Pointer), :: total \u2003TYPE (Field Pointer), INTENT (IN) :: left, right FUNCTION field plus Field (left, right) RESULT (total) END TYPE Field \u2014 Pointer \u2003TYPE (Field), POINTER :: target _field TYPE Field \u2014 Pointer",
    "textAfterTable": "Aug 15, 2006 David H. Alderson Grammer for regular expressions US7814462 * Aug 31, 2005 Oct 12, 2010 Massachusetts Institute Of Technology Methods and apparatus for parallel execution of a process US20070294682 * Mar 5, 2007 Dec 20, 2007 Demetriou Christopher G Systems and methods for caching compute kernels for an application running on a parallel-processing computer system US20080307174 * Jun 8, 2007 Dec 11, 2008 Apple Inc. Dual Use Memory Management Library * Cited by examiner Non-Patent Citations Reference 1 * A. Iyengar et al.; Design and performance of a general-purpose software cache; IEEE International, 1998-ieeexplore.ieee.org; pp. 1-8. 2 * A. Iyengar et al.; Design and performance of a general-purpose software cache; IEEE International, 1998\u2014ieeexplore.ieee.org; pp. 1-8. 3 * D. Walker et al.; Alias types for recursive",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}