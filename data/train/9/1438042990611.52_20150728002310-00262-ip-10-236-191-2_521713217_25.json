{
    "relation": [
        [
            "Name",
            "ergonomics",
            "frag_size",
            "id",
            "level",
            "max_retained_buffer",
            "name",
            "stats"
        ],
        [
            "Description",
            "Enables ergonomics: dynamically find the best values for properties at runtime",
            "The max number of bytes in a message. Larger messages will be fragmented. Default is 8192 bytes",
            "Give the protocol a different ID if needed so we can have multiple instances of it in the same stack",
            "Sets the logger level (see javadocs)",
            "The max size in bytes for the byte array output buffer",
            "Give the protocol a different name if needed so we can have multiple instances of it in the same stack (also change ID)",
            "Determines whether to collect statistics (and expose them via JMX). Default is true"
        ]
    ],
    "pageTitle": "Reliable Multicasting with the JGroups Toolkit",
    "title": "",
    "url": "http://www.jgroups.org/manual/html_single/index.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990611.52/warc/CC-MAIN-20150728002310-00262-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 521812835,
    "recordOffset": 521713217,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{256133=This functionality was implemented in https://jira.jboss.org/browse/JGRP-1181., 28872=In the fall of 2002, Sacha Labourey contacted me, letting me know that JGroups was being used by JBoss for their clustering implementation. I joined JBoss in 2003 and have been working on JGroups and JBossCache. My goal is to make JGroups the most widely used clustering software in Java ..., 29176=Bela Ban, San Jose, Aug 2002, Kreuzlingen Switzerland 2006, 208374=TCPGOSSIP uses the GossipRouter (outside the firewall) at port 12001 to register its address (periodically) and to retrieve the initial membership for its group. It is not recommended to use TCPGOSSIP for discovery if TUNNEL is already used. TCPGOSSIP might be used in rare scenarios when registration and initial member discovery has to be done through gossip router indepedent of transport protocol being used. Starting with 2.8 release TCPGOSSIP accepts one or multiple router hosts as a comma delimited list of host[port] elements specified in a property initial_hosts., 26216=I spent 1998-1999 at the Computer Science Department at Cornell University as a post-doc, in Ken Birman's group. Ken is credited with inventing the group communication paradigm, especially the Virtual Synchrony model. At the time they were working on their third generation group communication prototype, called Ensemble. Ensemble followed Horus (written in C by Robbert VanRenesse), which followed ISIS (written by Ken Birman, also in C). Ensemble was written in OCaml, developed at INRIA, and is a functional language and related to ML. I never liked the OCaml language, which in my opinion has a hideous syntax. Therefore I never got warm with Ensemble either., 209833=Note that TUNNEL has to be given the hostname and port of the GossipRouter process. This example assumes a GossipRouter is running on the local host at port 12001. Both TUNNEL and TCPGOSSIP (or PING) access the same GossipRouter. Starting with 2.8 release TUNNEL transport layer accepts one or multiple router hosts as a comma delimited list of host[port] elements specified in a property gossip_router_hosts., 58438=JGroups project has been around since 2001. Over this time, some of the JGroups classes have been used in experimental phases and have never been matured enough to be used in today's production releases. However, they were not removed since some people used them in their products., 1156=Copyright \u00a9 2006-2011 Red Hat Inc, 1069=Copyright \u00a9 1998-2006 Bela Ban, 457669=[Ensemble:1997] The Ensemble Distributed Communication System , CS Dept Cornell University , 1997 . http://www.cs.cornell.edu/Info/Projects/Ensemble/index.html ., 278595=Before sending messages with instances of MyHeader attached, the program registers the MyHeader class with the ClassConfigurator. The example uses a magic number of 1900, but any number greater than 1024 can be used. If the magic number was already taken, an IllegalAccessException would be thrown., 97483=Each layer may have zero or more arguments, which are specified as a list of name/value pairs in parentheses directly after the protocol name. In the example above, UDP is configured with some options, one of them being the IP multicast address (mcast_addr) which is set to 228.10.10.10, or to the value of the system property jgroups.udp.mcast_addr, if set., 104178=A channel can be given a logical name which is then used instead of the channel's address. A logical name might show the function of a channel, e.g. \"HostA-HTTP-Cluster\", which is more legible than a UUID 3c7e52ea-4087-1859-e0a9-77a0d2f69f29., 437193=STOMP is a JGroups protocol which implements the STOMP protocol. Currently (as of Nov 2010), transactions and acks are not implemented., 440756=There are 4 nodes in a cluster. Say the cluster is in a LAN, and communication is via IP multicasting (UDP as transport). We now have clients which do not want to be part of the cluster themselves, e.g. because they're in a different geographic location (and we don't want to switch the main cluster to TCP), or because clients are frequently started and stopped, and therefore the cost of startup and joining wouldn't be amortized over the lifetime of a client. Another reason could be that clients are written in a different language, or perhaps, we don't want a large cluster, which could be the case if we for example have 10 JGroups server nodes and 1000 clients connected to them., 174702=Currently (Jan 2011), there are 2 protocols which provide locking: Section\u00a07.13.8.2, \u201cPEER_LOCK\u201d and Section\u00a07.13.8.1, \u201cCENTRAL_LOCK\u201d. The locking protocol has to be placed at or towards the top of the stack (close to the channel)., 1504=Jan 2011, 458140=[Gamma:1995] Erich Gamma , Richard Helm , Ralph Johnson , and John Vlissides . Design Patterns: Elements of Reusable Object-Oriented Software . Addison-Wesley , 1995 ., 179744=Currently (March 2011), there is 1 protocol which provide executions: Section\u00a07.13.9, \u201cCENTRAL_EXECUTOR\u201d. The executing protocol has to be placed at or towards the top of the stack (close to the channel)., 275615=The final requirement is to add the newly created header class to jg-magic-map.xml (in the ./conf directory), or - if this is not a JGroups internal protocol - to add the class to ClassConfigurator. This can be done with method ClassConfigurator.getInstance().put(1899, MyHeader.class)., 28570=At around that time (May 2000), SourceForge had just opened its site, and I decided to use it for hosting JGroups. I guess this was a major boost for JGroups because now other developers could work on the code. From then on, the page hit and download numbers for JGroups have steadily risen., 71205=Method receive() will be called when a message is received. The getState() and setState() methods are used to fetch and set the group state (e.g. when joining). Refer to Section\u00a03.6.13, \u201cGetting the group's state\u201d for a discussion of state transfer., 71888=JGroups release 2.3 introduced ExtendedMessageListener enabling partial state transfer (refer to Section\u00a03.6.15, \u201cPartial state transfer\u201d ) while release 2.4 further expands ExtendedMessageListener with streaming state transfer callbacks:}",
    "lastModified": "Wed, 20 Jul 2011 16:17:29 GMT",
    "textBeforeTable": "Table\u00a07.1.\u00a0Properties 7.1.1.\u00a0UDP 7.1.\u00a0Transport Behavior Provided services Required services Properties provided For each protocol define: The most important properties are described on the wiki. The idea is that users take one of the predefined configurations (shipped with JGroups) and make only minor changes to it. This section is work in progress; we strive to update the documentation as we make changes to the code. Chapter\u00a07.\u00a0List of Protocols Getting a header is done through Message.getHeader() which takes the name as argument. This name of course has to be the same as the one used in putHeader(). The final part is adding an instance of MyHeader to a message using Message.putHeader(). The first argument is a name which has to be unique across all headers for a given message. Usually, protocols use the protocol name (e.g. \"UDP\", \"NAKACK\"), so these names should not be used by an application. The second argument is an instance of the header. Before sending messages with instances of MyHeader attached, the program registers the MyHeader class with the ClassConfigurator. The example uses a magic number of 1900, but any number greater than 1024",
    "textAfterTable": "disable_loopback \u00a0 discard_incompatible_packets Discard packets with a different version if true. Default is false enable_bundling Enable bundling of smaller messages into bigger ones. Default is true enable_diagnostics Switch to enable diagnostic probing. Default is true enable_unicast_bundling Enable bundling of smaller messages into bigger ones for unicast messages. Default is false ergonomics Enables ergonomics: dynamically find the best values for properties at runtime id Give the protocol a different ID if needed so we can have multiple instances of it in the same stack ip_mcast Multicast toggle. If false multiple unicast datagrams are sent instead of one multicast. Default is true ip_ttl The time-to-live (TTL) for multicast datagram packets. Default is 8 level Sets the logger level (see javadocs) log_discard_msgs whether or not warnings about messages from different groups are logged logical_addr_cache_expiration Time (in ms) after which entries in the logical address cache marked as removable are removed logical_addr_cache_max_size Max number of elements in the logical address cache before eviction starts loopback Messages to self are looped back immediately if true max_bundle_size Maximum number of bytes for messages to be queued until they are sent max_bundle_timeout Max number of milliseconds until queued messages are sent mcast_group_addr The multicast address used for sending",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}