{
    "relation": [
        [
            "Date",
            "Mar 17, 2008",
            "Sep 21, 2010",
            "Jul 30, 2013",
            "Nov 15, 2013"
        ],
        [
            "Code",
            "AS",
            "CC",
            "FPAY",
            "AS"
        ],
        [
            "Event",
            "Assignment",
            "Certificate of correction",
            "Fee payment",
            "Assignment"
        ],
        [
            "Description",
            "Owner name: ALACRITECH, INC., CALIFORNIA Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BOUCHER, LAURENCE B.;BLIGHTMAN, STEPHEN E. J.;CRAFT, PETER K.;AND OTHERS;REEL/FRAME:020666/0858;SIGNING DATES FROM 19991026 TO 19991111 Owner name: ALACRITECH, INC.,CALIFORNIA Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BOUCHER, LAURENCE B.;BLIGHTMAN, STEPHEN E. J.;CRAFT, PETER K.;AND OTHERS;SIGNING DATES FROM 19991026 TO 19991111;REEL/FRAME:020666/0858 Owner name: ALACRITECH, INC., CALIFORNIA Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNORS:BOUCHER, LAURENCE B.;BLIGHTMAN, STEPHEN E. J.;CRAFT, PETER K.;AND OTHERS;SIGNING DATES FROM 19991026 TO 19991111;REEL/FRAME:020666/0858",
            "",
            "Year of fee payment: 4",
            "Owner name: A-TECH LLC, DELAWARE Free format text: ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:ALACRITECH INC.;REEL/FRAME:031644/0783 Effective date: 20131017"
        ]
    ],
    "pageTitle": "Patent US7664868 - TCP/IP offload network interface device - Google Patents",
    "title": "",
    "url": "http://www.google.com/patents/US7664868?dq=3140553",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042986423.95/warc/CC-MAIN-20150728002306-00155-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 488343547,
    "recordOffset": 488211892,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{6304=In general, a first instruction phase 500 of the pipelined microprocessors completes an instruction and stores the result in a destination operand, fetches the next instruction, and stores that next instruction in an instruction register. A first register set 490 provides a number of registers including the instruction register, and a set of controls 492 for first register set provides the controls for storage to the first register set 490. Some items pass through the first phase without modification by the controls 492, and instead are simply copied into the first register set 490 or a RAM file register 533. A second instruction phase 560 has an instruction decoder and operand multiplexer 498 that generally decodes the instruction that was stored in the instruction register of the first register set 490 and gathers any operands which have been generated, which are then stored in a decode register of a second register set 496. The first register set 490, second register set 496 and a third register set 501, which is employed in a third instruction phase 600, include many of the same registers, as will be seen in the more detailed views of FIGS. 15A-C. The instruction decoder and operand multiplexer 498 can read from two address and data ports of the RAM file register 533, which operates in both the first phase 500 and second phase 560. A third phase 600 of the processor 470 has an arithmetic logic unit (ALU) 602 which generally performs any ALU operations on the operands from the second register set, storing the results in a results register included in the third register set 501. A stack exchange 608 can reorder register stacks, and a queue manager 503 can arrange queues for the processor 470, the results of which are stored in the third register set.}",
    "TableContextTimeStampAfterTable": "{381531=Any 802.3/MII compliant PHY can be utilized, allowing the microprocessor to support 10BASE-T, 10BASE-T2, 100BASE-TX, 100Base-FX and 100BASE-T4 as well as future interface standards. PHY identification and initialization is accomplished through host driver initialization routines. PHY status registers can be polled continuously by the microprocessor and detected PHY status changes reported to the host driver. The Mac can be configured to support a maximum frame size of 1518 bytes or 32768 bytes., 80045=But what about applications that do not reside above NetBIOS? In this case we can not rely on a session level protocol to tell us the length of the transaction. Under these circumstances we will buffer the data as it arrives until, 1) we have received some predetermined number of bytes such as 8 k, or 2) some predetermined period of time passes between segments, or 3) we get a push flag. If after any of these conditions occur we will then indicate some or all of the data to the host depending on the amount of data buffered. If the data buffered is greater than about 1500 bytes we must then also wait for the memory address to be returned from the host so that we may then DMA the remainder of the data., 133611=From the TDI spec, the amount of data in the buffer actually sent must be at least 128 bytes. In fact, we have room for 192 bytes in our \u201csmall\u201d buffers; and experiments show that, to make the NETBT code respond correctly, it is necessary to pass more than 128 bytes. So for a full segment which starts with a NETBIOS header, we pass a \u201cheader\u201d of 192 bytes, together with the actual NETBIOS length, which will be indicated up as the \u201cavailable\u201d length. For segments less than a full 1460 byte payload, all of the received segment will be forwarded; it will be absorbed directly by the TDI client without any further memory descriptor list (MDL) exchange. Experiments tracing the TDI data flow show that the NETBT client directly absorbs up to 1460 bytes: the amount of payload data in a single Ethernet frame., 96909=For receiving messages we have abandoned the conventional receive descriptor queue for performance reasons. Small transactions on PCI can severely limit PCI bus throughput. In the typical receive descriptor environment a NIC must first read a descriptor (typically 16-32 bytes) across PCI to get the buffer information. It then moves the data across PCI into the buffer, and then writes status back into the receive descriptor. One objective of our receive design was to eliminate the first descriptor read. Thus we needed an efficient way in which to pass receive buffer addresses to the INIC. We accomplished this by passing a block of receive buffers to the INIC at one time. In the driver we allocate a block of contiguous memory (typically a page, which is typically 4 k). We write the address of that block to the INIC with the bottom bits of the address specifying the number of buffers in the block. In order to receive 1514 byte frames (maximum ether frame size), however, we can only fit two buffers in a 4 k page, which is not a substantial savings. Fortunately, network frames tend to be either large (\u02dc1500 bytes), or small (<256 bytes)., 49133=Moving all this data with the CPU slows the system down even after the data has been moved. Since both the source and destination cache lines must be pulled into the CPU cache when the data is moved, more than 3 k of instructions and or data resident in the CPU cache must be flushed or invalidated for every 1500 byte frame. This is of course assuming a combined instruction and data second level cache, as is the case with the Pentium processors. After the data has been moved, the former resident of the cache will likely need to be pulled back in, stalling the CPU even when we are not performing network processing. Ideally a system would never have to bring network frames into the CPU cache, instead reserving that precious commodity for instructions and data that are referenced repeatedly and frequently., 295087=ne2000hw.h\u2014The hardware definitions for the ne2000 NIC card.c\u2014Low-level ne2000 network card routines,, 295221=interrupt.c\u2014Interrupt, transmit and receive routines for the ne2000 portion of the INIC VPCI driver,, 422591=The \u201cjump\u201d (Jmp) instruction causes the program counter to be altered unconditionally. The new program counter (Pc) value is loaded from either the Literal field or the AluOut as described in the following section. The format allows instruction bits 23:16 to be used to perform a flag operation and the Literal field may be used as a source for the Alu or the ram address if the new Pc value is sourced by the Alu., 423038=The \u201cjump subroutine\u201d (Jsr) instruction causes the program counter to be altered unconditionally. The new program counter (Pc) value is loaded from either the Literal field or the AluOut as described in the following section. The old program counter value is stored on the top location of the Pc-Stack which is implemented as a LIFO memory. The format allows instruction bits 23:16 to be used to perform a flag operation and the Literal field may be used as a source for the Alu or the ram address if the new Pc value is sourced by the Alu., 294839=ne2000.c\u2014The DriverEntry and miniport routines for the ne2000 portion of the INIC VPCI driver,, 50575=A 64 k server message block (SMB) request (write or read-reply) is typically made up of 44 TCP segments when running over Ethernet, which has a 1500 byte maximum transmission unit (MTU). Each of these segments may result in an interrupt to the CPU. Furthermore, since TCP must acknowledge (ACK) all of this incoming data, it's possible to get another 44 transmit-complete interrupts as a result of sending out the TCP acknowledgements. While this is possible, it is not terribly likely. Delayed ACK timers allow us to acknowledge more than one segment at a time. And delays in interrupt processing may mean that we are able to process more than one incoming network frame per interrupt. Nevertheless, even if we assume 4 incoming frames per input, and an acknowledgement for every 2 segments (as is typical per the ACK-every-other-segment property of TCP), we are still left with 33 interrupts per 64 k SMB request., 67976=If we were to choose to handle both contexts in hardware, we would have to potentially keep track of many pieces of information. One such example is a case in which a single 64 k SMB write is broken down into 44 1500 byte TCP segments, which are in turn broken down into 131 576 byte IP fragments, all of which can come in any order (though the maximum window size is likely to restrict the number of outstanding segments considerably)., 427707=The SRAM control sequencer services requests to store to, or retrieve data from an SRAM organized as 1024 locations by 128 bits (16 KB). The sequencer operates at a frequency of 133 MHz, allowing both a Cpu access and a DMA access to occur during a standard 66 MHz Cpu cycle. One 133 MHz cycle is reserved for Cpu accesses during each 66 MHz cycle while the remaining 133 MHz cycle is reserved for DMA accesses on a prioritized basis., 294966=ne2000sw.h\u2014The main software definitions for the ne2000 portion of the INIC VPCI driver,, 423611=The \u201cNxt\u201d (Nxt) instruction causes the program counter to increment. The format allows instruction bits 23:16 to be used to perform a flag operation and the Literal field may be used as a source for the Alu or the ram address., 403889=The processor instructions reside in the on-chip control-store, which is implemented as a mixture of ROM and SRAM. The ROM contains 1K instructions starting at address 0x0000 and aliases each 0x0400 locations throughout the first 0x8000 of instruction space. The SRAM (WCS) will hold up to 0x2000 instructions starting at address 0x8000 and aliasing each 0x2000 locations throughout the last 0x8000 of instruction space. The ROM and SRAM are both 49-bits wide accounting for bits [48:0] of the instruction microword. A separate mapping ram provides bits [55:49] of the microword (MapAddr) to allow replacement of faulty ROM based instructions. The mapping ram has a configuration of 128\ufffd7 which is insufficient to allow a separate map address for each of the 1K ROM locations. To allow re-mapping of the entire 1K ROM space, the map ram address lines are connected to the address bits Fetch[9:3]. The result is that the ROM is re-mapped in blocks of 8 contiguous locations., 44350=This application claims the benefit under 35 U.S.C. \ufffd120 of (is a continuation of) U.S. patent application Ser. No. 10/005,536, filed Nov. 7, 2001, now U.S. Pat. No. 7,167,926 which in turn claims the benefit under 35 U.S.C. \ufffd120 of (is a continuation of) U.S. patent application Ser. No. 09/384,792, filed Aug. 27, 1999, now U.S. Pat. No. 6,434,620 which in turn: 1) claims the benefit under 35 U.S.C. \ufffd119(e) of provisional patent application Ser. No. 60/098,296, filed Aug. 27, 1998, 2) claims the benefit under 35 U.S.C. \ufffd120 of (is a continuation-in-part of) U.S. patent application Ser. No. 09/067,544, filed Apr. 27, 1998, now U.S. Pat. No. 6,226,680 and 3) claims the benefit under 35 U.S.C. \ufffd120 of (is a continuation-in-part of) U.S. patent application Ser. No. 09/141,713, filed Aug. 28, 1998, now U.S. Pat. No. 6,389,479. The subject matter of provisional patent application Ser. No. 60/098,296, and patent application Ser. Nos. 09/067,544, 09/141,713, 09/384,792, and 10/005,536 is incorporated herein by reference., 181514=By binding the drivers in this fashion, we can choose to direct incoming network data to our own ATCP transport driver, the Microsoft TCP driver, or both. We do this by playing with the ethernet \u201ctype\u201d field as follows. To NDIS and the transport drivers above it, the INIC is registered as a normal ethernet card. When the generic TCP/IP transport driver receives a packet from the INIC driver, it will expect the data to start with an ethernet header, and consequently, expects the protocol type field to be in byte offset 12. If Microsoft TCP finds that the protocol type field is not equal to either IP, or ARP, it will not accept the packet. So, to deliver an incoming packet to our driver, we simply map the data such that byte 12 contains a non-recognized ethernet type field. Note that we choose a value that is greater than 1500 bytes so that the transport drivers do not confuse it with an 802.3 frame. We also choose a value that will not be accepted by other transport driver such as Appletalk or IPX. Similarly, if we want to direct the data to Microsoft TCP, we can then simply leave the ethernet type field set to IP (or ARP). Note that since we will also see these frames we can choose to accept or not-accept them as necessary., 78378=Clearly there are circumstances in which this does not make sense. When a small amount of data (500 bytes for example), with a push flag set indicating that the data must be delivered to the client immediately, it does not make sense to deliver some of the data directly while waiting for the list of addresses to DMA the rest. Under these circumstances, it makes more sense to deliver the 500 bytes directly to the host, and allow the host to copy it into its final destination. While various ranges are feasible, it is currently preferred that anything less than a segment's (1500 bytes) worth of data will be delivered directly to the host, while anything more will be delivered as a small piece (which may be 128 bytes), while waiting until receiving the destination memory address before moving the rest.}",
    "textBeforeTable": "Patent Citations CD Appendix D defines various bits of control information relating to DMA operations. The done bit appears in a DMA event register which the Cpu can examine. The Cpu fetches ending status from SRAM, then clears the done bit by writing zeroes to the channel command (ChCmd) register. The channel is now ready to accept another command. Each of the DMA sequencers polls all thirty two DMA channels in search of commands to execute. Once a command request has been detected, the DMA sequencer fetches a DMA descriptor from a fixed location in SRAM. The SRAM location is fixed and is determined by the DMA channel number. The DMA sequencer loads the DMA descriptor into its own registers, executes the command, then overwrites the DMA descriptor with ending status. Once the command has halted, due to completion or error, and the ending status has been written, the DMA sequencer sets the done bit for the current DMA channel. The processors manage DMA in the following way. The processor writes a DMA descriptor to an SRAM location reserved for the DMA channel. The format of the DMA descriptor is dependent upon the targeted DMA sequencer. The processor then writes the DMA sequencer number to the channel command register. Moves data from PCI bus to SRAM. P2sSeq",
    "textAfterTable": "US5163131 Sep 8, 1989 Nov 10, 1992 Auspex Systems, Inc. Parallel i/o network file server architecture US5212778 May 27, 1988 May 18, 1993 Massachusetts Institute Of Technology Message-driven processor in a concurrent computer US5280477 Aug 17, 1992 Jan 18, 1994 E-Systems, Inc. Network synchronous data distribution system US5289580 May 10, 1991 Feb 22, 1994 Unisys Corporation Programmable multiple I/O interface controller US5303344 Feb 25, 1991 Apr 12, 1994 Hitachi, Ltd. Protocol processing apparatus for use in interfacing network connected computer systems utilizing separate paths for control information and data transfer US5412782 Jul 2, 1992 May 2, 1995 3Com Corporation Programmed I/O ethernet adapter with early interrupts for accelerating data transfer US5418912 Oct 18, 1993 May 23, 1995 International Business Machines Corporation System and method for controlling buffer transmission of data packets by limiting buffered data packets in a communication session US5448566 Nov 15, 1993 Sep 5, 1995 International Business Machines",
    "hasKeyColumn": true,
    "keyColumnIndex": 2,
    "headerRowIndex": 0
}