{
    "relation": [
        [
            "Property",
            "cachePolicy",
            "dataSourceJndiName",
            "defaultCatalogName",
            "defaultSchemaName",
            "driverClassloaderName",
            "driverClassName",
            "idleTimeInSecondsBeforeTestingConnections",
            "maximumConnectionsInPool",
            "maximumConnectionIdleTimeInSeconds",
            "maximumSizeOfStatementCache",
            "metadataCollectorClassName",
            "minimumConnectionsInPool",
            "name",
            "nameOfDefaultWorkspace",
            "numberOfConnectionsToAcquireAsNeeded",
            "retryLimit",
            "password",
            "rootNodeUuid",
            "url",
            "username"
        ],
        [
            "Description",
            "Optional property that, if used, defines the cache policy to use for this repository source. When not used, this source will not define a specific duration for caching information.",
            "The JNDI name of the JDBC DataSource instance that should be used. If not specified, the other driver properties must be set.",
            "The name to use for the catalog name if the database does not support catalogs or the database has a catalog with the empty string as a name. The default value is \"default\".",
            "The name to use for the schema name if the database does not support schemas or the database has a schema with the empty string as a name. The default value is \"default\".",
            "The name of the class loader or classpath that should be used to load the JDBC driver class. This is not required if the DataSource is found in JNDI.",
            "The name of the JDBC driver class. This is not required if the DataSource is found in JNDI, but is required otherwise.",
            "The number of seconds after a connection remains in the pool that the connection should be tested to ensure it is still valid. The default is 180 seconds (or 3 minutes).",
            "The maximum number of connections that may be in the connection pool. The default is \"5\".",
            "The maximum number of seconds that a connection should remain in the pool before being closed. The default is \"600\" seconds (or 10 minutes).",
            "The maximum number of statements that should be cached. Statement caching can be disabled by setting to \"0\". The default is \"100\".",
            "The name of a custom class to use for metadata collection. The class must implement the MetadataCollector interface. If a null value is specified for this property, a default MetadataCollector implementation will be used that relies on the DatabaseMetaData provided by the JDBC driver for the connection. This property is provided as a means for connecting to databases with a JDBC driver that provides a non-standard DatabaseMetaData implementation or no DatabaseMetaData implementation at all.",
            "The minimum number of connections that will be kept in the connection pool. The default is \"0\".",
            "The name of the repository source, which is used by the RepositoryService when obtaining a RepositoryConnection by name.",
            "Optional property that is initialized to an empty string and which defines the name for the workspace that will be used by default if none is specified.",
            "The number of connections that should be added to the pool when there are not enough to be used. The default is \"1\".",
            "Optional property that, if used, defines the number of times that any single operation on a RepositoryConnection to this source should be retried following a communication failure. The default value is '0'.",
            "The password that should be used when creating JDBC connections using the JDBC driver class. This is not required if the DataSource is found in JNDI.",
            "Optional property that, if used, defines the UUID of the root node in the repository. If not used, then a new UUID is generated.",
            "The URL that should be used when creating JDBC connections using the JDBC driver class. This is not required if the DataSource is found in JNDI.",
            "The username that should be used when creating JDBC connections using the JDBC driver class. This is not required if the DataSource is found in JNDI."
        ]
    ],
    "pageTitle": "ModeShape",
    "title": "",
    "url": "http://docs.jboss.org/modeshape/1.0.0.Final/manuals/reference/html_single/reference-guide-en.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042989043.35/warc/CC-MAIN-20150728002309-00192-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 71371255,
    "recordOffset": 71213616,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{630042=The grammar for the JCR-SQL2 query language is actually a superset of that defined by the JCR 2.0 specification, and as such the complete grammar is included here., 628615=Support for the IN and NOT IN clauses to more easily and concisely supply multiple of discrete static operands. For example, \"WHERE ... [my:type].[prop1] IN (3,5,7,10,11,50) ...\". For detail, see the grammar for set constraints., 37360=One of the more popular and widely-used persistence technologies is the relational database. Relational database management systems have been around for decades and are very capable. The Java Database Connectivity (JDBC) API provides a standard interface for connecting to and interacting with relational databases. However, it is a low-level API that requires a lot of code to use correctly, and it still doesn't abstract away the DBMS-specific SQL grammar. Also, working with relational data in an object-oriented language can feel somewhat unnatural, so many developers map this data to classes that fit much more cleanly into their application. The problem is that manually creating this mapping layer requires a lot of repetitive and non-trivial JDBC code., 864889=This connector has currently been tested successfully against Oracle 10g, Oracle 11g, Microsoft SQL Server 2008 (with the Microsoft JDBC driver), IBM DB2 v9, Sybase ASE 15, MySQL 5 (with the InnoDB engine), PostgreSQL 8, and HSQLDB. As JDBC driver implementations of the DatabaseMetaData interface tend to vary widely, other databases may or may not work with the default MetadataCollector implementation. As one example, the metadataCollectorClassName property must be set to org.modeshape.connector.meta.jdbc.SqlServerMetadataConnector if the Microsoft JDBC driver is used. This is to work around a known bug where that driver returns a list of users from a call to DatabaseMetaData.getSchemas() instead of a list of schemas., 629048=Support for the BETWEEN clause to more easily and concisely supply a range of discrete operands. For example, \"WHERE ... [my:type].[prop1] BETWEEN 3 EXCLUSIVE AND 10 ...\". For detail, see the grammar for between constraints., 939506=The DDL file sequencer included in ModeShape is capable of parsing the more important DDL statements from SQL-92, Oracle, Derby, and PostgreSQL, and constructing a graph structure containing a structured representation of these statements. The resulting graph structure is largely the same for all dialects, though some dialects have non-standard additions to their grammar, and thus require dialect-specific additions to the graph structure., 619578=JCR 1.0 extends the XPath grammar to add support for ordering the results according to the natural ordering of the values of one or more properties on the nodes., 241643=The UrlEncoder converts text to be used within the different parts of a URL, as defined by Section 2.3 of RFC 2396. Note that this class does not encode a complete URL (since java.net.URLEncoder and java.net.URLDecoder should be used for such purposes)., 649915=The grammar is presented using the same EBNF nomenclature as used in the JCR 2.0 specification. Terms are surrounded by '[' and ']' denote optional terms that appear zero or one times. Terms surrounded by '{' and '}' denote terms that appear zero or more times. Parentheses are used to identify groups, and are often used to surround possible values., 647402=This query language is actually defined by the JCR 2.0 specification as the full-text search expression grammar used in the second parameter of the CONTAINS(...) function of the JCR-SQL2 language. We just pulled it out and made it available as a first-class query language., 958927=This will use all of the built-in grammars (e.g., \"standard\", \"oracle\", \"postgres\", and \"derby\"). To specify a different order or subset of the grammars, use the setProperty(...) method. Here's an example that just uses the standard grammar followed by the PostgreSQL grammar:, 627068=Additional dynamic operands \"DEPTH([<selectorName>])\" and \"PATH([<selectorName>])\" that enable placing constraints on the node depth and path, respectively. These dynamic operands can be used in a manner similar to \"NAME([<selectorName>])\" and \"LOCALNAME([<selectorName>])\" that are defined by JCR-SQL2. Note in each of these cases, the selector name is optional if there is only one selector in the query. For detail, see the grammar for dynamic operands., 625482=Support for the UNION, INTERSECT, and EXCEPT set operations on multiple result sets to form a single result set. As with standard SQL, the result sets being combined must have the same columns. The UNION operator combines the rows from two result sets, the INTERSECT operator returns the difference between two result sets, and the EXCEPT operator returns the rows that are common to two result sets. Duplicate rows are removed unless the operator is followed by the ALL keyword. For detail, see the grammar for set queries., 629459=Support for simple arithmetic in numeric-based criteria and order-by clauses. For example, \"... WHERE SCORE(type1) + SCORE(type2) > 1.0\" or \"... ORDER BY (SCORE(type1) * SCORE(type2)) ASC, LENGTH(type2.property1) DESC\". For detail, see the grammar for order-by clauses., 649576=The grammar for this full-text search language is specified in Section 6.7.19 of the JCR 2.0 specification, but it is also included here as a convenience., 646981=There are times when a formal structured query language is overkill, and the easiest way to find the right content is to perform a search, like you would with a search engine such as Google or Yahoo! This is where ModeShape's full-text search language comes in, because it allows you to use the JCR query API but with a far simpler, Google-style search grammar., 626288=Removal of duplicate rows in the results, using \"SELECT DISTINCT ...\". For detail, see the grammar for queries., 627811=Additional dynamic operand \"REFERENCE([<selectorName>.]<propertyName>)\" and \"REFERENCE([<selectorName>])\" that enables placing constraints on one or any of the reference properties, respectively, and which can be used in a manner similar to \" PropertyValue([<selectorName>.]<propertyName>)\". Note in each of these cases, the selector name is optional if there is only one selector in the query, and that the property name can be excluded if the constraint should apply to all reference properties. For detail, see the grammar for dynamic operands., 624882=Support for the \"FULL OUTER JOIN\" and \"CROSS JOIN\" join types, in addition to the \"LEFT OUTER JOIN\", \"RIGHT OUTER JOIN\" and \"INNER JOIN\" types defined by JCR-SQL2. Note that \"JOIN\" is a shorthand for \"INNER JOIN\". For detail, see the grammar for joins., 780554=This subgraph query mechanism is extremely efficient, performing one join/insert statement per level of the subgraph, and is completely independent of the number of nodes in the subgraph. For example, consider a subgraph of node A, where A has 10 children, and each child contains 10 children, and each grandchild contains 10 children. This subgraph has a total of 1111 nodes (1 root + 10 children + 10*10 grandchildren + 10*10*10 great-grandchildren). Finding the nodes in this subgraph would normally require 1 query per node (in other words, 1111 queries). But with this subgraph query mechanism, all of the nodes in the subgraph can be found with 1 insert plus 4 additional join/inserts., 630390=The grammar is presented using the same EBNF nomenclature as used in the JCR 2.0 specification. Terms are surrounded by '[' and ']' denote optional terms that appear zero or one times. Terms surrounded by '{' and '}' denote terms that appear zero or more times. Parentheses are used to identify groups, and are often used to surround possible values. Literals (or keywords) are denoted by single-quotes., 626535=Limiting the number of rows in the result set with the \"LIMIT count\" clause, where count is the maximum number of rows that should be returned. This clause may optionally be followed by the \"OFFSET number\" clause to specify the number of initial rows that should be skipped. For detail, see the grammar for limits and offsets.}",
    "lastModified": "Thu, 04 Mar 2010 20:09:06 GMT",
    "textBeforeTable": "Table\u00a019.1.\u00a0JdbcMetadataSource properties The JdbcMetadataSource class provides a number of JavaBean properties that control its behavior: To use this connector with the ModeShape JCR layer, you must import the JCR node types that this connector uses. These are bundled in the JAR for this connector at the path /org/modeshape/connector/meta/jdbc/nodeTypes.cnd. Please see the Getting Started Guide for detailed examples of how to import custom JCR node types. This connector has currently been tested successfully against Oracle 10g, Oracle 11g, Microsoft SQL Server 2008 (with the Microsoft JDBC driver), IBM DB2 v9, Sybase ASE 15, MySQL 5 (with the InnoDB engine), PostgreSQL 8, and HSQLDB. As JDBC driver implementations of the DatabaseMetaData interface tend to vary widely, other databases may or may not work with the default MetadataCollector implementation. As one example, the metadataCollectorClassName property must be set to org.modeshape.connector.meta.jdbc.SqlServerMetadataConnector if the Microsoft JDBC driver is used. This is to work around a known bug where that driver returns a list of users from a call to DatabaseMetaData.getSchemas() instead of a list of schemas. Note The root, table, column, and procedure nodes contain additional properties that correspond to the metadata provide by the DatabaseMetaData class. In databases that do not support catalogs or schemas (or allow the empty string as",
    "textAfterTable": "One way to configure the JDBC metadata connector is to create JcrConfiguration instance with a repository source that uses the JdbcMetadataSource class. For example:  JcrConfiguration\u00a0config\u00a0=\u00a0... config.repositorySource(\"Meta\u00a0Store\") \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.usingClass(JdbcMetadataSource.class) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.setDescription(\"The\u00a0database\u00a0source\u00a0for\u00a0our\u00a0content\") \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.setProperty(\"dataSourceJndiName\",\u00a0\"java:/MyDataSource\") \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.setProperty(\"nameOfDefaultWorkspace\",\u00a0\"default\"); Of course, setting other more advanced properties would entail calling setProperty(...) for each. Since almost all of the properties have acceptable default values, however, we don't need to set very many of them. Another way to configure the JDBC metadata connector is to create JcrConfiguration instance and load an XML configuration file that contains a repository source that uses the JdbcMetadataSource class. For example a file named configRepository.xml can be created with these contents:    <?xml\u00a0version=\"1.0\"\u00a0encoding=\"UTF-8\"?>  <configuration\u00a0xmlns:mode=\"http://www.modeshape.org/1.0\"\u00a0xmlns:jcr=\"http://www.jcp.org/jcr/1.0\">  \u00a0\u00a0\u00a0\u00a0<!--\u00a0  \u00a0\u00a0\u00a0\u00a0Define\u00a0the\u00a0sources\u00a0for\u00a0the\u00a0content.\u00a0\u00a0These\u00a0sources\u00a0are\u00a0directly\u00a0accessible\u00a0using\u00a0the\u00a0  \u00a0\u00a0\u00a0\u00a0ModeShape-specific\u00a0Graph\u00a0API.\u00a0\u00a0In\u00a0fact,\u00a0this\u00a0is\u00a0how\u00a0the\u00a0ModeShape\u00a0JCR\u00a0implementation\u00a0works.\u00a0\u00a0You\u00a0  \u00a0\u00a0\u00a0\u00a0can\u00a0think\u00a0of\u00a0these\u00a0as\u00a0being\u00a0similar\u00a0to\u00a0JDBC\u00a0DataSource\u00a0objects,\u00a0except\u00a0that\u00a0they\u00a0expose\u00a0  \u00a0\u00a0\u00a0\u00a0graph\u00a0content\u00a0via\u00a0the\u00a0Graph\u00a0API\u00a0instead\u00a0of\u00a0records\u00a0via\u00a0SQL\u00a0or\u00a0JDBC.\u00a0  \u00a0\u00a0\u00a0\u00a0-->  \u00a0\u00a0\u00a0\u00a0",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}