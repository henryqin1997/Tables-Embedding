{
    "relation": [
        [
            "Parameter",
            "cred",
            "pipe",
            "oldlabel",
            "newlabel"
        ],
        [
            "Description",
            "Subject credential",
            "Pipe",
            "Current policy label associated with pipe",
            "Policy label update to apply to pipe"
        ],
        [
            "Locking",
            "",
            "",
            "",
            ""
        ]
    ],
    "pageTitle": "FreeBSD Architecture Handbook",
    "title": "",
    "url": "http://www.freebsd.org/doc/en_US.ISO8859-1/books/arch-handbook/book.html",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 125,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988317.67/warc/CC-MAIN-20150728002308-00251-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 471333211,
    "recordOffset": 471141278,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampBeforeTable": "{170088=We next build boot2.s from files boot2.h, boot2.c and /usr/src/sys/boot/common/ufsread.c. The rule for this is to compile the code in boot2.c (which includes boot2.h and ufsread.c) into assembly code. Having boot2.s, the next rule assembles boot2.s, creating the object file boot2.o. The next rule directs the linker to link various files (crt0.o, boot2.o and sio.o). Note that the output file, boot2.out, is linked to execute at address 0x2000. Recall that boot2 will be executed in user mode, within a special user segment set up by the BTX server. This segment starts at 0xa000. Also, remember that the boot2 portion of boot was copied to address 0xc000, that is, offset 0x2000 from the start of the user segment, so boot2 will work properly when we transfer control to it. Next, boot2.bin is created from boot2.out by stripping its symbols and format information; boot2.bin is a raw binary. Now, note that a file boot2.ldr is created as a 512-byte file full of zeros. This space is reserved for the bsdlabel., 146326=It is important to note how the User Code Segment is defined. This segment's base address is set to 0xa000. This means that code memory addresses are relative to address 0xa000; if code being executed is fetched from address 0x2000, the actual memory addressed is 0xa000+0x2000=0xc000., 87465=Copyright \u00a9 2001 Evan Sarmiento, 264139=Copyright \u00a9 2000-2006, 2012-2013 The FreeBSD Documentation Project}",
    "TableContextTimeStampAfterTable": "{471960=If your system is going to use the network heavily, you may want to increase NMBCLUSTERS. Typical values range from 1024 to 4096., 815417=The AC97 interface is a very small hardware access (register read/write) interface, implemented by drivers for hardware with an AC97 codec. In this case, the actual MIXER interface is provided by the shared AC97 code in pcm., 838151=The AC97 interface is implemented by drivers with an AC97 codec. It only has three methods:, 858017=[1] Marshall Kirk McKusick, Keith Bostic, Michael J Karels, and John S Quarterman. Copyright \u00a9 1996 Addison-Wesley Publishing Company, Inc.. 0-201-54979-4. Addison-Wesley Publishing Company, Inc.. The Design and Implementation of the 4.4 BSD Operating System. 1-2., 559976=static int xxx_isa_suspend (device_t dev); Suspend the device before the system goes to the power-save state. May also abort transition to the power-save state., 761982=The UHCI host controller maintains a framelist with 1024 pointers to per frame data structures. It understands two different data types: transfer descriptors (TD) and queue heads (QH). Each TD represents a packet to be communicated to or from a device endpoint. QHs are a means to groupTDs (and QHs) together., 813860=Use a device_identify() method (example: sound/isa/es1888.c). The device_identify() method probes for the hardware at known addresses and, if it finds a supported device, creates a new pcm device which is then passed to probe/attach., 475331=Copyright \u00a9 2002, 2004-2005 John Baldwin, Robert Watson}",
    "lastModified": "Fri, 31 Jul 2015 23:24:44 GMT",
    "textBeforeTable": "btext calls the routines recover_bootinfo(), identify_cpu(), create_pagetables(), which are also defined in locore.s. Here is a description of what they do: mov %ax, %gs mov %ax, %fs mov %ds, %ax */ * to set %cs, %ds, %es and %ss. * Don't trust what the BIOS gives for %fs and %gs. Trust the bootstrap /* popfl pushl $PSL_KERNEL /* Don't trust what the BIOS gives for eflags. */ sys/i386/i386/locore.s: First, the register EFLAGS is set to a predefined value of 0x00000002. Then all the segment registers are initialized: NON_GPROF_ENTRY(btext) */ * * This is where the bootblocks start us, set the ball rolling... * /********************************************************************** .text sys/i386/i386/locore.s: says that a kernel's entry point is the symbol `btext'. This symbol is defined in locore.s: ENTRY(btext) sys/conf/ldscript.i386: A few interesting things can be seen here. First, the kernel is an ELF dynamically linked binary, but the dynamic linker for kernel is /red/herring, which is definitely a bogus file. Second, taking a look at the file sys/conf/ldscript.i386 gives an idea about what ld options are used when compiling a kernel. Reading through the first few lines, the string  <lots of kernel .o files> -dynamic-linker /red/herring -o kernel -X locore.o \\ ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386 -export-dynamic \\ sys/conf/Makefile.i386: Let us take a look at the command that links the kernel. This will help identify the exact location where the loader passes execution to the kernel. This location",
    "textAfterTable": "pushl\t$begin\t\t\t\t/* jump to high virtualized address */ ret /* now running relocated at KERNBASE where the system is linked to run */ begin: The function init386() is called with a pointer to the first free physical page, after that mi_startup(). init386 is an architecture dependent initialization function, and mi_startup() is an architecture independent one (the 'mi_' prefix stands for Machine Independent). The kernel never returns from mi_startup(), and by calling it, the kernel finishes booting: sys/i386/i386/locore.s: movl\tphysfree, %esi pushl\t%esi\t\t\t\t/* value of first for init386(first) */ call\t_init386\t\t\t/* wire 386 chip for unix operation */ call\t_mi_startup\t\t\t/* autoconfiguration, mountroot etc */ hlt\t\t/* never returns to here */ 1.9.1.\u00a0init386() init386() is defined in sys/i386/i386/machdep.c and performs low-level initialization specific to the i386 chip. The switch to protected mode was performed by the loader. The loader has created the very first task, in which the kernel continues to operate. Before looking at the code, consider the tasks the processor must complete to initialize protected mode execution: Initialize the kernel tunable parameters, passed from the bootstrapping program. Prepare the GDT. Prepare the IDT. Initialize the system console. Initialize the DDB, if it is compiled into kernel. Initialize the TSS. Prepare the LDT. Set up proc0's pcb. init386() initializes the tunable parameters",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}