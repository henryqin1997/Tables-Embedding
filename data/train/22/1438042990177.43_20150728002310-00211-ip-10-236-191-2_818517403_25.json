{
    "relation": [
        [
            "Caption Alignment",
            "Top Left, Middle Left or Bottom Left",
            "Top Right, Middle Right or Bottom Right",
            "Top Center",
            "Middle Center",
            "Bottom Center"
        ],
        [
            "Type of Split",
            "Vertical",
            "Vertical",
            "Horizontal",
            "None",
            "Horizontal"
        ],
        [
            "Position of Caption Relative to Split",
            "Left",
            "Right",
            "Above",
            "Centered on nominal content region",
            "Below"
        ]
    ],
    "pageTitle": "XFA-Template",
    "title": "",
    "url": "http://www.w3.org/1999/05/XFA/xfa-template",
    "hasHeader": true,
    "headerPosition": "FIRST_ROW",
    "tableType": "RELATION",
    "tableNum": 25,
    "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042990177.43/warc/CC-MAIN-20150728002310-00211-ip-10-236-191-2.ec2.internal.warc.gz",
    "recordEndOffset": 818623135,
    "recordOffset": 818517403,
    "tableOrientation": "HORIZONTAL",
    "TableContextTimeStampAfterTable": "{270866=As a concession to present day realities, the two digit years 00 to 29 are interpreted as the years 2000 to 2029, while the two digits years 30 to 99 as interpreted as the years 1930 to 1999. This is known as the century split option, and the century split year is set by default to 30; its expected that the application would be able to reconfigure the century split year. It is strongly recommended that applications interchange data with fully specified years., 1550=\u00a0\u00a9 Copyright 1999, JetForm Corporation. All rights reserved., 124089=XFA defines a form calculation-oriented scripting language, FormCalc [FORMCALC], to satisfy those who do not want to step over the programming threshold.\u00a0 Advanced users might prefer to forgo FormCalc and use one of the scripting environments available with their platform.\u00a0 However, FormCalc does have a grammar and feature set tailored specifically to the common operations that occur within forms; the result is that users of all skill levels can express powerful operations with minimal instruction and effort., 290431=From the entered data of ABC-1234-5 the value of the field would be, 282082=The first data item is a value representing the date of December 31st 1999, and the second data item is a numeric value. The picture clause uses a bracketing syntax to partition the date picture sub-clause from the numeric picture sub-clause. The left and right brace characters are reserved for this purpose, and therefore must always be quoted within a picture clause to obtain a brace literal character., 287397=However, the value of the field will remain 1275.5 regardless of the formatting. Because the value is unchanged by the formatting, dependent fields will not recalculate as a result, and any validation that has been specified for the formatted field will operate on the unformatted value., 290522=ABC12345, 270620=Date picture clauses with adjacent one letter pattern symbols, e.g., YYMD, are inherently ambiguous -- if you consider the input 99121, YYMD can be evaluated as either Jan 21, 1999 or Dec 1, 1999; such picture clauses should be avoided., 267301=Short date formats tend to be purely numeric, e.g., \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 10/2/70. Medium date formats specify use of abbreviated month names, e.g., \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 10-Feb-70, and long date formats specify use of full month names, e.g., \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 February 10, 1970. Full date formats tend to include the weekday name, as in: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Thursday, February 10, 1970., 290222=Therefore, entered data of the form ABC-1234-5 or ABC-1234-D would satisfy the input mask. Entered data of the form 123-4567-8 would not satisfy the input mask.}",
    "lastModified": "Mon, 13 Mar 2000 14:39:00 GMT",
    "textBeforeTable": "One constructs an XFA-SOM array element reference by placing square brackets after a name and enclosing within those brackets one of the following: \u00a0 XFA-SOM supports certain array syntax conventions specified here.\u00a0 Note that the XFA-SOM array referencing syntax is not necessarily the same as the array referencing syntax of scripting languages. original example, one could think of the instances of the field called Amount as belonging to a four element array and the instances of the field called Name as belonging to a five element array (recall that areas are transparent, so all instances of the field called Name are equally accessible, irrespective of the area hierarchy). XFA-SOM Array Referencing Syntax As stated already, XFA-SOM treats the collection of accessible objects with the same name as an array.\u00a0In our There is one exception to this rule.\u00a0 If a multiply-occurring field makes reference to a singly-occurring field with no explicit occurrence indication, that single occurrence is always found.\u00a0 For example, all instances of a multiply-occurring Amount field might refer to a singly-occurring Discount field. Note that it is possible to design a form where the size of the array of referencing fields is not the same as the size of the array of referenced fields.\u00a0 In such a case matching is still attempted by index number.\u00a0 So, if the reference falls within the range of referenced fields, a match is found.\u00a0 If it falls outside, it is an error. XFA-SOM treats multiply-occurring fields",
    "textAfterTable": "</Subform> <Subform Name=\"Summary\" ...> <Subform Name=\"SummaryData\" ...> <Field Name=\"Total\" ...> ... </Field> </Subform> <Subform Name=\"SummaryData\" ...> <Field Name=\"Total\" ...> ... </Field> </Subform> <Subform Name=\"SummaryData\" ...> <Field Name=\"Total\" ...> ... </Field> </Subform> </Subform> <Subform Name=\"Summary\" ...> <Subform Name=\"SummaryData\" ...> <Field Name=\"Total\" ...> ... </Field> </Subform> <Subform Name=\"SummaryData\" ...> <Field Name=\"Total\" ...> ... </Field> </Subform> <Subform Name=\"SummaryData\" ...> <Field Name=\"Total\" ...> ... </Field> </Subform> </Subform> </Subform> </Template> </XFA> Essentially, at the root level, we have two instances of a subform called Detail. Each of these contains three instances of a field called Amount. Also at the root level are two instances of a subform called Summary. Each of these contains three instances of another subform called SummaryData, each of which, in turn, contains a single instance of a field called Total. Suppose that Detail[2].Amount[3] makes an unqualified reference to Summary.\u00a0 Summary exists in the scoping context managed by the Template.\u00a0 That is an ancestral context of Amount, so Amount can access Summary by unqualified name.\u00a0 The ancestor of Amount that is a peer to Summary is Detail.\u00a0 Occurrence [2] of Detail contains the occurrence of Amount that made the reference.\u00a0 Therefore, the reference refers to Summary[2]. If the unqualified reference is itself a compound name, we walk back down the tree, using current occurrence numbers.\u00a0 Continuing with the",
    "hasKeyColumn": true,
    "keyColumnIndex": 0,
    "headerRowIndex": 0
}